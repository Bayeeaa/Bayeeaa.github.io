<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CORS跨源资源共享</title>
    <link href="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <url>/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="CORS跨源资源共享"><a href="#CORS跨源资源共享" class="headerlink" title="CORS跨源资源共享"></a>CORS跨源资源共享</h2><p>当我通过axios向目标url发送请求时候出现下面报错：</p><p><img src="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/image-20241020161909427.png" alt="访问拒绝"></p><p>Javascript代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://127.0.0.1:5000/data&#x27;</span>,<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;GET&#x27;</span>,<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到我的http请求被拒绝了。而在Status中我们可以看到CORS error这是什么？</p><h3 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS?"></a>什么是CORS?</h3><p>CORS（跨源资源共享）是一种机制，允许服务器指示浏览器允许来自不同源的请求。这通常用于保护资源，确保只有特定网站可以访问 API。那么为什么这里出现了CORS的错误呢？</p><h3 id="由于不同源"><a href="#由于不同源" class="headerlink" title="由于不同源"></a>由于不同源</h3><p>首先要有CORS这个出现(而你用request请求就不会)就是因为我们是不同源。比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">123</span>.com:<span class="hljs-number">8080</span><br><span class="hljs-attribute">http</span>://<span class="hljs-number">321</span>.com:<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>这里就是host不一样(或者你端口不一样，http和https不一样)，这就是不同源，也就是说网站不能直接共享另一个网站的数据，除非另一个网站有其他配置。那么何为同源？比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">123</span>.com:<span class="hljs-number">8080</span><br><span class="hljs-attribute">http</span>://<span class="hljs-number">123</span>.com:<span class="hljs-number">8080</span>/abab<br></code></pre></td></tr></table></figure><p>那么它就和是同源的。因此，我现在的网站文件要么就是本地服务器源，要么就是file源，总之不和目标源一样。</p><h3 id="为什么python的request请求就可以？"><a href="#为什么python的request请求就可以？" class="headerlink" title="为什么python的request请求就可以？"></a>为什么python的request请求就可以？</h3><p>由上一篇文章知道，我们的python是可以正常获取的。这是因为python不在浏览器中运行，它属于后端程序，不会触发preflight检测。</p><h3 id="何为preflight"><a href="#何为preflight" class="headerlink" title="何为preflight"></a>何为preflight</h3><p>如果你要通过这个网站得到目标网站的数据，首先网站不直接发送http请求，而是发送一个http option请求，然后目标网站的服务器会检查这个http option请求。这个过程就叫preflight。</p><h3 id="预检查流程"><a href="#预检查流程" class="headerlink" title="预检查流程"></a>预检查流程</h3><p>如果目标的服务器有配置这个来处理预检的 OPTIONS 请求，那么目标服务器就会发送一个CORS头请求，这个头请求包括：</p><ul><li><code>Access-Control-Allow-Origin</code>：指定允许的源。如果该值与请求源匹配，浏览器会继续执行实际请求。</li><li><code>Access-Control-Allow-Methods</code>：列出允许的方法（如 GET、POST）。</li><li><code>Access-Control-Allow-Headers</code>：列出允许的自定义请求头。</li></ul><p>可以看到目标服务器是可以指定允许的源，允许的方法还有允许的请求头。</p><p>然后你的浏览器接收到了这个CORS之后，会自己检查，如果符合的，就不会发送你的http请求（这也是在保护你的数据，总不能什么都不检查就把你的cookie什么发过去吧）。当然如果你的http请求都满足CORS的头请求，那么就会正常发送。</p><p><img src="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/5436ea32a234579146be2bbee96c24f.jpg" alt="流程如图"></p><p>这里再看下我的请求：</p><p><img src="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/image-20241020170533736.png" alt="控制台信息"></p><p>再结合第一张图的404，可以看出并不是我的请求不满足CORS头请求，而是目标服务器根本没做接收option请求的配置。</p><h3 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h3><p>如果我们浏览器无法直接请求，那么我是不是可以通过先通过python请求并获取目标服务器数据，然后再将获取的数据部署到本地服务器，然后再让axios去请求本地服务器的数据呢？<img src="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/9138eda93c6a9ff183eb2d72329abc8.jpg" alt="思路如上图"></p><h4 id="配置Flask"><a href="#配置Flask" class="headerlink" title="配置Flask"></a>配置Flask</h4><p>我们这里直接使用Flask框架来简单的将json数据传入本地服务器，端口就写5000好了。</p><p>main文件代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> GetScoreData <span class="hljs-keyword">import</span> send_to_server<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify<br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>():<br>    url = <span class="hljs-string">&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html？doType=query&amp;gnmkdm=N305005&quot;</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    body = &#123;<br>        <span class="hljs-string">&quot;xnm&quot;</span>: <span class="hljs-string">&quot;2023&quot;</span>,<br>        <span class="hljs-string">&quot;xqm&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>,<br>        <span class="hljs-string">&quot;queryModel.showCount&quot;</span>: <span class="hljs-string">&quot;15&quot;</span><br>    &#125;<br>    data = send_to_server(url, headers, body)<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-keyword">return</span> jsonify(data)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(port=<span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><p>但是这样可能还是有问题：</p><p><img src="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/image-20241020180407277.png" alt="由于请求过于简单，没有请求体，直接跳过了preflight，返回CORS error"></p><p>可以看到跟上文所说的一样，端口不一样也会触发preflight预检测，因此我们有两个思路：</p><ul><li>更改端口号使其一致</li><li>配置CORS</li></ul><p>如果配置CORS也非常方便，只需下载flask_cors库并在主文件中写下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_cors <span class="hljs-keyword">import</span> CORS<br>CORS(app) <span class="hljs-comment"># 允许所有来源访问</span><br></code></pre></td></tr></table></figure><p>即可允许访问。</p><p>同样你也可以将端口改成5050，这样也可以成功访问数据。</p><p><img src="/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/image-20241020180811311.png" alt="访问成功"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一键爬取个人绩点并计算平均绩点的脚本</title>
    <link href="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <url>/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="一键爬取个人绩点并计算平均绩点的脚本"><a href="#一键爬取个人绩点并计算平均绩点的脚本" class="headerlink" title="一键爬取个人绩点并计算平均绩点的脚本"></a>一键爬取个人绩点并计算平均绩点的脚本</h2><p>不知各位有没有用过下图的教务管理系统：</p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019101146167.png" alt="如图所示"></p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019101310608.png" alt="本人绩点惨不忍睹不易展示0.0"></p><p>虽然吧，你看着这个系统做的还不错，信息量非常足。但是其实我们学生并不关心什么课程代码，学年，学期这些信息，而且有个非常重要的点！它居然没有帮我们算平均绩点！这就导致每次学期结束，学校要统计综测的时候，都要用手指一个一个对着绩点按计算器，然后班长都要我们手动填表格，并让班长一个一个算出来分数，非常的让人蛋疼。</p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019102114849.png" alt="有图为证"></p><p>于是乎我就想弄一个脚本来帮我们直接刨析出各学期的绩点，并计算平均绩点、总绩点还有全年总平均绩点。</p><h3 id="使用Fiddler进行代理实现网络抓包"><a href="#使用Fiddler进行代理实现网络抓包" class="headerlink" title="使用Fiddler进行代理实现网络抓包"></a>使用Fiddler进行代理实现网络抓包</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>思路非常简单，通过Fiddler工具抓取每一次查询时接收的响应体，并找到响应体json文件中的信息，然后通过FiddlerScript(为JScript.NET语言)将响应体以txt文件形式保存到本地，然后通过python脚本解析txt文件使其可视化更强。</p><h4 id="找到包及其绩点所在位置"><a href="#找到包及其绩点所在位置" class="headerlink" title="找到包及其绩点所在位置"></a>找到包及其绩点所在位置</h4><p>点击”查询“按钮，我们在Fiddler中时刻关注此时跳出的包，经过查找，在url为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>jwxt.zufe.edu.cn<span class="hljs-regexp">/jwglxt/</span>cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005<br></code></pre></td></tr></table></figure><p>的包中有含有jd(绩点)信息，因此我们来捕捉这个包。</p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019104254571.png" alt="抓包信息获取"></p><h4 id="配置FiddlerScript将json文件下载到本地"><a href="#配置FiddlerScript将json文件下载到本地" class="headerlink" title="配置FiddlerScript将json文件下载到本地"></a>配置FiddlerScript将json文件下载到本地</h4><p>打开FiddlerScript，找到OnBeforeResponse，然后输入下面JScript.NET代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (oSession.uriContains(<span class="hljs-string">&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx&quot;</span>)) &#123;<br>    oSession.utilDecodeResponse(); <br>    <span class="hljs-type">var</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\yyn19\\Desktop\\college_score.txt&quot;</span>;<br>    oSession.SaveResponseBody(fileName);<br></code></pre></td></tr></table></figure><ul><li><p>oSession.uriContains：它检查当前会话（<code>oSession</code>）的url是否包含字符串<code>&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx&quot;</code></p></li><li><p>oSession.utilDecodeResponse()：用于将响应体（如果它是经过编码的，比如gzip压缩）解码为人类可读的形式。因为在网络传输中，为了节省带宽，数据通常会被压缩。</p></li></ul><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019104848777.png" alt="如图"></p><p>我将其下载到了桌面，当然你要下载到别处也可以。</p><h4 id="用python脚本读取"><a href="#用python脚本读取" class="headerlink" title="用python脚本读取"></a>用python脚本读取</h4><p>单纯的用肉眼读十分的费力，这时候我们再借助一下python来解析json文件。在下面的path中填入你保存文件的位置，经过刨析，就可以得到各门成绩绩点和当前学期的平均绩点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">path = <span class="hljs-string">&quot;C:\\Users\\yyn19\\Desktop\\college_score.txt&quot;</span><br>sum_score = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    content = file.read()<br>    data = json.loads(content)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;items&#x27;</span>])):<br>    <span class="hljs-built_in">print</span>(data[<span class="hljs-string">&#x27;items&#x27;</span>][i][<span class="hljs-string">&#x27;jd&#x27;</span>])<br>    sum_score += <span class="hljs-built_in">float</span>(data[<span class="hljs-string">&#x27;items&#x27;</span>][i][<span class="hljs-string">&#x27;jd&#x27;</span>])<br>    <br><span class="hljs-built_in">print</span>(sum_score/<span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;items&#x27;</span>])))<br></code></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>每一次运行脚本都需要手动点开各个学期的查询才能算出该学期的绩点平均值</li><li>需要Fiddler工具辅助</li><li>每一次都需要登录</li></ul><p>于是我就想到用python自带的request方法来进行发送网络请求。</p><h3 id="使用request库进行请求"><a href="#使用request库进行请求" class="headerlink" title="使用request库进行请求"></a>使用request库进行请求</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>我们都知道一个http请求由以下几个部分组成：</p><ol><li>‌<strong>请求行</strong>‌：包含请求方法（如GET、POST等）、URL地址和HTTP版本。例如，<code>GET /index.html HTTP/1.1</code>。</li><li>‌<strong>请求头</strong>‌：包含了一系列键值对，用于传递附加信息，如客户端可接受的MIME类型、字符集、编码方式等。常见的请求头包括<code>Accept</code>、<code>Accept-Charset</code>、<code>Content-Length</code>等‌。</li><li>‌<strong>请求体</strong>‌：包含要提交给服务器的数据。对于GET请求，请求体为空；对于POST请求，请求体包含提交的数据‌。</li></ol><p>因此，我们只需要通过浏览器自带的抓包工具，找到url等一系列请求头和请求体(有时不需要)就可以发出http请求从而拿到数据。</p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/tcp%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%8F%A1%E6%89%8B.png" alt="3次握手"></p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>首先我们先写入请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;你自己的User-Agent&quot;</span>,<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;你自己的cookie&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019111524295.png" alt="找到如图"></p><h5 id="GET请求可以吗？"><a href="#GET请求可以吗？" class="headerlink" title="GET请求可以吗？"></a>GET请求可以吗？</h5><p>然后我们直接使用GET方法发送请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;你自己的User-Agent&quot;</span>,<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;你自己的cookie&quot;</span><br>&#125;<br>response = requests.get(url,headers)<br></code></pre></td></tr></table></figure><p>这时候我们发现：</p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019112011636.png" alt="jquery文件"></p><p>竟然得到的是这个网页的前端jquery文件，很显然这不是我们需要的答案。因此我们要选用POST请求。</p><h5 id="选用POST请求"><a href="#选用POST请求" class="headerlink" title="选用POST请求"></a>选用POST请求</h5><p>由前面我们知道POST请求包含了请求体，因此更能发送完善的请求来针对性的得到数据，这里我们就要再设置一个body来加入请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">body = &#123;<br>    <span class="hljs-string">&quot;xnm&quot;</span>: <span class="hljs-string">&quot;2023&quot;</span>,<br>    <span class="hljs-string">&quot;xqm&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>,<br>    <span class="hljs-string">&quot;queryModel.showCount&quot;</span>: <span class="hljs-string">&quot;15&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019112557236.png" alt="从这里找到"></p><p>当然这里的值会随着学期和学年改变，之后完整代码用双重for循环来遍历。</p><p>然后调用request中的session，发出POST方法，并将str转化成json文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">session = requests.Session()<br>response = session.post(url, headers=headers, data=body).text<br>response_json = json.loads(response)<br></code></pre></td></tr></table></figure><p>然后我们就得到了很长一串数据，然后不断的完善修饰数据即可。</p><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/image-20241019112949660.png" alt="获得数据"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_to_server</span>(<span class="hljs-params">url, headers, body</span>):<br>    session = requests.Session()<br>    response = session.post(url, headers=headers, data=body).text<br>    response_json = json.loads(response)<br>    <span class="hljs-keyword">return</span> response_json<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_data</span>(<span class="hljs-params">response, sum_score</span>):<br>    length = <span class="hljs-built_in">len</span>(response[<span class="hljs-string">&#x27;items&#x27;</span>])<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>        subject_score = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(response[<span class="hljs-string">&#x27;items&#x27;</span>][t][<span class="hljs-string">&#x27;jd&#x27;</span>]), <span class="hljs-number">1</span>))<br>        subject = response[<span class="hljs-string">&#x27;items&#x27;</span>][t][<span class="hljs-string">&#x27;kcmc&#x27;</span>]<br>        <span class="hljs-built_in">print</span>(subject + <span class="hljs-string">&quot;：&quot;</span> +subject_score)<br>        sum_score += <span class="hljs-built_in">float</span>(response[<span class="hljs-string">&#x27;items&#x27;</span>][t][<span class="hljs-string">&#x27;jd&#x27;</span>])<br>    avg_score = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">round</span>(sum_score, <span class="hljs-number">3</span>) / <span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(response[<span class="hljs-string">&#x27;items&#x27;</span>])), <span class="hljs-number">2</span>)<br>    avg_xq_score = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">round</span>(sum_score, <span class="hljs-number">3</span>) / <span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(response[<span class="hljs-string">&#x27;items&#x27;</span>])), <span class="hljs-number">2</span>))<br>    sum_xq_score = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(sum_score, <span class="hljs-number">2</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;该学期总绩点为&quot;</span> + sum_xq_score + <span class="hljs-string">&quot;，平均绩点为&quot;</span> + avg_xq_score)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------&quot;</span>)<br>    <span class="hljs-keyword">return</span> avg_score<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetScore</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.url = <span class="hljs-string">&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot;</span><br>        self.headers = &#123;<br>            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;你自己的User-Agent&quot;</span>,<br>            <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;你自己的cookie&quot;</span><br>        &#125;<br>        self.xq_num = [<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;16&quot;</span>]<br>        self.xn_num = [<span class="hljs-string">&quot;2023&quot;</span>, <span class="hljs-string">&quot;2024&quot;</span>, <span class="hljs-string">&quot;2025&quot;</span>, <span class="hljs-string">&quot;2026&quot;</span>]<br>        self.body = &#123;<br>            <span class="hljs-string">&quot;xnm&quot;</span>: <span class="hljs-string">&quot;2023&quot;</span>,<br>            <span class="hljs-string">&quot;xqm&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>,<br>            <span class="hljs-string">&quot;queryModel.showCount&quot;</span>: <span class="hljs-string">&quot;15&quot;</span><br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">analysis_xq</span>(<span class="hljs-params">self, length, i, j</span>):<br>        <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> self.xq_num[j] == <span class="hljs-string">&quot;3&quot;</span>:<br>            <span class="hljs-built_in">print</span>(self.xn_num[i] + <span class="hljs-string">&quot;第一学年&quot;</span>)<br>        <span class="hljs-keyword">elif</span> self.xq_num[j] == <span class="hljs-string">&quot;12&quot;</span>:<br>            <span class="hljs-built_in">print</span>(self.xn_num[i] + <span class="hljs-string">&quot;第二学年&quot;</span>)<br>        <span class="hljs-keyword">elif</span> self.xq_num[j] == <span class="hljs-string">&quot;16&quot;</span>:<br>            <span class="hljs-built_in">print</span>(self.xn_num[i] + <span class="hljs-string">&quot;第三学年&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self</span>):<br>        all_avg_score = all_len = sum_score = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.xn_num)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.xq_num)):<br>                self.body[<span class="hljs-string">&quot;xnm&quot;</span>] = self.xn_num[i]<br>                self.body[<span class="hljs-string">&quot;xqm&quot;</span>] = self.xq_num[j]<br>                response = send_to_server(self.url, self.headers, self.body)<br>                length = <span class="hljs-built_in">len</span>(response[<span class="hljs-string">&#x27;items&#x27;</span>])<br>                <span class="hljs-keyword">if</span> self.analysis_xq(length, i, j) == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    all_len += <span class="hljs-number">1</span><br>                all_avg_score += print_data(response, sum_score)<br>        all_avg_score_str = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(all_avg_score / all_len, <span class="hljs-number">2</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;全年总平均绩点为：&quot;</span> + all_avg_score_str)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    score = GetScore()<br>    score.get_data()<br></code></pre></td></tr></table></figure><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/5a35d7cbbe2b42957e3f0f2bef22ba8.jpg" alt="贴纸是自己贴的0.0"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2024/10/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/10/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是计算机程序中执行的最小单位，是进程内的一个执行路径。简单来说，一个进程可以包含多个线程，它们共享进程的资源，比如内存和文件句柄，但每个线程有自己独立的栈和程序计数器。</p><h4 id="线程的特点："><a href="#线程的特点：" class="headerlink" title="线程的特点："></a>线程的特点：</h4><ol><li><strong>轻量级</strong>：线程的创建和销毁比进程更快，资源占用更少。</li><li><strong>共享资源</strong>：同一进程中的线程可以共享数据和资源，方便数据传递。</li><li><strong>并发执行</strong>：多个线程可以并发执行，充分利用多核处理器，提高程序的效率。</li><li><strong>独立性</strong>：虽然线程共享资源，但一个线程的崩溃不会直接影响到其他线程。</li></ol><h3 id="编写程序的两种方式"><a href="#编写程序的两种方式" class="headerlink" title="编写程序的两种方式"></a>编写程序的两种方式</h3><h4 id="通过继承Thread类"><a href="#通过继承Thread类" class="headerlink" title="通过继承Thread类"></a>通过继承Thread类</h4><ol><li><strong>构造方法</strong></li></ol><ul><li><code>Thread()</code>: 创建一个新线程。</li><li><code>Thread(Runnable target)</code>: 创建一个新线程并指定要执行的目标。</li><li><code>Thread(String name)</code>: 创建一个新线程并指定线程名称。</li><li><code>Thread(Runnable target, String name)</code>: 创建一个新线程，指定目标和线程名称。</li></ul><ol start="2"><li><strong>启动与运行</strong></li></ol><ul><li><code>void start()</code>: 启动线程，调用 <code>run()</code> 方法。</li><li><code>void run()</code>: 线程执行的代码，通常由 <code>Runnable</code> 接口实现。</li></ul><ol start="3"><li><strong>线程状态管理</strong></li></ol><ul><li><code>void join()</code>: 等待线程结束。</li><li><code>void join(long millis)</code>: 等待指定时间或直到线程结束。</li><li><code>void interrupt()</code>: 中断线程。</li><li><code>boolean isAlive()</code>: 检查线程是否仍在运行。</li></ul><ol start="4"><li><strong>线程信息</strong></li></ol><ul><li><code>String getName()</code>: 获取线程名称。</li><li><code>int getPriority()</code>: 获取线程优先级。</li><li><code>void setPriority(int newPriority)</code>: 设置线程优先级。</li><li><code>Thread.State getState()</code>: 获取线程当前状态。</li></ul><ol start="5"><li><strong>线程调度</strong></li></ol><ul><li><code>static void sleep(long millis)</code>: 使当前线程睡眠指定时间。</li><li><code>static void yield()</code>: 暂停当前线程，让其他线程有机会执行。</li></ul><p>​6. <strong>线程组</strong></p><ul><li><code>ThreadGroup getThreadGroup()</code>: 获取线程所属的线程组。</li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">thread_test</span><span class="hljs-params">(String name)</span>&#123; <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">//调用Tread的构造方法，把name传递给父类</span><br>        System.out.println(name+<span class="hljs-string">&quot;创建成功&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName());<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">thread_test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">thread_test</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">thread_test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">thread_test</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次运行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>创建成功<br><span class="hljs-number">2</span>创建成功<br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>第二次运行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>创建成功<br><span class="hljs-number">2</span>创建成功<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到两次运行的结果是不同的，这是因为两个线程是同时进行的，不分快慢。</p><h4 id="通过Runnable接口方法"><a href="#通过Runnable接口方法" class="headerlink" title="通过Runnable接口方法"></a>通过Runnable接口方法</h4><p>如果一个类已经继承了其他类，由于Java是单继承的，所以不能再继承Thread类，需要通过实现Runnable接口来建立线程类。</p><h5 id="定义线程类载体，并编写run-方法"><a href="#定义线程类载体，并编写run-方法" class="headerlink" title="定义线程类载体，并编写run()方法"></a>定义线程类载体，并编写run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//具体内容</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="建立线程载体对象"><a href="#建立线程载体对象" class="headerlink" title="建立线程载体对象"></a>建立线程载体对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">test</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>();<br></code></pre></td></tr></table></figure><h5 id="利用线程载体对象建立线程"><a href="#利用线程载体对象建立线程" class="headerlink" title="利用线程载体对象建立线程"></a>利用线程载体对象建立线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br></code></pre></td></tr></table></figure><h5 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t.start();<br></code></pre></td></tr></table></figure><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">thread_test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        System.out.println(name+<span class="hljs-string">&quot;创建成功&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            System.out.println(name); <span class="hljs-comment">//这个name是这个类里的name</span><br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">thread_test</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">thread_test</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">thread_test</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">thread_test</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1); <span class="hljs-comment">//需要再使用Thread类来启动线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Thread构造方法"><a href="#Thread构造方法" class="headerlink" title="Thread构造方法"></a>Thread构造方法</h4><ol><li><em>默认构造方法</em></li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>创建一个新的线程实例，但没有指定任务。</p><ol start="2"><li><em>指定Runnable对象</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Runnable target);<br></code></pre></td></tr></table></figure><p>通过实现<code>Runnable</code>接口的对象创建线程。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br></code></pre></td></tr></table></figure><ol start="3"><li><em>指定Runnable对象和线程名称</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Runnable target, String name);<br></code></pre></td></tr></table></figure><p>创建一个线程，并为它指定一个名称。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable, <span class="hljs-string">&quot;MyThread&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li><em>指定线程名称和线程组</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ThreadGroup group, Runnable target, String name);<br></code></pre></td></tr></table></figure><p>创建一个线程，并将其加入到指定的线程组。</p><ol start="5"><li><em>指定线程组、Runnable对象和线程名称</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ThreadGroup group, Runnable target, String name, <span class="hljs-type">long</span> stackSize);<br></code></pre></td></tr></table></figure><p>创建一个线程，指定线程组、Runnable任务、名称以及栈大小。</p><ol start="6"><li><em>指定优先级</em></li></ol><p>虽然构造方法中不直接设置优先级，但可以在创建线程后使用<code>setPriority(int priority)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread.setPriority(Thread.MAX_PRIORITY);<br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>线程创建后并不会执行，需要调用start方法才能启动线程，启动了之后也不一定马上运行。线程从创建到结束是有一个过程的，这个过程就称为线程的生命周期。</p><p><img src="/2024/10/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" alt="线程生命周期"></p><p>这里我们可以看到和进程的生命周期类似，但是</p><p><strong>主要区别</strong></p><ul><li><strong>资源</strong>：进程有独立的内存空间，线程共享同一进程的资源。</li><li><strong>管理</strong>：进程的创建和管理开销相对较大，线程则相对轻量。</li><li><strong>调度</strong>：线程调度通常比进程调度更频繁。</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先级是线程获得CPU调度的优先度。优先级高的线程排在线程队列的前端，优先获得处理机的控制权，可以在短时间内进入运行状态。在Java中，线程的优先级是一个整型值，用于表示线程的相对重要性。线程优先级的设置可以影响线程调度的顺序，但并不保证。优先级的范围通常是从1到10，Java提供了以下常量来表示优先级：</p><ul><li><code>Thread.MIN_PRIORITY</code>（1）</li><li><code>Thread.NORM_PRIORITY</code>（5）</li><li><code>Thread.MAX_PRIORITY</code>（10）</li></ul><h4 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h4><p>你可以通过 <code>setPriority(int newPriority)</code> 方法来设置线程的优先级，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.setPriority(Thread.MAX_PRIORITY);<br></code></pre></td></tr></table></figure><h4 id="获取线程优先级"><a href="#获取线程优先级" class="headerlink" title="获取线程优先级"></a>获取线程优先级</h4><p>使用 <code>getPriority()</code> 方法可以获取线程的优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">priority</span> <span class="hljs-operator">=</span> thread.getPriority();<br></code></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriporityDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 第 &quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;次运行&quot;</span>);<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">//让出cpu控制权</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">PriporityDemo</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriporityDemo</span>();<br>        <span class="hljs-type">PriporityDemo</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriporityDemo</span>();<br>        <span class="hljs-type">PriporityDemo</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriporityDemo</span>();<br>        t1.setPriority(Thread.MAX_PRIORITY);<br>        t2.setPriority(Thread.NORM_PRIORITY);<br>        t3.setPriority(Thread.MIN_PRIORITY);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>-<span class="hljs-number">0</span> 第 <span class="hljs-number">1</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">0</span> 第 <span class="hljs-number">2</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">0</span> 第 <span class="hljs-number">3</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">0</span> 第 <span class="hljs-number">4</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">1</span> 第 <span class="hljs-number">1</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">1</span> 第 <span class="hljs-number">2</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">1</span> 第 <span class="hljs-number">3</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">1</span> 第 <span class="hljs-number">4</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">2</span> 第 <span class="hljs-number">1</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">0</span> 第 <span class="hljs-number">5</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">1</span> 第 <span class="hljs-number">5</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">2</span> 第 <span class="hljs-number">2</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">2</span> 第 <span class="hljs-number">3</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">2</span> 第 <span class="hljs-number">4</span>次运行<br><span class="hljs-attribute">Thread</span>-<span class="hljs-number">2</span> 第 <span class="hljs-number">5</span>次运行<br></code></pre></td></tr></table></figure><p>可以看到，虽然并不是严格的按等级来运行排序，但是大致可以看出，优先级越高的获得CPU的次数越多。</p><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>线程调度是操作系统或Java虚拟机（JVM）负责管理和安排线程执行的过程。它决定了哪些线程可以运行以及它们运行的顺序。通常我们的计算机只有一个CPU，线程只有得到CPU时间片才可以执行命令。调度模式其实有两种：分时调度模式和抢占调度模式。而Java的线程调度机制是基于抢占式调度的，下面是一些关键概念：</p><ol><li><strong>调度算法</strong></li></ol><p>Java的线程调度依赖于底层操作系统的调度算法，常见的调度算法包括：</p><ul><li>时间片轮转：每个线程被分配一个时间片，时间片用完后，操作系统会切换到下一个线程。</li><li>优先级调度：根据线程的优先级来决定调度顺序，优先级高的线程有更高的机会获得CPU时间。</li><li>公平调度：确保所有线程都有机会运行，避免某些线程长时间等待。</li></ul><ol start="2"><li><strong>线程状态</strong></li></ol><p>线程的状态影响调度的方式，主要状态包括：</p><ul><li>新建状态（New）：线程被创建，但尚未启动。</li><li>就绪状态（Runnable）：线程已准备好运行，等待操作系统分配CPU。</li><li>运行状态（Running）：线程正在执行。</li><li>阻塞状态（Blocked）：线程因等待某种资源而暂停。</li><li>等待状态（Waiting）：线程等待其他线程的通知或特定条件。</li><li>死亡状态（Terminated）：线程已完成执行。</li></ul><ol start="3"><li><strong>优先级的影响</strong></li></ol><p>如前所述，线程的优先级可能会影响调度，但具体效果依赖于JVM和操作系统的实现。在许多系统中，高优先级线程会在就绪队列中获得优先权，但并不保证一定先执行。</p><ol start="4"><li><strong>Thread.sleep() 和 yield()</strong></li></ol><ul><li>Thread.sleep(milliseconds)：使当前线程暂停指定时间，允许其他线程运行。</li><li>Thread.yield()：提示调度器当前线程愿意让出CPU，允许其他同优先级的线程执行。</li></ul><ol start="5"><li><strong>使用线程池</strong></li></ol><p>在实际应用中，使用线程池（如 <code>ExecutorService</code>）可以更有效地管理线程调度，减少线程创建和销毁的开销。</p><h3 id="加锁及死锁"><a href="#加锁及死锁" class="headerlink" title="加锁及死锁"></a>加锁及死锁</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>线程加锁是用于控制对共享资源的访问，以防止线程间的竞争条件和数据不一致。Java提供了多种方式来实现加锁，最常见的是使用 <code>synchronized</code> 关键字和 <code>Lock</code> 接口。以下是主要概念：</p><h5 id="1-synchronized-同步-关键字"><a href="#1-synchronized-同步-关键字" class="headerlink" title="1. synchronized (同步)关键字"></a>1. synchronized (同步)关键字</h5><ul><li><p><strong>实例方法加锁</strong>：锁定对象的实例，确保同一时间只有一个线程能执行该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程安全的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>静态方法加锁</strong>：锁定类的对象，确保同一时间只有一个线程能执行该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程安全的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>代码块加锁</strong>：可以更灵活地锁定特定的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 线程安全的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="2-Lock-上锁-接口"><a href="#2-Lock-上锁-接口" class="headerlink" title="2. Lock (上锁)接口"></a>2. Lock (上锁)接口</h5><p><code>Lock</code> 接口提供了比 <code>synchronized</code> 更灵活的锁机制。常用的实现是 <code>ReentrantLock</code>。</p><ul><li><p><strong>获取锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>lock.lock(); <span class="hljs-comment">// 获取锁</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 线程安全的代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock(); <span class="hljs-comment">// 确保释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>公平与非公平锁</strong>：可以创建公平锁，确保按请求顺序获取锁，或非公平锁，可能会导致某些线程饿死。</p></li></ul><p>线程死锁是指两个或多个线程在执行过程中，因为争夺资源而造成一种互相等待的状态，导致它们无法继续执行。死锁是一种严重的并发问题，可能导致程序停滞不前。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>发生死锁通常需要满足以下四个条件：</p><ol><li><strong>互斥条件</strong>：至少有一个资源必须处于非共享状态，即一个资源只能被一个线程占用。</li><li><strong>保持与等待</strong>：一个线程至少持有一个资源，并等待获取其他资源。</li><li><strong>不剥夺条件</strong>：已经获得的资源在使用完之前不能被强行剥夺。</li><li><strong>环路等待</strong>：存在一组线程，每个线程持有至少一个资源并等待另一个线程持有的资源，从而形成环路。</li></ol><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>以下是一个简单的死锁示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadlockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 1: Holding lock 1...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟处理</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>                System.out.println(<span class="hljs-string">&quot;Thread 1: Waiting for lock 2...&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread 1: Acquired lock 2!&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2: Holding lock 2...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟处理</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2: Waiting for lock 1...&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread 2: Acquired lock 1!&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span> <span class="hljs-number">1</span>: Holding lock <span class="hljs-number">1</span>...<br><span class="hljs-attribute">Thread</span> <span class="hljs-number">2</span>: Holding lock <span class="hljs-number">2</span>...<br><span class="hljs-attribute">Thread</span> <span class="hljs-number">2</span>: Waiting for lock <span class="hljs-number">1</span>...<br><span class="hljs-attribute">Thread</span> <span class="hljs-number">1</span>: Waiting for lock <span class="hljs-number">2</span>...<br></code></pre></td></tr></table></figure><p>可以看到Thread1获得了lock1的锁，休眠了100ms。此时Thread2获得了lock2的锁，然后休眠100ms。Thread1休眠结束后需要lock2的锁而Thread2休眠结束后需要lock1的锁，但是各自需要的锁都被对方锁把持着，这就陷入了僵局。</p><h5 id="死锁检测与预防"><a href="#死锁检测与预防" class="headerlink" title="死锁检测与预防"></a>死锁检测与预防</h5><ol><li><strong>避免死锁</strong>：<ul><li><strong>资源有序分配</strong>：对资源进行排序，确保线程按固定顺序获取资源。</li><li><strong>使用尝试锁</strong>：使用 <code>tryLock()</code> 方法尝试获取锁，如果失败，则可以选择不等待。</li><li><strong>减少持锁时间</strong>：尽量减少持有锁的时间，避免长时间占用资源。</li></ul></li><li><strong>检测死锁</strong>：<ul><li>Java提供的 <code>ThreadMXBean</code> 可以用于检测死锁，可以查看当前线程状态并检测死锁情况。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<br><span class="hljs-keyword">import</span> java.lang.management.ThreadInfo;<br><span class="hljs-keyword">import</span> java.lang.management.ThreadMXBean;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadlockDetector</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadMXBean</span> <span class="hljs-variable">threadMXBean</span> <span class="hljs-operator">=</span> ManagementFactory.getThreadMXBean();<br>        <span class="hljs-type">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads();<br><br>        <span class="hljs-keyword">if</span> (deadlockedThreads != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> threadId : deadlockedThreads) &#123;<br>                <span class="hljs-type">ThreadInfo</span> <span class="hljs-variable">threadInfo</span> <span class="hljs-operator">=</span> threadMXBean.getThreadInfo(threadId);<br>                System.out.println(<span class="hljs-string">&quot;Deadlocked thread: &quot;</span> + threadInfo.getThreadName());<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No deadlocks detected.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程(理论篇)</title>
    <link href="/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <url>/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程-理论篇"><a href="#进程与线程-理论篇" class="headerlink" title="进程与线程(理论篇)"></a>进程与线程(理论篇)</h2><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>多道程序设计(multi-programming)是操作系统所采用的最基本、最重要的技术，其根本目的是提高整个计算机系统的效率。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">吞吐量 <span class="hljs-operator">=</span> 作业道数/全部处理时间<br></code></pre></td></tr></table></figure><p>这里的吞吐可以用来衡量系统效率。</p><h4 id="单道程序设计的问题"><a href="#单道程序设计的问题" class="headerlink" title="单道程序设计的问题"></a>单道程序设计的问题</h4><p>所谓单道程序设计，就是一次只允许一个程序进入系统的程序设计方法。显而易见，这样就有一个严重的缺点：资源利用率低。</p><ul><li>设备资源利用率低：计算机系统有许多外围设备，在单道程序中，一次只能使用外围设备中的一个子集，而未被使用的设备会被浪费。</li><li>内存资源利用率低：随着硬件技术的提升，内存容量不断扩大，如果单道程序使用这么大的内存，其内存浪费空间是惊人的。</li><li>处理器资源利用率低：单道程序设计的方式导致CPU在I&#x2F;O操作和其他阻塞期间的空闲，影响了整体资源利用率。</li></ul><p>单道程序设计还有个缺点是不能表达程序内在并行性。比如Windows中使用Word文档时，在打字时需要有下面操作：①在缓冲区交互式地编辑用户输入；②对缓冲区内用户输入内容进行语法检查；③将缓冲区的内容定时保存到磁盘上。显然如果操作一频繁，这三道程序是无法安排执行顺序的，它们其内在就是并行的。</p><h4 id="多道程序设计的提出"><a href="#多道程序设计的提出" class="headerlink" title="多道程序设计的提出"></a>多道程序设计的提出</h4><p>多道程序设计的提出源于对计算资源利用率的提升需求，尤其是在20世纪60年代初期，计算机处理速度迅速提高，而I&#x2F;O设备的速度相对较慢。为了解决单道程序设计中的低资源利用率和高等待时间问题，研究人员和工程师们开发了多道程序设计。</p><p>这种设计允许多个程序同时驻留在内存中，使得CPU可以在一个程序等待I&#x2F;O操作时，切换到另一个程序继续执行，从而充分利用处理器时间。通过这种方式，多道程序设计实现了更高的并行性和资源利用率，减少了空闲时间，并提高了系统的整体效率。最终，这种设计成为现代操作系统的基础，推动了计算机技术的发展。</p><p>相应与单道程序设计，它对以下方面都有所提升：</p><ul><li>设备资源利用率提高</li><li>内存资源利用率提高</li><li>处理器资源利用率提高</li></ul><h4 id="多道程序设计的问题"><a href="#多道程序设计的问题" class="headerlink" title="多道程序设计的问题"></a>多道程序设计的问题</h4><p>多道程序设计改善了系统资源的使用情况，从而增加了吞吐量，提高系统效率。但是也带来了新的问题：<em>资源竞争</em>。</p><p><strong>内存管理复杂性</strong>：随着多个程序同时驻留在内存中，内存分配和管理变得复杂。需要有效地管理内存，以防止内存泄漏、碎片化等问题。</p><p><strong>上下文切换开销</strong>：频繁地在多个程序之间切换会消耗CPU时间和系统资源，尤其是在上下文切换（保存和恢复程序状态）频繁的情况下，这可能导致性能下降。</p><p><strong>资源竞争</strong>：多个程序同时请求同一资源（如I&#x2F;O设备、CPU时间等），可能导致竞争和冲突，进而影响系统的稳定性和性能。</p><p><strong>调度算法复杂性</strong>：为了公平和高效地分配CPU时间，需要设计复杂的调度算法。这些算法需要考虑优先级、响应时间、周转时间等多种因素，增加了系统设计的复杂性。</p><p><strong>错误和故障传播</strong>：一个程序的错误可能会影响到整个系统的稳定性，特别是在多道程序设计中，程序之间的相互影响和依赖关系可能导致更严重的问题。</p><p><strong>调试和测试难度</strong>：在多道程序环境中，调试和测试变得更加困难，因为多个程序的交互可能导致难以重现的错误。</p><h3 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h3><p>由上述我们知道，在多道程序系统中运行的程序是一个时断时续的一个状态，其运作规律：一个程序获得处理器资源后向前推进，当它未得到某种资源时就暂停下来。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">推进→暂停→推进→暂停→...<br></code></pre></td></tr></table></figure><p>当程序暂停时，需要将其现场的信息作为断点保护起来，以便以后再次推进时能够恢复上次暂停时的现场信息并从断点处开始继续执行。这样，在多道程序设计系统中运行的程序只需要一个保存断点现场信息的区域，而这个区域并不是程序的组成部分，因此就需要一个能够更准确地描述多道程序系统中执行程序的术语，这就是<em>进程</em>(process)。</p><h4 id="状态及状态转换"><a href="#状态及状态转换" class="headerlink" title="状态及状态转换"></a>状态及状态转换</h4><p>进程的状态：</p><ul><li>运行态：进程占有处理器资源，正在运行。</li><li>就绪态：进程本身具备运行条件，但是由于处理器的数量少于可运行进程的数量，暂未投入运行</li><li>阻塞态：也称等待态、挂起态、睡眠态。进程本身不具备运行条件，即使分给其处理器也不能运行。进程正在等待一个事情发生，如等待某一资源被释放，等待与该进程相关的数据传输完成信号等。</li></ul><p>状态转换关系如下图：</p><p><img src="/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/image-20241002133250373.png" alt="进程状态转换图"></p><h4 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h4><p>进程控制块（Process Control Block, PCB）是操作系统用于管理进程的重要数据结构。它包含了一个进程在执行期间所需的所有信息，主要包括以下内容：</p><ol><li><strong>进程标识符</strong>：每个进程的唯一ID，帮助系统区分不同进程。</li><li><strong>进程状态</strong>：指示进程当前的状态，如运行、就绪、阻塞等。</li><li><strong>程序计数器</strong>：记录进程下一条将要执行的指令的地址。</li><li><strong>CPU寄存器</strong>：保存进程执行时的寄存器状态，以便在上下文切换时恢复。</li><li><strong>内存管理信息</strong>：包括进程的地址空间、页表等信息，帮助操作系统管理内存。</li><li><strong>调度信息</strong>：与进程调度相关的优先级、调度队列指针等信息。</li><li><strong>I&#x2F;O状态信息</strong>：记录进程所需的I&#x2F;O设备及其状态，帮助管理I&#x2F;O操作</li></ol><h4 id="组成与上下文"><a href="#组成与上下文" class="headerlink" title="组成与上下文"></a>组成与上下文</h4><p>进程由两个部分组成，即<em>进程控制块</em>和<em>程序</em>，其中程序包括代码和数据等。</p><ol><li><strong>程序代码</strong>：进程所执行的指令，通常存储在内存中。</li><li><strong>进程数据</strong>：用于存储程序运行时的数据，包括全局变量、局部变量和堆数据等。</li><li><strong>进程控制块（PCB）</strong>：前面提到的用于管理进程的结构，包含进程的状态、标识符、寄存器信息等。</li><li><strong>堆栈</strong>：用于存放函数调用时的局部变量和返回地址，支持程序的递归和函数调用。</li></ol><p>关于上下文，上下文是指进程在执行时的状态信息，主要包括：</p><ol><li><strong>CPU寄存器</strong>：当前寄存器的值，保存进程执行时的状态。</li><li><strong>程序计数器</strong>：指向进程下一条要执行的指令。</li><li><strong>内存映射</strong>：当前进程使用的内存空间信息。</li></ol><p>在上下文切换时，操作系统会保存当前进程的上下文（如寄存器和程序计数器），然后加载下一个进程的上下文，从而实现多进程的切换与执行。这使得多个进程能够在同一CPU上并发运行。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>进程的队列是操作系统中用于管理和调度进程的重要数据结构，通常由多种不同类型的队列组成。以下是常见的进程队列及其功能：</p><ol><li><strong>就绪队列</strong>：<ul><li>包含所有准备好运行但尚未被CPU执行的进程。</li><li>操作系统调度程序从此队列中选择进程进行调度。</li></ul></li><li><strong>阻塞队列</strong>（或等待队列）：<ul><li>包含正在等待某些事件（如I&#x2F;O操作完成、信号等）的进程。</li><li>当事件发生时，相关进程会从阻塞队列中移除并进入就绪队列。</li></ul></li><li><strong>运行队列</strong>：<ul><li>这个概念通常指的是当前正在使用CPU的进程。</li><li>在多处理器系统中，可能存在多个运行队列，每个CPU都有自己的运行队列。</li></ul></li><li><strong>新建队列</strong>：<ul><li>包含刚创建但尚未进入就绪状态的进程。</li><li>这些进程正在初始化和分配资源。</li></ul></li><li><strong>终止队列</strong>：<ul><li>包含已完成执行的进程，等待操作系统回收资源。</li><li>这些进程将被移除，相关的PCB也会被释放。</li></ul></li><li><strong>优先级队列</strong>：<ul><li>在某些调度算法中，进程根据优先级被放入不同的队列。</li><li>高优先级进程会比低优先级进程更早被调度。</li></ul></li></ol><p><img src="/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/image-20241002135320303.png" alt="进程队列模型"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol><li>创建过程</li></ol><ul><li><strong>系统调用</strong>：进程创建通常通过系统调用实现。在Unix&#x2F;Linux系统中，常用的系统调用是<code>fork()</code>。在Windows系统中，常用的调用是<code>CreateProcess()</code>。</li><li><strong>复制资源</strong>：在使用<code>fork()</code>时，操作系统会创建一个新的进程控制块（PCB）并复制父进程的资源，包括内存空间、打开的文件描述符、信号处理等。</li><li><strong>返回值</strong>：<code>fork()</code>返回值有两种情况：<ul><li>在父进程中返回子进程的进程ID。</li><li>在子进程中返回0。</li></ul></li></ul><ol start="2"><li>初始化新进程</li></ol><ul><li><strong>独立的资源</strong>：虽然子进程复制了父进程的资源，但它们是独立的。对子进程的修改不会影响父进程，反之亦然。</li><li><strong>执行新程序</strong>：子进程可以使用<code>exec()</code>系列系统调用来加载并执行一个新的程序，这个过程将替换当前进程的映像。</li></ul><ol start="3"><li>进程树</li></ol><ul><li><strong>进程间关系</strong>：进程以树形结构组织，父进程可以创建多个子进程，每个子进程也可以创建自己的子进程，形成进程树。</li><li><strong>进程ID</strong>：每个进程都有一个唯一的进程ID（PID），它用于标识和管理进程。</li></ul><ol start="4"><li>进程的终止</li></ol><ul><li><strong>子进程的终止</strong>：子进程可以通过调用<code>exit()</code>系统调用结束自己，操作系统会清理其资源，并将其状态信息保留在父进程中，以便父进程可以读取（通过<code>wait()</code>系统调用）。</li><li><strong>孤儿和僵尸进程</strong>：<ul><li><strong>孤儿进程</strong>：如果父进程先于子进程终止，子进程会成为孤儿进程，操作系统会将其父进程改为<code>init</code>进程（PID为1）。</li><li><strong>僵尸进程</strong>：如果子进程结束，但父进程未调用<code>wait()</code>来收集其状态信息，子进程会变成僵尸进程，保留在系统中以等待父进程处理。</li></ul></li></ul><h4 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h4><p>程序</p><ul><li><strong>定义</strong>：程序是一个静态的代码集合，它是由计算机语言编写的指令的集合，通常以文件的形式存储在磁盘上。程序本身并不执行，它只是一组指令和数据的描述。</li><li><strong>作用</strong>：程序的作用是定义计算机执行特定任务的步骤和逻辑。程序可以是任何形式的应用，例如文本编辑器、浏览器、游戏等。</li></ul><p>进程</p><ul><li><strong>定义</strong>：进程是程序在执行时的一个动态实例，它是程序运行时的状态，包括程序代码、程序计数器、寄存器内容、变量、堆栈、内存分配等。每个进程都有其自己的地址空间和系统资源。</li><li><strong>作用</strong>：进程是操作系统管理和调度的基本单位。它代表了程序在计算机上运行时的状态，使得多个程序可以同时运行而不相互干扰。</li></ul><p>主要区别</p><ol><li><strong>状态</strong>：<ul><li>程序是静态的，而进程是动态的。</li></ul></li><li><strong>存在形式</strong>：<ul><li>程序存在于存储介质上（如硬盘），而进程在内存中运行。</li></ul></li><li><strong>资源管理</strong>：<ul><li>程序本身不需要资源，进程则需要CPU、内存等资源来执行。</li></ul></li><li><strong>调度与执行</strong>：<ul><li>程序在需要时被加载成进程，而进程可以被调度执行、挂起或终止。</li></ul></li></ol><h3 id="线程与轻进程"><a href="#线程与轻进程" class="headerlink" title="线程与轻进程"></a>线程与轻进程</h3><p>早期的操作系统是基于进程的，一个进程中只包含一个执行流，进程是处理器调度的基本单位。当处理器由一个进程切换到另一个进程时，整个上下文都要发生变化，系统开销比较大，相关进程耦合度差。</p><p>在许多应用中，一些执行流之间具有内在逻辑关系，设计相同的代码或数据。如果将这些执行流放在同一进程的框架下，则这些执行流之间的切换便不涉及地址空间的变化，这就是线程思想的由来。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是计算机程序中的一个基本执行单元，它是进程中的一个独立运行的子任务。线程在同一进程内共享内存空间和资源，但拥有自己的执行上下文。以下是线程的一些关键概念：</p><ol><li><strong>轻量级进程</strong>：线程常被称为轻量级进程，因为它们比进程更轻便，创建和销毁的开销较小。</li><li><strong>并发性</strong>：线程允许程序同时执行多个任务，这样可以提高程序的响应性和资源利用率。例如，用户界面可以在一个线程中运行，而后台任务（如数据处理）可以在另一个线程中进行。</li><li><strong>共享资源</strong>：同一进程中的线程可以共享全局变量和堆内存，便于数据交换，但也需要小心处理以避免数据竞争和不一致性。</li><li><strong>线程状态</strong>：线程的生命周期包括多个状态，如新建、就绪、运行、阻塞和终止，操作系统根据这些状态调度线程的执行。</li><li><strong>同步和互斥</strong>：由于多个线程可能会同时访问共享资源，因此需要使用同步机制（如锁、信号量等）来防止数据不一致和竞争条件。</li><li><strong>调度</strong>：操作系统通过线程调度算法决定哪个线程获得 CPU 的使用权，以实现高效的多任务处理。</li><li><strong>优先级</strong>：线程可以设置优先级，以影响它们获得 CPU 时间的顺序。</li></ol><h4 id="线程的结构"><a href="#线程的结构" class="headerlink" title="线程的结构"></a>线程的结构</h4><p>线程的结构主要包含以下几个核心部分：</p><ol><li><strong>线程标识符（Thread ID）</strong>：<ul><li>每个线程都有一个唯一的标识符，用于区分不同的线程。</li></ul></li><li><strong>程序计数器（Program Counter, PC）</strong>：<ul><li>记录线程当前执行的指令地址。每个线程都有自己的程序计数器，以独立追踪执行位置。</li></ul></li><li><strong>堆栈（Stack）</strong>：<ul><li>每个线程拥有自己的堆栈，用于存储局部变量、方法调用的参数、返回地址等信息。堆栈在函数调用和返回时动态变化。</li></ul></li><li><strong>线程状态（Thread State）</strong>：<ul><li>线程可以处于不同状态，如新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Terminated）。这些状态反映了线程的生命周期。</li></ul></li><li><strong>优先级（Priority）</strong>：<ul><li>每个线程可以设置优先级，影响其被调度执行的顺序。操作系统使用优先级来管理线程竞争 CPU 时间。</li></ul></li><li><strong>共享资源</strong>：<ul><li>同一进程内的线程共享全局变量和堆内存，这使得线程之间可以高效通信，但也需要注意同步问题。</li></ul></li><li><strong>同步机制</strong>：<ul><li>为了避免数据竞争和确保数据一致性，线程间需要使用同步机制，如互斥锁、读写锁和信号量等。</li></ul></li><li><strong>线程本地存储（Thread Local Storage, TLS）</strong>：<ul><li>一些数据可以为每个线程单独存储，避免线程间的干扰和数据共享。</li></ul></li></ol><p><img src="/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/05980c6008d89ae1cd09d1b1dfd87a3.jpg" alt="线程结构"></p><p>注意图中的“逻辑寄存器”，这是想强调在单CPU系统中，硬件寄存器只有一套，可以理解为每个进程有一组虚拟的寄存器。</p><h4 id="控制块-1"><a href="#控制块-1" class="headerlink" title="控制块"></a>控制块</h4><p>线程控制块（Thread Control Block, TCB）是操作系统用于管理线程的重要数据结构。它包含了关于线程的关键信息，具体包括：</p><ol><li><strong>线程标识符</strong>（Thread ID）：唯一标识该线程。</li><li><strong>线程状态</strong>：记录线程的当前状态（如就绪、运行、阻塞等）。</li><li><strong>程序计数器</strong>（Program Counter, PC）：指向当前执行的指令地址。</li><li><strong>堆栈指针</strong>：指向该线程的堆栈顶部，用于管理线程的局部变量和函数调用。</li><li><strong>优先级</strong>：线程的优先级信息，用于调度。</li><li><strong>上下文信息</strong>：包括寄存器内容、调度信息等，确保线程切换时能够正确恢复状态。</li><li><strong>共享资源信息</strong>：描述该线程访问的共享资源，以管理同步和互斥。</li><li><strong>调度信息</strong>：与调度算法相关的数据，用于管理线程的执行顺序。</li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>线程有两种实现方式：在目态实现的用户级别线程，在管态实现的核心级别线程。</p><ol><li><em>用户级线程（User-Level Threads, ULT）</em></li></ol><ul><li><strong>管理方式</strong>：线程的创建和管理在用户空间进行，操作系统不直接感知这些线程。</li><li><strong>优点</strong>：上下文切换开销较小，因为切换只涉及用户态的操作；线程的创建和销毁速度快。</li><li><strong>缺点</strong>：操作系统无法调度用户级线程，如果一个线程进入阻塞状态，整个进程都会被阻塞；无法充分利用多核处理器，因为操作系统只看到进程，不了解内部线程。</li></ul><ol start="2"><li><em>内核级线程（Kernel-Level Threads, KLT）</em></li></ol><ul><li><strong>管理方式</strong>：线程的创建、管理和调度由操作系统内核完成，每个线程都有自己的内核控制块。</li><li><strong>优点</strong>：操作系统能够识别和调度每个线程，可以在多个核心上并行执行，提高性能；如果一个线程阻塞，其他线程仍可继续运行。</li><li><strong>缺点</strong>：上下文切换开销较大，因为涉及内核态和用户态之间的切换；创建和销毁线程的成本也较高。</li></ul><ol start="3"><li><em>混合线程（Hybrid Threads）</em></li></ol><ul><li><strong>管理方式</strong>：结合用户级线程和内核级线程的优势，通常采用多线程模型，如轻量级进程（LWP）。</li><li><strong>优点</strong>：用户级线程的管理提供了灵活性和快速切换，而内核级线程的调度能力使得可以有效利用多核处理器。</li><li><strong>实现</strong>：用户级线程在用户空间管理，而内核可以调度多个用户级线程至内核级线程，达到更好的性能和资源利用。</li></ul><p><img src="/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/6dea1e775725a18492126baf6234bb3.jpg" alt="用户级别线程"></p><p><img src="/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/c59639a72a1aeb3db0df74f45060f74.jpg" alt="核心级别线程"></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol><li><strong>并行处理</strong></li></ol><p>在计算密集型任务中，线程可以同时执行多个计算任务，提高整体处理速度。例如，在科学计算、图像处理和数据分析等领域，线程可以分担复杂的计算任务。</p><ol start="2"><li><strong>响应性提升</strong></li></ol><p>在用户界面（UI）应用中，使用线程可以保持界面的响应性。例如，长时间运行的任务可以在后台线程中执行，使得主线程可以继续处理用户输入。</p><ol start="3"><li><strong>服务器应用</strong></li></ol><p>在网络服务器（如Web服务器、数据库服务器）中，线程通常用于处理多个客户端请求。每个请求可以分配一个线程，使得服务器能够并发处理多个连接，提高吞吐量和响应速度。</p><ol start="4"><li><strong>实时系统</strong></li></ol><p>在实时应用中，线程可以根据优先级调度，确保高优先级任务及时响应。这在嵌入式系统、工业控制和金融交易系统中尤为重要。</p><ol start="5"><li><strong>数据处理</strong></li></ol><p>在大数据处理和流处理应用中，线程可以用于并行读取、处理和存储数据。例如，MapReduce框架利用多线程来并行处理大量数据。</p><ol start="6"><li><strong>游戏开发</strong></li></ol><p>在游戏开发中，线程用于管理多个并发任务，如渲染、物理计算和输入处理，提升游戏的性能和流畅度。</p><ol start="7"><li><strong>多媒体应用</strong></li></ol><p>在视频和音频处理应用中，线程可以并行处理音视频流，确保播放和处理的实时性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概述</title>
    <link href="/2024/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>操作系统(operation system,OS)是一个最基本也是最重要的系统软件。从虚拟机的角度来看，软件是分层次的。系统软件位于底层，应用软件位于最高层。</p><p><img src="/2024/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20240924141907645.png" alt="Windows资源监视器"></p><p>当我们打开资源监视器可以发现一个计算机在工作的时候不仅包括正在运行的软件，还包括许多下层系统进程在工作，我们软件的运行离不开这些进程的工作。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>有以下两个重要作用：</p><ul><li><strong>管理系统中的各种资源：</strong>在计算机系统中同时有多个程序在执行。这些程序在执行过程中会要用到系统中的各种资源。比如当程序1和程序2都要用到同一个地址的打印机进行输出，这就产生了冲突，这就需要一个“资源仲裁者“来负责在各个程序之间的调度，从而提高资源运行效率。</li><li><strong>为用户提供友好的界面：</strong>我们知道早期的计算机是没有图形界面的，如果要操作就非常的繁琐，如果需要编写一个c语言程序是相当困难的。有了操作系统之后，我们只需要在终端上输入几行代码就可以完成运行。随着商业化发展，操作系统提供了图形用户界面(graphic user interface, GUI)，使得计算机的操作更加简单，方便。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>操作系统也是一个程序，其主要有4个特性：</p><ul><li>并发性(concurrency)</li><li>共享性(sharing)</li><li>异步性(asynchronous)</li><li>虚拟性(virtuality)</li></ul><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><p>所谓并发就是计算机系统中同时存在多个程序。具体可以体现在下面3个方面：</p><ul><li>用户程序与用户程序之间并发执行；</li><li>用户程序与操作系统之间并发执行；</li><li>操作系统与操作系统之间并发执行。</li></ul><h5 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h5><p>程序并行要求微观上的同时，就是在同一个时刻有多个程序同时向前推进。</p><p>程序并发则是只需要在宏观上多个程序都在向前推进。</p><p>显然，要实现程序<em>并行</em>必须要有多个处理器，但是在单处理器环境中可以实现程序<em>并发</em>。这是由于并发执行的程序时按照某种次序交替地获得处理器并运行的。由于处理器的速度很快，因此从微观上看，这些程序都是在向前推进的。这些程序仿佛都有属于自己的处理器，即虚处理器。</p><h4 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h4><p>所谓资源共享，其实就是操作系统与多个用户程序公用系统中的各种资源，这种共享是在操作系统下控制实现的。对于一个给定的计算机系统来说，它的资源配置情况是相对固定的，而程序对于资源的需求则是变化的。操作系统要掌握系统中当前资源的使用情况并据此决定各个程序进入系统的次序以及使用资源的次序。</p><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><p>在操作系统之上，宏观上同时运行的程序有多个，这些程序是交替执行的。异步的反义词即同步，一个程序的执行并不是一直都顺利的，有时候会发生中断并切换到另一端操作系统程序。</p><h4 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h4><p>利用某种技术把一个物理实体变为若干个逻辑实体。例如：为在单处理器系统中同时运行多个程序，操作系统把一个实体的CPU改造成多个虚拟的CPU，每个用户仿佛拥有一个属于自己的CPU。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p><strong>多道批处理操作系统</strong>：多道批处理系统允许多个作业（程序）同时存储在内存中，并通过操作系统的管理，交替在CPU上执行。这提高了CPU的利用率和系统吞吐量。</p></li><li><p><strong>分时操作系统</strong>：分时系统允许多个用户通过各自的终端同时访问计算机系统，每个用户感觉像是独占系统资源。系统通过时间片轮转等方式公平地分配CPU时间给各个用户。</p></li><li><p><strong>实时操作系统</strong>：实时操作系统（RTOS）设计用于处理对时间要求极为严格的任务。它确保关键操作能够在给定的时间限制内完成，常用于航空航天、工业控制等领域。</p></li><li><p><strong>通用操作系统</strong>：通用操作系统是一种没有明确特定应用领域的操作系统，如Windows、Linux等，它们支持广泛的应用程序和多样化的用户群体。</p></li><li><p><strong>单用户操作系统</strong>：单用户操作系统一次只允许一个用户访问系统资源。这种系统通常用于个人计算机，如早期的DOS系统。</p></li><li><p><strong>网络操作系统</strong>：网络操作系统（NOS）负责管理网络上的硬件和软件资源，提供网络通信、资源共享和分布式处理等服务。</p></li><li><p><strong>分布式操作系统</strong>：分布式操作系统管理分布在不同计算机上的资源，这些计算机通过网络相互连接，形成一个逻辑上统一的系统。</p></li><li><p><strong>多处理操作系统</strong>：多处理操作系统能够管理多个CPU（或处理器核心），通过并行或并发执行提高系统的处理能力</p></li><li><p><strong>集群操作系统</strong>：集群操作系统将多个计算节点（服务器）连接成一个集群，通过集群管理软件来协调节点间的资源和工作负载，以提供高可用性和可扩展性。</p></li><li><p><strong>云计算操作系统</strong>：云计算操作系统是专为云计算环境设计的，它管理虚拟资源（如虚拟机、存储、网络），提供弹性计算、按需付费等特性。</p></li><li><p><strong>嵌入式操作系统</strong>：嵌入式操作系统是专为嵌入式系统设计的，这些系统通常具有特定的硬件和实时要求，如智能家居设备、手机等。</p></li><li><p><strong>多媒体操作系统</strong>：多媒体操作系统支持多媒体数据的处理、存储和传输，如音频、视频和图像的实时处理。</p></li><li><p><strong>智能卡操作系统</strong>：智能卡操作系统是运行在智能卡（如IC卡、SIM卡）上的微型操作系统，管理卡上的资源，提供安全的数据存储和访问控制。</p></li></ul><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>包括：定时装置、堆与栈、寄存器、特权指令与非特权指令、处理器状态及状态转换、地址映射机构、存储保护装置、中断装置、通道与DMA控制器。</p><p>-以下进行选择性说明。</p><h4 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h4><p><em>栈</em>（Stack）</p><ol><li>‌<strong>设计目的</strong>‌：栈主要用于存储局部变量和方法调用的上下文信息（如参数、返回地址等）。它遵循后进先出（LIFO, Last In First Out）的原则。</li><li>‌<strong>管理方式</strong>‌：栈由操作系统自动管理，包括内存的分配和释放。每当一个函数被调用时，它的参数、局部变量和返回地址等信息就会被压入栈中；当函数返回时，这些信息会从栈中弹出。这种自动管理机制简化了内存管理，但也限制了栈的使用方式。</li><li>‌<strong>存储特性</strong>‌：栈的大小在程序运行时通常是固定的，或者有一个最大限制（这取决于操作系统和程序的设计）。因此，栈上能够存储的数据量是有限的。如果尝试在栈上分配过多的数据，将会导致栈溢出（Stack Overflow）错误。</li><li>‌<strong>使用方式</strong>‌：程序员通常不需要（也无法）直接控制栈内存的分配和释放，这是由编译器和操作系统自动完成的。</li></ol><p><em>堆</em>（Heap）</p><ol><li>‌<strong>设计目的</strong>‌：堆主要用于存储程序运行期间动态分配的内存。与栈不同，堆上的内存分配和释放是由程序员控制的，这提供了更大的灵活性。</li><li>‌<strong>管理方式</strong>‌：堆的管理更加复杂，需要程序员手动管理内存的分配和释放（尽管有些现代语言如Java、C#等提供了垃圾回收机制来自动管理堆内存）。程序员可以通过调用特定的库函数（如C语言中的<code>malloc</code>和<code>free</code>，C++中的<code>new</code>和<code>delete</code>）来在堆上分配和释放内存。</li><li>‌<strong>存储特性</strong>‌：堆的大小通常比栈大得多，并且可以在程序运行时动态地增长和缩小（取决于操作系统的内存管理策略和可用内存）。然而，这也意呀着堆上的内存管理更加复杂，容易出现内存泄漏等问题。</li><li>‌<strong>使用方式</strong>‌：程序员需要负责在堆上分配和释放内存，这增加了程序的复杂性但也提供了更大的灵活性。堆上的内存可以用于存储各种类型的数据结构，如链表、树、图等。</li></ol><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>程序切换时，一般需要把寄存器的当前值保存起来，再次运行前再恢复。</p><ul><li><p>程序状态字(program status word, PSW)：</p></li><li><p>状态字（Status Word）是计算机科学中常用于表示程序、设备或系统当前状态的一种数据结构或变量。它通常包含了一系列的标志位（Flag bits），每个标志位用来表示不同的状态或条件是否被满足。通过检查这些标志位，程序可以了解系统或设备的当前状况，并据此做出相应的处理。</p><p>状态字的设计可以根据不同的应用场景而有所不同，但一般来说，它们都会包含以下几种类型的信息：</p><ol><li>‌<strong>错误码</strong>‌：用来指示操作是否成功执行，如果失败，则可能包含具体的错误代码或类型。</li><li>‌<strong>操作模式</strong>‌：指示设备或系统当前处于何种操作模式（如读模式、写模式、待机模式等）。</li><li>‌<strong>硬件状态</strong>‌：反映硬件组件（如内存、磁盘、传感器等）的当前状态（如满、空、就绪、错误等）。</li><li>‌<strong>权限级别</strong>‌：在安全敏感的应用中，可能包含用户或进程的权限级别信息。</li><li>‌<strong>特殊条件</strong>‌：如中断是否被启用、特定资源是否被锁定等。</li></ol><p>示例</p><p>假设我们有一个简单的状态字，用于表示一个数据处理模块的状态，这个状态字是一个8位的字节，设计如下：</p><ul><li>位0（最低位）：<code>0</code> 表示没有错误，<code>1</code> 表示发生错误。</li><li>位1：<code>0</code> 表示模块处于空闲状态，<code>1</code> 表示模块正在处理数据。</li><li>位2-3（共2位）：用于表示模块当前的工作模式（假设有4种模式）。</li><li>位4-7（共4位）：保留，将来可能用于其他目的或特定条件。</li></ul><p>在这个例子中，如果我们想检查模块是否处于空闲状态并且没有错误，我们可以读取状态字，并检查位0和位1是否为<code>00</code>。</p><p>编码示例（伪代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">pseudofunction check_status(status_word):<br>    if (status_word &amp; 0x01) == 0 and (status_word &amp; 0x02) == 0:<br>        return True  # 空闲且无错误<br>    else:<br>        return False<br><br># 假设 status_word 是从某处获取的<br>status_word = 0x00  # 假设的示例值<br>if check_status(status_word):<br>    print(&quot;模块处于空闲状态且没有错误。&quot;)<br>else:<br>    print(&quot;模块不在空闲状态或存在错误。&quot;)<br></code></pre></td></tr></table></figure><p>注意：上面的示例使用的是位操作（位与<code>&amp;</code>）来检查特定位的值。<code>0x01</code>是二进制<code>0000 0001</code>，<code>0x02</code>是二进制<code>0000 0010</code>，它们分别用于检查状态字的最低两位。</p></li></ul><h4 id="处理器状态及状态转换"><a href="#处理器状态及状态转换" class="headerlink" title="处理器状态及状态转换"></a>处理器状态及状态转换</h4><p>处理器状态：</p><p>为构造一个可靠的系统，硬件至少要区分两种状态：管态和目态。它由一位触发器标识，通常属于程序状态字的一部分，即由程序状态字中的一位标识。</p><p><em>目态</em>（Object Mode）</p><p>‌<strong>定义</strong>‌：<br>目态，也称为用户态或常态，是用户程序执行时CPU所处的状态。</p><p>‌<strong>特点</strong>‌：</p><ol><li>‌<strong>指令限制</strong>‌：在目态下，程序只能执行非特权指令，即那些不会直接影响到系统硬件或安全性的指令。这包括大部分的计算和数据处理指令，但不包括如I&#x2F;O操作、内存保护寄存器访问、中断控制等特权指令。</li><li>‌<strong>资源访问限制</strong>‌：用户程序不能直接使用系统资源，也不能改变CPU的工作状态。它们通常只能访问自己被分配的内存空间，而不能访问其他用户程序或操作系统的内存。</li><li>‌<strong>安全性</strong>‌：这种限制机制有助于保护系统免受恶意用户程序的破坏，确保系统的稳定性和安全性。</li></ol><p><em>管态</em>（Supervisor Mode）</p><p>‌<strong>定义</strong>‌：<br>管态，也称为特权态、系统态或核心态，是CPU在执行操作系统内核程序或进行低级硬件操作时所处的状态。</p><p>‌<strong>特点</strong>‌：</p><ol><li>‌<strong>指令全集执行</strong>‌：在管态下，CPU可以执行指令系统的全集，包括特权指令和非特权指令。这使得操作系统能够执行必要的硬件管理任务，如设备驱动、内存管理、进程调度等。</li><li>‌<strong>资源访问无限制</strong>‌：操作系统在管态下可以访问计算机的任何资源，包括所有内存空间、硬件设备以及系统级的配置信息。这种无限制的资源访问权限使得操作系统能够有效地管理整个系统。</li><li>‌<strong>系统稳定性与安全性</strong>‌：虽然管态下的权限非常广泛，但操作系统的设计和实现需要确保这些权限的合理使用，以避免系统崩溃或安全漏洞。</li></ol><p>状态转换：</p><ul><li>目态→管态：目态程序无法直接控制处理器状态的转换(修改处理器状态是个特权命令)，故需要中断。中断之后处理器状态字就处于管态。</li><li>管态→目态：可以通过修改程序状态字(置PSW)来实现</li></ul><h3 id="操作系统的界面形式"><a href="#操作系统的界面形式" class="headerlink" title="操作系统的界面形式"></a>操作系统的界面形式</h3><ul><li>交互终端命令</li><li>图形用户界面</li><li>触屏用户界面</li><li>作业控制语言</li></ul><h3 id="运行机理"><a href="#运行机理" class="headerlink" title="运行机理"></a>运行机理</h3><p>操作系统是中断驱动的，这么说，当考虑一个系统并发执行P1和P2两个程序时，若：”在t1时刻P1程序执行，在t2时刻P2程序执行，t1&lt;t2“，那么在t1-t2之间一定发生过中断，即中断时程序切换的必要条件。</p><p>实际上，P1本人并不能直接把CPU使用权交给P2，这过程需要操作系统。而操作系统取代P1成为处理器持有者的唯一途径是<em>中断</em>。</p><p>中断将引出新的程序状态字并导致系统由目态转到管态(即进入操作系统)(目态，也称为用户态或常态，是用户程序执行时CPU所处的状态;管态，也称为特权态、系统态或核心态，是CPU在执行操作系统内核程序或进行低级硬件操作时所处的状态)。</p><p>当系统中断之后，通过CPU的调度再决定执行P1或P2。</p><h3 id="系统举例"><a href="#系统举例" class="headerlink" title="系统举例"></a>系统举例</h3><p><em>Linux系统</em>：</p><p>源代码开放，免费；系统稳定、可靠；速度快，效率高；内核模块化程度高，允许第三方配置文件系统及设备管理程序；功能完善；具有网络支持优势；标准化程度高。</p><p><em>Windows 10系统</em>：</p><p>Windows10是基于NT技术构建的面向个人计算机平台的操作系统，本质上属于单用户系统，但可以组网并提供网络服务。</p><ul><li>具有多任务(包括多线程、多进程)管理功能，支持对称多处理，操作系统进程可以在任何可获得的处理器上运行，同一进程中的多个线程可以在不同处理器上同时运行。</li><li>支持客户-服务器计算模式，一台PC或工作站与一个主系统合作完成特定的服务程序。</li><li>提供友好图形化界面</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Web入门</title>
    <link href="/2024/09/22/Java-Web%E5%85%A5%E9%97%A8/"/>
    <url>/2024/09/22/Java-Web%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-Web入门"><a href="#Java-Web入门" class="headerlink" title="Java Web入门"></a>Java Web入门</h2><p>在这里我们可以学习Java程序与另一台机器上的程序对话。Java好处之一就是：通过网络发送和接收数据都是I&#x2F;O，只是I&#x2F;O链末尾的连接稍有不同。我们可以建立一个client类和一个server类来模拟服务器与客户端的数据传递。</p><h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>TCP（传输控制协议）和UDP（用户数据报协议）是两种常用的传输层协议，它们在计算机网络中负责在主机之间传输数据。它们各自有不同的特性和适用场景。以下是对它们的详细介绍：</p><h4 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h4><ul><li><strong>连接导向</strong>: TCP是一个面向连接的协议，这意味着在实际数据传输之前，必须在通信的两端建立一个连接。这个连接确保数据的可靠传输。</li><li><strong>可靠性</strong>: TCP提供可靠的数据传输，确保数据包的顺序、完整性和无丢失。在数据传输过程中，TCP会进行错误检测、重传丢失的数据包、以及保证数据包的顺序正确。</li><li><strong>流量控制</strong>: TCP通过流量控制机制来避免发送方过快地发送数据，从而防止接收方处理不及。</li><li><strong>拥塞控制</strong>: TCP还具备拥塞控制功能，能够动态调整数据传输的速率，以应对网络中的拥塞情况。</li><li><strong>数据传输</strong>: TCP将数据分段，并在接收端重新组装成完整的数据流。每个数据包都有序号，以便接收端可以按顺序重新组装数据。</li><li><strong>使用场景</strong>: 由于其可靠性，TCP适用于需要保证数据传输完整性和顺序的应用，如网页浏览（HTTP&#x2F;HTTPS）、电子邮件（SMTP）、文件传输（FTP）等。</li></ul><h4 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h4><ul><li><strong>无连接</strong>: UDP是一个无连接的协议，这意味着在数据传输之前不需要建立连接。每个数据包（称为数据报）独立发送，不保证数据的到达顺序或完整性。</li><li><strong>不可靠</strong>: UDP不提供数据包丢失的重传、顺序保证或错误校验。数据可能会丢失、重复或乱序到达。</li><li><strong>低开销</strong>: 由于UDP没有连接建立和管理的开销，相比TCP，UDP的开销更小，传输效率更高。</li><li><strong>数据传输</strong>: UDP将数据分割成数据报，每个数据报独立发送，接收端不进行重新组装，接收应用需要自行处理数据的顺序和完整性。</li><li><strong>使用场景</strong>: UDP适用于那些对数据传输速度要求高而对可靠性要求低的应用，如实时视频流、在线游戏、语音通话（VoIP）等。在这些场景中，数据传输的速度和时效性比数据的完整性更为重要。</li></ul><p>所以一般情况下，我们使用TCP协议传输较多。</p><p>关于数据传输，我们可以参考下图的TCP三次握手，当我们完成了三次握手，就说明客户端已经和服务器建立了连接，可以进行数据传输了。</p><p><img src="/2024/09/22/Java-Web%E5%85%A5%E9%97%A8/tcp%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%8F%A1%E6%89%8B.png" alt="tcp三次连接握手"></p><p>通俗的理解：</p><ul><li>客户端：听得到吗？ ——&gt; 服务器 （连接）</li><li>客户端 ——&gt; 服务器：听得到，你听的到我吗？ （接收）</li><li>客户端：可以听到，我们可以说话了 ——&gt; 服务器 （发送）</li></ul><h3 id="Web实现思路"><a href="#Web实现思路" class="headerlink" title="Web实现思路"></a>Web实现思路</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>要建立连接，我们需要知道这个服务器的IP地址和TCP端口号。当我们发送信息时Java会将二进制数据传入“网络栈”中，并向外发送请求。</p><p>我们大致的连接思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;192.164.1.103&quot;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(serverAddress);<br></code></pre></td></tr></table></figure><p>通过InetSocketAddress我们记录了所要地址的ip和端口，然后我们通过SocketChannel进行连接。注意在SocketChannel后面是SocketChannel.open(serverAddress)，说明我们并没有使用构造器来创建，而是调用了一个open()方法。这会创建一个新的SocketChannel，并把它连接到一个提供的地址。</p><p>注意：一般情况下TCP端口号在0-1023是用作公认服务的，当自己在创建服务器的时候应当尽量避免这些端口。我们使用的端口可以在1024-65535之间随便选择。</p><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><h5 id="用BufferedReader读取"><a href="#用BufferedReader读取" class="headerlink" title="用BufferedReader读取"></a>用BufferedReader读取</h5><p><code>BufferedReader</code>通过使用缓冲区来减少对底层输入流的频繁访问，从而提高读取效率。它通常会将多个字符读取到内存中，然后逐个读取，从而减少I&#x2F;O操作的开销.</p><p><strong>建立与服务器的连接(就是重复上一步)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketAddress</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(serverAddr);<br></code></pre></td></tr></table></figure><p><strong>从这个连接创建或获取一个Reader：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Channels.newReader(socketChannel,StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>这个Reader是字符流和字节流交流的桥梁，比如来自Channel的流就是字节流，链流顶端的BufferedReader就是字符流。我们在文件传输最底层是由字节流传递的，而最后由我们客户端接收显示就是要由字符流形成。也就是我们用reader将字节变成了字符。</p><p><strong>创建一个BufferedReader并读取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br></code></pre></td></tr></table></figure><p>我们用我们上一步的reader，我们知道reader此时已经是字符，我们只需再将其通过BufferedReader构造器，变成缓冲的字符，然后我们就可以再客户端读取数据了。</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><h5 id="用PrintWriter写至网络"><a href="#用PrintWriter写至网络" class="headerlink" title="用PrintWriter写至网络"></a>用PrintWriter写至网络</h5><p><strong>同样的线创建一个连接：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketAddress</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(serverAddr);<br></code></pre></td></tr></table></figure><p><strong>从连接创建或获得一个Writer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> Channels.newWriter(socketChannel,StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>Writer也同Reader一样，在字符流和字节流中间充当桥梁。</p><p><strong>创建一个PrinterWriter并打印一些内容：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">printWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(writer);<br>writer.println(<span class="hljs-string">&quot;message to send&quot;</span>);<br>writer.println(<span class="hljs-string">&quot;another message&quot;</span>);<br></code></pre></td></tr></table></figure><p>PrintWriter接收字符，然后串链到Writer，最后Writer转换字符流为字节流传递给服务器。</p><h4 id="另一种连接方式"><a href="#另一种连接方式" class="headerlink" title="另一种连接方式"></a>另一种连接方式</h4><p><strong>Socket连接：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Socket</span> <span class="hljs-variable">chatSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(chatSocket.getInputStream());<br><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(in);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(chatSocket.getOutputStream());<br><br>writer.println(<span class="hljs-string">&quot;message to send&quot;</span>);<br>writer.println(<span class="hljs-string">&quot;another message&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然我们已经有了Channel来进行连接了，为什么还要用Socket来连接呢？</p><ol><li><strong>基本概念</strong></li></ol><ul><li><strong>Socket</strong>：是Java中用于进行网络通信的传统方式。它代表一个端点，通过TCP或UDP协议在网络中进行数据传输。</li><li><strong>Channel</strong>：是Java NIO（New Input&#x2F;Output）中的一个概念，代表一个连接的打开的通道，支持非阻塞I&#x2F;O操作，能够进行更高效的文件和网络操作。</li></ul><ol start="2"><li><strong>阻塞与非阻塞</strong></li></ol><ul><li><strong>Socket</strong>：通常是阻塞的，这意味着当你进行读写操作时，调用会一直等待，直到操作完成。</li><li><strong>Channel</strong>：支持非阻塞模式，允许你在没有数据可用时继续执行其他操作。可以通过Selector管理多个Channel，从而在单个线程中处理多个连接。</li></ul><ol start="3"><li><strong>I&#x2F;O模型</strong></li></ol><ul><li><strong>Socket</strong>：使用传统的字节流或字符流进行数据的读取和写入。</li><li><strong>Channel</strong>：使用Buffer进行数据的传输，可以通过ByteBuffer和CharBuffer等直接操作内存，提高性能。</li></ul><ol start="4"><li><strong>API设计</strong></li></ol><ul><li><strong>Socket</strong>：使用较简单，适合小型或简单的网络应用。比如，通过<code>Socket</code>和<code>ServerSocket</code>类进行创建和管理连接。</li><li><strong>Channel</strong>：提供更灵活的API，如<code>SocketChannel</code>、<code>ServerSocketChannel</code>等，适合高性能应用，尤其是需要处理大量并发连接的场景。</li></ul><ol start="5"><li><strong>适用场景</strong></li></ol><ul><li><strong>Socket</strong>：适合小型应用或较为简单的网络通信需求。</li><li><strong>Channel</strong>：适合高性能的网络应用，尤其是在处理大量连接或需要非阻塞I&#x2F;O的场景。</li></ul><p>Socket适合传统、简单的网络编程，而Channel则是为了更高效的非阻塞I&#x2F;O设计的，特别是在需要处理高并发和高性能时。</p><h3 id="两个实例"><a href="#两个实例" class="headerlink" title="两个实例"></a>两个实例</h3><h4 id="服务器向客户端发送字符串"><a href="#服务器向客户端发送字符串" class="headerlink" title="服务器向客户端发送字符串"></a>服务器向客户端发送字符串</h4><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.web.Advice;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.Reader;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.Channels;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaliyAdviceClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">5000</span>); <span class="hljs-comment">//获取地址和端口</span><br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(serverAddress))&#123; <span class="hljs-comment">//尝试连接,返回字节流，赋值于socketChannel</span><br>            <span class="hljs-type">Reader</span> <span class="hljs-variable">channelReader</span> <span class="hljs-operator">=</span> Channels.newReader(socketChannel, StandardCharsets.UTF_8); <span class="hljs-comment">//channelReader读入传输数据，转为字符流</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(channelReader); <span class="hljs-comment">//BufferedReader可以显著提高读取性能,它通过在内存中维护一个缓冲区来减少对底层数据源的访问频率</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> reader.readLine(); <span class="hljs-comment">//读取行</span><br>            System.out.println(<span class="hljs-string">&quot;Today you should &quot;</span> + advice);<br>            reader.close(); <span class="hljs-comment">//关闭输入流</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaliyAdviceClient</span>().go();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.web.Advice;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.channels.Channel;<br><span class="hljs-keyword">import</span> java.nio.channels.Channels;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaliyAdviceServer</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> String[] adviceList = &#123; <span class="hljs-comment">//随机一个建议</span><br>            <span class="hljs-string">&quot;Happy&quot;</span>,<br>            <span class="hljs-string">&quot;Good&quot;</span>,<br>            <span class="hljs-string">&quot;Be yourself&quot;</span>,<br>            <span class="hljs-string">&quot;relax&quot;</span>,<br>            <span class="hljs-string">&quot;paly computer games&quot;</span><br>    &#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextAdvice</span> <span class="hljs-operator">=</span> random.nextInt(adviceList.length);<br>        <span class="hljs-keyword">return</span> adviceList[nextAdvice];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            serverChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">5000</span>));<br>            <span class="hljs-keyword">while</span>(serverChannel.isOpen())&#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> serverChannel.accept();<br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(Channels.newOutputStream(clientChannel));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> getAdvice();<br>                writer.println(advice);<br>                writer.close();<br>                System.out.println(advice);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaliyAdviceServer</span>().go();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="客户端向服务器发送字符串信息"><a href="#客户端向服务器发送字符串信息" class="headerlink" title="客户端向服务器发送字符串信息"></a>客户端向服务器发送字符串信息</h4><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.web.simplechat;<br><br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.channels.Channels;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleChatClientA</span> &#123;<br>    <span class="hljs-keyword">private</span> JTextField outgoing;<br>    <span class="hljs-keyword">private</span> PrintWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123;<br>        setUpNetworking();<br><br>        outgoing = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">//这里是在搞GUI</span><br><br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">sendButton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;Send&quot;</span>);<br>        sendButton.addActionListener(e -&gt; sendMessage());<br><br>        <span class="hljs-type">JPanel</span> <span class="hljs-variable">mainPanel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>        mainPanel.add(outgoing);<br>        mainPanel.add(sendButton);<br>        <span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;Simple Chat Client&quot;</span>);<br>        frame.getContentPane().add(BorderLayout.CENTER,mainPanel);<br>        frame.setSize(<span class="hljs-number">400</span>,<span class="hljs-number">100</span>);<br>        frame.setVisible(<span class="hljs-literal">true</span>);<br>        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUpNetworking</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">5000</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(serverAddress); <span class="hljs-comment">//socketChannel为网络通道</span><br>            writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(Channels.newWriter(socketChannel, StandardCharsets.UTF_8)); <span class="hljs-comment">//PrintWriter 是一个字符流类，用于将字符数据写入输出流</span><br>            <span class="hljs-comment">//Channels.newWriter(socketChannel, StandardCharsets.UTF_8) 创建了一个 WritableByteChannel 的字符流，这样可以将字符数据写入到与 socketChannel 关联的网络通道中。socketChannel 是一个与远程服务器连接的 SocketChannel。</span><br>            System.out.println(<span class="hljs-string">&quot;Network established&quot;</span>);<br>            writer.println(<span class="hljs-string">&quot;nihao&quot;</span>);<span class="hljs-comment">//这里测试，是将&quot;nihao&quot;输入到了服务器</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>        writer.println(outgoing.getText());<br>        writer.flush(); <span class="hljs-comment">//强制将所有缓存的输出数据写入到底层输出流中</span><br>        outgoing.setText(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//setText 是一个方法，用于设置文本组件中显示的文本内容.这里是清空 outgoing 组件中的文本</span><br>        outgoing.requestFocus(); <span class="hljs-comment">//requestFocus() 方法会将焦点设置到 outgoing 组件，使得用户可以立即开始在该组件中输入文本</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChatClientA</span>().go();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.web.simplechat;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.channels.Channels;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleChatServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;PrintWriter&gt; clientWriters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tellEveryone</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">for</span>(PrintWriter writer : clientWriters)&#123;<br>            writer.println(message);<br>            writer.flush();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientHanlder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        BufferedReader reader;<br>        SocketChannel socket;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientHanlder</span><span class="hljs-params">(SocketChannel clientSocket)</span>&#123;<br>            socket = clientSocket;<br>            reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(Channels.newReader(socket, StandardCharsets.UTF_8));<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String message;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span>((message = reader.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;read &quot;</span> + message);<br>                    tellEveryone(message);<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (IOException ex)&#123;<br>                ex.printStackTrace();<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">treadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">5000</span>));<br><br>            <span class="hljs-keyword">while</span> (serverSocketChannel.isOpen()) &#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(Channels.newWriter(clientSocket, StandardCharsets.UTF_8));<br>                clientWriters.add(writer);<br>                treadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientHanlder</span>(clientSocket));<br>                System.out.println(<span class="hljs-string">&quot;got a connection&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChatServer</span>().go();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里使用了简单的GUI使操作可视化，只需在跳出的窗口中输入字符串就可以发送到服务器，并在其终端查看内容。</p><p><img src="/2024/09/22/Java-Web%E5%85%A5%E9%97%A8/image-20240922105449103.png" alt="实例如图"></p><p>可以看到”nihao”和我刚刚输入的”123”是同时打出的，说明这个”nihao”是加入了缓冲中，然后点击”send”时最后释放。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过Github Pages上线Vite app静态项目</title>
    <link href="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="通过Github-Pages上线Vite-app静态项目"><a href="#通过Github-Pages上线Vite-app静态项目" class="headerlink" title="通过Github Pages上线Vite app静态项目"></a>通过Github Pages上线Vite app静态项目</h2><p>我们都知道通过github pages是能够免费上线一个静态项目的。但你是否有疑惑，为什么我的vue项目在本地npm run dev的时候是能够查看的，为什么我部署到github上并通过github pages却是空白的？经过尝试我发现vite所构建的项目是相当于是操作文件，而不是对外发布(public)的文件，因此我们需要进行额外的操作。</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>在vite.config.ts文件中输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">base</span>:<span class="hljs-string">&#x27;/仓库名/&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/image-20240916144907709.png" alt="如上图所示配置"></p><p>然后在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>注意要build的话就需要将所有的飘红的bug都解决掉，否则报错。</p><p>然后要是build成功，就会发现多出一个dist隐藏文件，这个dist文件就是我们需要对外部署的文件。</p><p><img src="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/image-20240916145348136.png" alt="build成功如图所示"></p><h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><p>然后我们就需要将这个文件单独出一个分支，我们约定俗成给这个分支叫做”gh-pages”，并将dis导入进这个分支。</p><p>操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add dist -f<br>git commit -m <span class="hljs-string">&quot;adding dist&quot;</span>  <br>git subtree push --prefix dist origin gh-pages<br></code></pre></td></tr></table></figure><ul><li>git add dist -f ：注意-f是强制添加(force)的意思，因为这个是隐藏文件，git会默认将其忽略掉，因此需要强制添加到缓冲区。</li><li>git commit -m “adding dist”  ：确认上传，并写入原因。</li><li>git subtree push –prefix dist origin gh-pages ：我们一个一个分析:”git subtree”用于管理项目中的子目录作为独立的 Git 树结构进行操作；”push –prefix dist”推入子文件dist(dist在整个项目中是子文件)；”origin gh-pages “是目标地，origin是仓库，gh-pages是分支</li></ul><h3 id="上线pages"><a href="#上线pages" class="headerlink" title="上线pages"></a>上线pages</h3><p>当你完成了上述git操作之后就可以在github pages里面操作了：</p><p><img src="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/image-20240916150945697.png" alt="根据步骤操作"></p><p>然后你就可以点击上面”Your site is live at https:&#x2F;&#x2F;**”，就可以访问了。</p><h3 id="静态项目更新"><a href="#静态项目更新" class="headerlink" title="静态项目更新"></a>静态项目更新</h3><p>当我们发现错误需要更新的时候，我们要知道在原vite项目和dist文件中都需要更改。首先需要在原来的vite项目中更改，然后上传至仓库。接着再重复上述的git命令上传至gh-pages里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br>git add dist -f<br>git commit -m <span class="hljs-string">&quot;adding dist&quot;</span>  <br>git subtree push --prefix dist origin gh-pages<br></code></pre></td></tr></table></figure><p>然后就可以完成网站更新了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/2024/09/03/Java-IO%E6%B5%81/"/>
    <url>/2024/09/03/Java-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-I-O流"><a href="#Java-I-O流" class="headerlink" title="Java I&#x2F;O流"></a>Java I&#x2F;O流</h2><p>I&#x2F;O流即input和output产生的流。Java程序是通过“流”的形式进行数据输入和输出。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流是一种抽象的概念，可以理解为输入&#x2F;输出的途径。I&#x2F;O部分内容是很庞大的，包括有标准的输入&#x2F;输出、文件操作、网络上的数据流、字符串流、对象流等。当程序需要读取数据时，就会开启一个通向数据源的流，这个数据源可以是文件、内存或网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。</p><h4 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h4><p>Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类表示：</p><ul><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ul><p><img src="/2024/09/03/Java-IO%E6%B5%81/08526eb1f3a09d7c36cbbed1be6c9f8.jpg" alt="Input和Output流继承关系"></p><p><img src="/2024/09/03/Java-IO%E6%B5%81/4794484f9461b73f5fa12aea1cf6443.jpg" alt="Reader和Writer流继承关系"></p><h4 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h4><p>流可分为两类：输入流和输出流。用户可以从输入流中读取信息，但不能写它。相反，对于输出流，只能往其中写，而不能读它。</p><h5 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h5><p>输入流的信息源可以位于文件、内存或网络套接字(Socket)等地方，信息源可以是对象、字符、图像、声音等。</p><h5 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h5><p>与输入流类似，程序页能通过打开一个输出流并顺序地写入数据来将信息送至目的端。</p><h4 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h4><h5 id="1-数据处理方式"><a href="#1-数据处理方式" class="headerlink" title="1. 数据处理方式"></a>1. 数据处理方式</h5><ul><li><strong>字节流</strong>：处理原始的字节数据。它适用于所有类型的数据，包括图像、音频、视频等，因为这些数据并不依赖于特定的字符编码。常见的字节流类包括 <code>InputStream</code> 和 <code>OutputStream</code> 及其子类，例如 <code>FileInputStream</code> 和 <code>FileOutputStream</code>。</li><li><strong>字符流</strong>：处理字符数据，并且能够自动处理字符编码和解码。字符流是基于字节流的封装，能将字节流转换成字符流，处理时考虑了字符编码（如 UTF-8、ISO-8859-1 等）。常见的字符流类包括 <code>Reader</code> 和 <code>Writer</code> 及其子类，例如 <code>FileReader</code> 和 <code>FileWriter</code>。</li></ul><h5 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h5><ul><li><strong>字节流</strong>：适合于二进制数据的读写，如图像、音频文件等，因为它们的数据通常不需要字符编码转换。例如，当你需要处理一个图片文件时，使用字节流是比较合适的选择。</li><li><strong>字符流</strong>：适合于文本数据的读写，尤其是当你需要处理不同字符编码时。字符流可以直接处理字符、字符串，并且会根据指定的字符集进行编码和解码。例如，当你读取或写入文本文件时，使用字符流更为方便。</li></ul><h5 id="3-处理单位"><a href="#3-处理单位" class="headerlink" title="3. 处理单位"></a>3. 处理单位</h5><ul><li><strong>字节流</strong>：以字节为单位进行读写，操作的是原始的二进制数据。</li><li><strong>字符流</strong>：以字符为单位进行读写，操作的是文本数据，并会进行字符编码的转换</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>在前面我们知道I&#x2F;O类中所有对字节流处理的类，都继承与InputStream类和OutputStream类。</p><h4 id="InputStream类"><a href="#InputStream类" class="headerlink" title="InputStream类"></a>InputStream类</h4><p><code>InputStream</code> 是 Java 中用于读取字节流的抽象类。它是所有字节输入流类的超类，提供了基本的输入流操作方法。<code>InputStream</code> 类的设计使得你可以从各种数据源（如文件、网络、内存等）读取字节数据。以下是关于 <code>InputStream</code> 类的一些关键点：</p><ol><li><p><strong><code>int read()</code></strong></p><ul><li><p>读取下一个字节的数据。</p></li><li><p>如果流末尾已到达，返回 <code>-1</code>。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> inputStream.read();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>int read(byte[] b)</code></strong></p><ul><li><p>从输入流中读取数据到字节数组中。</p></li><li><p>返回实际读取的字节数，如果流末尾已到达，返回 <code>-1</code>。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inputStream.read(buffer);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>int read(byte[] b, int off, int len)</code></strong></p><ul><li><p>从输入流中读取数据到字节数组中的指定位置。</p></li><li><p>参数 <code>off</code> 指定写入数据的起始位置，<code>len</code> 指定最大读取字节数。</p></li><li><p>返回实际读取的字节数，如果流末尾已到达，返回 <code>-1</code>。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inputStream.read(buffer, <span class="hljs-number">0</span>, buffer.length);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void close()</code></strong></p><ul><li><p>关闭输入流并释放与之关联的系统资源。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">inputStream.close();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>long skip(long n)</code></strong></p><ul><li><p>跳过并丢弃输入流中的 <code>n</code> 个字节。</p></li><li><p>返回实际跳过的字节数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">skipped</span> <span class="hljs-operator">=</span> inputStream.skip(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>available()</code></strong></p><ul><li><p>返回流中当前可读的字节数，但不一定能保证实际读取的字节数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">availableBytes</span> <span class="hljs-operator">=</span> inputStream.available();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>常见子类：</p><ul><li><code>FileInputStream</code>：从文件中读取字节流。</li><li><code>ByteArrayInputStream</code>：从内存中的字节数组中读取字节流。</li><li><code>BufferedInputStream</code>：提供缓冲功能的输入流，能提高读取效率。</li><li><code>DataInputStream</code>：提供读取 Java 原始数据类型的输入流。</li></ul><p>示例：</p><p>以下是一个简单的使用 <code>FileInputStream</code> 类读取文件内容的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">int</span> content;<br>            <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 打印读取的字节（转换为字符）</span><br>                System.out.print((<span class="hljs-type">char</span>) content);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>InputStream</code> 是一个抽象类，不能直接实例化。通常，你会使用其具体子类来进行实际的字节读取操作。</li><li>操作完成后，一定要关闭流，以释放系统资源。这通常通过 <code>try-with-resources</code> 语句来自动完成。</li></ul><h4 id="OutputStream类"><a href="#OutputStream类" class="headerlink" title="OutputStream类"></a>OutputStream类</h4><p><code>OutputStream</code> 是 Java 中用于写入字节流的抽象类。它是所有字节输出流类的超类，提供了基本的输出流操作方法。<code>OutputStream</code> 类的设计使得你可以将字节数据写入各种数据目标，如文件、网络连接、内存等。以下是 <code>OutputStream</code> 类的一些关键点：</p><ol><li><p><strong><code>void write(int b)</code></strong></p><ul><li><p>将指定的字节写入输出流。</p></li><li><p>参数 <code>b</code> 是要写入的字节（实际上是一个 <code>int</code> 值，但只使用低 8 位）。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outputStream.write(<span class="hljs-number">65</span>); <span class="hljs-comment">// 写入字节 &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(byte[] b)</code></strong></p><ul><li><p>将字节数组中的所有字节写入输出流。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes();<br>outputStream.write(data);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(byte[] b, int off, int len)</code></strong></p><ul><li><p>将字节数组中的一部分写入输出流。</p></li><li><p>参数 <code>off</code> 是字节数组中的起始偏移量，<code>len</code> 是要写入的字节数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = <span class="hljs-string">&quot;Hello World&quot;</span>.getBytes();<br>outputStream.write(data, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void flush()</code></strong></p><ul><li><p>刷新输出流，确保所有缓冲的字节都被写入到目标地。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outputStream.flush();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void close()</code></strong></p><ul><li><p>关闭输出流并释放与之关联的系统资源。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outputStream.close();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>常见子类：</p><ul><li><code>FileOutputStream</code>：将字节写入文件。</li><li><code>ByteArrayOutputStream</code>：将字节写入内存中的字节数组。</li><li><code>BufferedOutputStream</code>：提供缓冲功能的输出流，能提高写入效率。</li><li><code>DataOutputStream</code>：提供写入 Java 原始数据类型的输出流。</li></ul><p>示例：</p><p>以下是一个简单的使用 <code>FileOutputStream</code> 类写入文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriteExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>            fos.write(content.getBytes());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:</p><ol><li><strong>关闭流</strong>：使用完 <code>OutputStream</code> 后一定要关闭流，以释放系统资源。通常使用 <code>try-with-resources</code> 语句来自动关闭流。</li><li><strong>缓冲</strong>：如果你需要提高写入效率，可以使用 <code>BufferedOutputStream</code> 进行缓冲操作。</li><li><strong>写入数据</strong>：在写入数据时，可以选择将字节数组、单个字节或字节数组的部分写入流。确保正确处理偏移量和长度，以避免写入不必要的数据或产生异常。</li></ol><p><code>OutputStream</code> 提供了处理字节数据的基本操作，了解其使用方法可以帮助你在处理文件、网络和其他数据目标时有效地输出字节数据。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>InputStream和OutputStream在早期的Java版本中就已经存在了，它们是基于字节流的，而基于字符流的Reader和Writer是后来加入作为补充的。</p><h4 id="Rreader类"><a href="#Rreader类" class="headerlink" title="Rreader类"></a>Rreader类</h4><p><code>Reader</code> 类是 Java 中用于处理字符流的抽象类。它是所有字符输入流类的超类，提供了基本的字符读取操作方法。与 <code>InputStream</code> 类不同，<code>Reader</code> 处理的是字符而不是原始字节，因此它会根据指定的字符编码进行字符转换。</p><p>其主要操作方法有下述几种，因与IO类类似，故其不在赘述。</p><ol><li><code>int read()</code></li><li><code>int read(char[] cbuf)</code></li><li><code>int read(char[] cbuf, int off, int len)</code></li><li><code>long skip(long n)</code></li><li><code>boolean ready()</code></li><li><code>void close()</code></li></ol><p>常见子类:</p><ul><li><code>FileReader</code>：从文件中读取字符流。</li><li><code>BufferedReader</code>：提供缓冲功能的字符流，能提高读取效率，并且提供了 <code>readLine()</code> 方法以便逐行读取文本。</li><li><code>CharArrayReader</code>：从内存中的字符数组中读取字符流。</li><li><code>StringReader</code>：从内存中的字符串读取字符流。</li></ul><p>示例:</p><p>以下是一个简单的使用 <code>FileReader</code> 类读取文件内容的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">int</span> character;<br>            <span class="hljs-keyword">while</span> ((character = fr.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) character);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>BufferedReader</code> 逐行读取文本的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;example.txt&quot;</span>))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p><strong>字符编码</strong>：<code>Reader</code> 类会处理字符编码问题，因此在读取文件时，确保文件编码与你的 <code>Reader</code> 配置一致。</p><p><strong>关闭流</strong>：使用完 <code>Reader</code> 后，一定要关闭流以释放系统资源。通常使用 <code>try-with-resources</code> 语句来自动关闭流。</p><p><strong>缓冲</strong>：为了提高读取效率，可以使用 <code>BufferedReader</code> 类，它提供了缓冲功能，并且能更高效地读取数据。</p><h4 id="Writer类"><a href="#Writer类" class="headerlink" title="Writer类"></a>Writer类</h4><p><code>Writer</code> 类是 Java 中用于处理字符流的抽象类。它是所有字符输出流类的超类，提供了基本的字符输出操作方法。与 <code>OutputStream</code> 类不同，<code>Writer</code> 处理的是字符数据，而不是原始的字节数据，因此它会根据指定的字符编码进行字符转换。</p><ol><li><p><strong><code>void write(int c)</code></strong></p><ul><li><p>将指定的字符写入输出流。</p></li><li><p>参数 <code>c</code> 是要写入的字符（实际是一个 <code>int</code> 值，但只使用低 16 位）。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.write(<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">// 写入字符 &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(char[] cbuf)</code></strong></p><ul><li><p>将字符数组中的所有字符写入输出流。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] data = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray();<br>writer.write(data);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(char[] cbuf, int off, int len)</code></strong></p><ul><li><p>将字符数组中的一部分写入输出流。</p></li><li><p>参数 <code>off</code> 是字符数组中的起始偏移量，<code>len</code> 是要写入的字符数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] data = <span class="hljs-string">&quot;Hello World&quot;</span>.toCharArray();<br>writer.write(data, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(String str)</code></strong></p><ul><li><p>将字符串中的所有字符写入输出流。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(String str, int off, int len)</code></strong></p><ul><li><p>将字符串的指定部分写入输出流。</p></li><li><p>参数 <code>off</code> 是字符串中的起始位置，<code>len</code> 是要写入的字符数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void flush()</code></strong></p><ul><li><p>刷新输出流，确保所有缓冲的字符都被写入到目标地。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.flush();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void close()</code></strong></p><ul><li><p>关闭输出流并释放与之关联的系统资源。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.close();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>常见子类:</p><ul><li><code>FileWriter</code>：将字符写入文件。</li><li><code>BufferedWriter</code>：提供缓冲功能的字符流，能提高写入效率。</li><li><code>CharArrayWriter</code>：将字符写入内存中的字符数组。</li><li><code>PrintWriter</code>：提供了更多格式化功能的字符输出流，支持打印各种数据类型。</li></ul><p>示例:</p><p>以下是一个简单的使用 <code>FileWriter</code> 类写入文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriteExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            fw.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>BufferedWriter</code> 提高写入效率的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;example.txt&quot;</span>))) &#123;<br>            bw.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>            bw.newLine(); <span class="hljs-comment">// 添加新行</span><br>            bw.write(<span class="hljs-string">&quot;This is a new line.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><strong>字符编码</strong>：<code>Writer</code> 类会处理字符编码问题，因此在写入文件时，确保文件编码与你的 <code>Writer</code> 配置一致。如果需要特定的编码格式，可以使用 <code>OutputStreamWriter</code> 类来指定编码。</li><li><strong>关闭流</strong>：使用完 <code>Writer</code> 后，一定要关闭流以释放系统资源。通常使用 <code>try-with-resources</code> 语句来自动关闭流。</li><li><strong>缓冲</strong>：为了提高写入效率，可以使用 <code>BufferedWriter</code> 类，它提供了缓冲功能，并能更高效地写入数据。</li></ol><h3 id="实现用户输入"><a href="#实现用户输入" class="headerlink" title="实现用户输入"></a>实现用户输入</h3><p>Java提供了java.util.Scanner类，可以直接接收控制台命令行的输入。</p><h4 id="使用System-in获取用户输入"><a href="#使用System-in获取用户输入" class="headerlink" title="使用System.in获取用户输入"></a>使用System.in获取用户输入</h4><p>Java提供了System.in、System.out及System.err类。</p><p>System.out是一个已经预先处理过的、被包装成PrintStream的对象。</p><p>System.err和System.out一样，也是一个PrintStream。</p><p>但System.in就不是了，它是一个未经处理的InputStream。</p><p>System.in输入示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System_test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">char</span> a;<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>);<br>        a=(<span class="hljs-type">char</span>)System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;输入的是&quot;</span> + a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用Scanner类获取用户输入"><a href="#使用Scanner类获取用户输入" class="headerlink" title="使用Scanner类获取用户输入"></a>使用Scanner类获取用户输入</h4><p>java.util.Scanner类是JDK新增的一个类，可使用该类创建一个命令行读取数据的对象，而不必再进行流的转换。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scannner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure><p>然后我们就可以对sc进行调用操作，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextLine();<br></code></pre></td></tr></table></figure><p>这里我们注意了，可以有多种调用方式：</p><ul><li>next()：字符串</li><li>nextInt()：整型</li><li>nextDouble()：浮点型</li><li>nextLine()：字符串，但可以读入空格</li></ul><h3 id="在绝对路径创建文件夹，并创建一个临时txt文件"><a href="#在绝对路径创建文件夹，并创建一个临时txt文件" class="headerlink" title="在绝对路径创建文件夹，并创建一个临时txt文件"></a>在绝对路径创建文件夹，并创建一个临时txt文件</h3><ul><li>FileCreateAndDir.java：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.IO_test;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCreateAndDir</span> &#123; <span class="hljs-comment">//文件创建和目录</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createDir</span><span class="hljs-params">(String destDirName)</span>&#123; <span class="hljs-comment">//创建目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(destDirName);<br>        <span class="hljs-keyword">if</span>(dir.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标目录存在！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!destDirName.endsWith(File.separator))&#123; <span class="hljs-comment">//结尾是否以&quot;/&quot;结束</span><br>            destDirName = destDirName + File.separator;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dir.mkdir())&#123; <span class="hljs-comment">//这里创建目录，并返回true</span><br>            System.out.println(<span class="hljs-string">&quot;目录成功创建！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;创建失败！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createFile</span><span class="hljs-params">(String filePath)</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(file.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标文件已存在！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(filePath.endsWith(File.separator))&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标文件不能是文件！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!file.getParentFile().exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标文件文件夹不存在，正在创建它！&quot;</span>);<br>            <span class="hljs-keyword">if</span>(!file.getParentFile().mkdir())&#123;<br>                System.out.println(<span class="hljs-string">&quot;创建目标文件失败！&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(file.createNewFile())&#123;<br>                System.out.println(<span class="hljs-string">&quot;文件创建成功！&quot;</span> + filePath);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;文件创建失败！&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>test：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.IO_test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dirPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\yyn19\\Desktop\\demoTest&quot;</span>;<br>        FileCreateAndDir.createDir(dirPath); <span class="hljs-comment">// 创建目录</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> dirPath + File.separator + <span class="hljs-string">&quot;myfile.txt&quot;</span>; <span class="hljs-comment">// 文件路径,并给出文件名</span><br>        FileCreateAndDir.createFile(filePath); <span class="hljs-comment">// 创建文件</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2024/08/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/08/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>集合有时又称容方法，简单地说就是个对象，能将具有相同性质的多个元素汇聚成一个整体。</p><p>集合框架(Collections Framework)是用来表现和操纵集合的一个统一的体系结构。</p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>Collection接口时Java集合框架的最顶层接口，它位于<code>java.util</code>包中，是Set接口和List接口(后面会讲)的父接口。</p><h4 id="转换构造法"><a href="#转换构造法" class="headerlink" title="转换构造法"></a>转换构造法</h4><p>Collection接口实现都有一个带有集合参数的构造方法。也就是说，在这里可以通过”转换”集合的类型来实现存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>a可以是一个List、Set或另外一中Collection。通常，习惯地创建一个新的ArrayList，初始化为包含a中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(a);<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;(a);<br></code></pre></td></tr></table></figure><p>通过“转换构造法”，list或set对象就包含了集合a中的所有元素。</p><h4 id="Collection接口的定义"><a href="#Collection接口的定义" class="headerlink" title="Collection接口的定义"></a>Collection接口的定义</h4><p>基本操作：</p><ul><li><code>boolean add(E e)</code>: 将指定的元素添加到集合中（如果集合允许添加）。</li><li><code>boolean remove(Object o)</code>: 从集合中移除指定的元素。</li><li><code>boolean contains(Object o)</code>: 检查集合是否包含指定的元素。</li><li><code>int size()</code>: 返回集合中的元素数量。</li><li><code>boolean isEmpty()</code>: 检查集合是否为空。</li><li><code>Iterator&lt;E&gt; iterator()</code>: 返回一个迭代器，用于遍历集合中的元素。</li></ul><p>以及批量操作：</p><ul><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>: 批量添加</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: 从集合中批量移除元素。</li><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>: 检查当前集合是否包含所有传入集合的元素</li><li><code>bollean retainAll(Collection&lt;?&gt; c)</code>: 删除当前集合中所有不在指定集合 <code>c</code> 中的元素</li><li><code>void clear()</code>: 移除集合中的所有元素。</li></ul><p>数组操作：</p><ul><li><code>Object[] toArray()</code>: 将集合转换为数组，数组类型为object</li><li><code>&lt;T&gt; T[] toArry(T[] a)</code>: 将集合中的元素转换为指定类型的数组，并将其存储在提供的数组中。如果提供的数组足够大，则元素将被存储在这个数组中；否则，将创建一个新的数组。</li></ul><h4 id="Collection接口的基本操作"><a href="#Collection接口的基本操作" class="headerlink" title="Collection接口的基本操作"></a>Collection接口的基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">dog</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>(<span class="hljs-string">&quot;andy&quot;</span>,<span class="hljs-number">5</span>);<br><span class="hljs-type">dog</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">2</span>);<br>Collection&lt;dog&gt; collection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>collection.add(d1);<br>collection.add(d2);<br><br><span class="hljs-keyword">for</span>(dog o : collection)&#123; <span class="hljs-comment">//for-each遍历</span><br>    System.out.println(o.getName());<br>&#125;<br><br>Iterator&lt;String&gt; iterator = collection.iterator(); <span class="hljs-comment">//迭代遍历</span><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br><br>collection.remove(d1); <span class="hljs-comment">//删除d1对象</span><br><br>collection.clear(); <span class="hljs-comment">//清空</span><br></code></pre></td></tr></table></figure><p>这里我创建了一个dog对象，并给它name和age。</p><p>要注意的是，iterator迭代方法同样有遍历的功能，但是Iterator.remove是修改集合唯一安全的方法。如果要移除当前元素。for-each结构隐藏迭代方法，因此不能调用remove方法。同样在多重集合上进行并行迭代也要用迭代器迭代。</p><p>下面演示如何过滤Collection集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>&#123;<br><span class="hljs-keyword">for</span>(Iterator&lt;?&gt; it = c.iterator();it.hasNext();)&#123;<br>        <span class="hljs-keyword">if</span>(?cond(it.next())) it.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Collection接口的批量操作"><a href="#Collection接口的批量操作" class="headerlink" title="Collection接口的批量操作"></a>Collection接口的批量操作</h4><p>下面展示表现批量操作强大功能的一个示例，从一个名为c的Collection中移除一个指定元素e的所有实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">c.removeAll(Collections.singleton(e))；<br></code></pre></td></tr></table></figure><p>或者也可以移除所有null元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">c.removeAll(Collections.singleton(<span class="hljs-literal">null</span>))；<br></code></pre></td></tr></table></figure><p>Collections.singleton是一个静态工厂方法，返回一个只包含指定元素的不可变Set集合(没有重复元素)。</p><p>在例子中Collections.singleton(e)方法只包含元素e的Set集合，然后就可以用removeAll删除。</p><h4 id="Collection数组操作"><a href="#Collection数组操作" class="headerlink" title="Collection数组操作"></a>Collection数组操作</h4><p>toArray()方法主要作为集合和老的期望输入数组的API之间的桥梁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建并初始化一个 List</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br><span class="hljs-comment">// 使用 toArray() 方法将集合转换为 Object 数组</span><br>Object[] array = list.toArray();<br><br><span class="hljs-comment">// 使用 toArray(T[] a) 方法将集合转换为指定类型的数组</span><br>String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set是一个不能包含重复元素的接口，是Collection接口的子接口，并且只包含从Collection继承过来的方法，并增加了对add()方法的使用限制，不允许有重复的元素。Set()还修改了equals()和hashCode()方法的实现，允许对Set实例进行内容上的比较，即使它们实现类型不同。如果两个Set实例包含相同的元素，那么它们就是相等的。</p><h4 id="Set定义"><a href="#Set定义" class="headerlink" title="Set定义"></a>Set定义</h4><p><strong>主要方法</strong>:</p><ul><li>继承了<code>Collection</code>接口的所有方法。</li><li>没有专门定义新的方法，但子接口和实现类提供了对集合不重复性要求的具体实现。</li></ul><p><strong>主要实现类</strong>:</p><ul><li><strong><code>HashSet</code></strong>: 基于哈希表的实现，不保证元素的顺序，通常提供快速的插入、删除和查找操作。</li><li><strong><code>TreeSet</code></strong>: 基于红黑树的实现，按自然顺序或构造时提供的比较器进行排序。</li><li><strong><code>LinkedHashSet</code></strong>: 结合了哈希表和链表的特点，保持插入顺序的同时提供较快的操作速度。</li></ul><p>Java平台包含3个通用目的的Set实现就是HashSet、TreeSet、LinkedHashSet这三个。</p><h4 id="Set接口的基本操作"><a href="#Set接口的基本操作" class="headerlink" title="Set接口的基本操作"></a>Set接口的基本操作</h4><p>那么Set和Collection有什么区别呢？下面看这个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用 Collection 接口</span><br>        Collection&lt;String&gt; collection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        collection.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Collection: &quot;</span> + collection);<br><br>        <span class="hljs-comment">// 使用 Set 接口</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">//这里用了哈希存放</span><br>        set.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Apple&quot;</span>); <span class="hljs-comment">// 重复元素不会被添加</span><br>        System.out.println(<span class="hljs-string">&quot;Set: &quot;</span> + set);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，这其中最大的区别就是Set不能重复添加元素。</p><h4 id="Set接口的批量操作"><a href="#Set接口的批量操作" class="headerlink" title="Set接口的批量操作"></a>Set接口的批量操作</h4><p>批量操作特别适合于Set接口：</p><ul><li>s1.containsAll(s2)：如果s2是s1的一个子集合，返回true</li><li>s1.addAll(s2)：将s1变换为s1和s2的并集</li><li>s1.retain(s2)：将s1变换为s1和s2的交集</li><li>s1.removeAll(s2)：将s1不对称地变换为s1和s2的差集</li></ul><p>addAll示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set1.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>set1.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>Set&lt;String&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set2.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;Date&quot;</span>);<br><br><span class="hljs-comment">// 将 set2 的所有元素添加到 set1 中</span><br>set1.addAll(set2);<br><br>System.out.println(<span class="hljs-string">&quot;Set1 after addAll: &quot;</span> + set1);<br><span class="hljs-comment">//Set1 after addAll: [Apple, Banana, Cherry, Date]</span><br></code></pre></td></tr></table></figure><p>removeAll示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set1.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>set1.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>set1.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br>Set&lt;String&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set2.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br><span class="hljs-comment">// 从 set1 中移除 set2 中的所有元素</span><br>set1.removeAll(set2);<br><br>System.out.println(<span class="hljs-string">&quot;Set1 after removeAll: &quot;</span> + set1);<br></code></pre></td></tr></table></figure><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List是一个有序的集合(又是被称为序列)。List可以包含重复的元素。除了从Collection继承过来的操作之外，List接口还包括以下操作：</p><ul><li>按位置访问：根据元素在序列中的位置索引访问元素</li><li>查找：在序列中查找指定对象，并返回其位置索引</li><li>迭代：扩展了Iteractor接口，以利用序列的顺序特性</li><li>List子集合：在序列上执行任意范围的操作</li></ul><h4 id="List接口的定义"><a href="#List接口的定义" class="headerlink" title="List接口的定义"></a>List接口的定义</h4><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span>;<br>    E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span>;<br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span>;<br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    List&lt;E&gt; <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java平台常见的List实现包括： <code>ArrayList</code>（基于动态数组）、<code>LinkedList</code>（基于双向链表）和 <code>Vector</code>（线程安全的动态数组）。</p><h4 id="List接口的操作"><a href="#List接口的操作" class="headerlink" title="List接口的操作"></a>List接口的操作</h4><h5 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. <strong>添加元素</strong></h5><ul><li><p><strong><code>void add(int index, E element)</code></strong></p><ul><li>在指定位置插入元素。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Orange&quot;</span>);  <span class="hljs-comment">// 在位置 1 插入 &quot;Orange&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></strong></p><ul><li>从指定位置开始，将指定集合中的所有元素添加到当前列表中。</li></ul><p><strong>示例</strong>:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Items</span> = Arrays.asList(<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Grapes&quot;</span>);<br>list.addAll(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Items</span>);  <span class="hljs-comment">// 从位置 1 开始添加 newItems 中的元素</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2. 访问元素"></a>2. <strong>访问元素</strong></h5><ul><li><p><strong><code>E get(int index)</code></strong></p><ul><li>获取指定位置的元素。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 获取位置 0 的元素</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>E set(int index, E element)</code></strong></p><ul><li>替换指定位置的元素。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Orange&quot;</span>);  <span class="hljs-comment">// 将位置 1 的元素替换为 &quot;Orange&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. <strong>删除元素</strong></h5><ul><li><p><code>E remove(int index)</code></p><ul><li>移除指定位置的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>list.remove(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 移除位置 1 的元素</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="4-查找元素"><a href="#4-查找元素" class="headerlink" title="4. 查找元素"></a>4. <strong>查找元素</strong></h5><ul><li><p><strong><code>int indexOf(Object o)</code></strong></p><ul><li>返回指定元素第一次出现的索引，如果不在列表中，则返回 -1。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> list.indexOf(<span class="hljs-string">&quot;Banana&quot;</span>);  <span class="hljs-comment">// 获取 &quot;Banana&quot; 的位置</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>int lastIndexOf(Object o)</code></strong></p><ul><li>返回指定元素最后一次出现的索引，如果不在列表中，则返回 -1。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> list.lastIndexOf(<span class="hljs-string">&quot;Banana&quot;</span>);  <span class="hljs-comment">// 获取 &quot;Banana&quot; 最后出现的位置</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="5-子列表"><a href="#5-子列表" class="headerlink" title="5. 子列表"></a>5. <strong>子列表</strong></h5><ul><li><p><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></p><ul><li>返回当前列表中从 <code>fromIndex</code>（包含）到 <code>toIndex</code>（不包含）的部分列表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Date&quot;</span>);<br><br>List&lt;String&gt; subList = list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 获取子列表 [Banana, Cherry]</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6. 迭代器"></a>6. <strong>迭代器</strong></h5><ul><li><p><code>ListIterator&lt;E&gt; listIterator()</code></p><ul><li>返回一个 <code>ListIterator</code>，从列表的开始处迭代。</li></ul></li><li><p><code>ListIterator&lt;E&gt; listIterator(int index)</code></p><ul><li>返回一个 <code>ListIterator</code>，从指定的位置开始迭代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br>ListIterator&lt;String&gt; iterator = list.listIterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br><br>ListIterator&lt;String&gt; iteratorFromIndex = list.listIterator(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (iteratorFromIndex.hasNext()) &#123;<br>    System.out.println(iteratorFromIndex.next());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="Map接口的定义"><a href="#Map接口的定义" class="headerlink" title="Map接口的定义"></a>Map接口的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">//基本操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span>;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br>    V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span>;<br>    <span class="hljs-comment">//批量操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//集合视图</span><br>    Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br>    Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br>    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br><br>    <span class="hljs-comment">//嵌套接口</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt; &#123;<br>        K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br>        V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br>        V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java平台包括3中通用的Map实现：HashMap、TreeMap和LinkedHashMap。</p><h4 id="Map接口的基本操作"><a href="#Map接口的基本操作" class="headerlink" title="Map接口的基本操作"></a>Map接口的基本操作</h4><h5 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. <strong>基本操作</strong></h5><ul><li><p><strong><code>int size()</code></strong></p><ul><li>返回 <code>Map</code> 中键值对的数量。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();  <span class="hljs-comment">// 返回 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>boolean isEmpty()</code></strong></p><ul><li>检查 <code>Map</code> 是否为空（即是否没有键值对）。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> map.isEmpty();  <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-键和值的存在性检查"><a href="#2-键和值的存在性检查" class="headerlink" title="2. 键和值的存在性检查"></a>2. <strong>键和值的存在性检查</strong></h5><ul><li><p><strong><code>boolean containsKey(Object key)</code></strong></p><ul><li>检查 <code>Map</code> 是否包含指定的键。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">hasKey</span> <span class="hljs-operator">=</span> map.containsKey(<span class="hljs-string">&quot;One&quot;</span>);  <span class="hljs-comment">// 返回 true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>boolean containsValue(Object value)</code></strong></p><ul><li>检查 <code>Map</code> 是否包含指定的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">hasValue</span> <span class="hljs-operator">=</span> map.containsValue(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 返回 true</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="3-获取和设置键值对"><a href="#3-获取和设置键值对" class="headerlink" title="3. 获取和设置键值对"></a>3. <strong>获取和设置键值对</strong></h5><ul><li><p><strong><code>V get(Object key)</code></strong></p><ul><li>根据键获取对应的值。如果键不存在，则返回 <code>null</code>。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;One&quot;</span>);  <span class="hljs-comment">// 返回 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>V put(K key, V value)</code></strong></p><ul><li>将指定的键值对添加到 <code>Map</code> 中。如果键已经存在，则更新对应的值，并返回之前的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;Three&quot;</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 将 &quot;Three&quot; 键与 3 值添加到 map 中</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>V remove(Object key)</code></strong></p><ul><li>根据键移除对应的键值对，并返回被移除的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">removedValue</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">&quot;Two&quot;</span>);  <span class="hljs-comment">// 移除 &quot;Two&quot; 键对应的值 2</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="4-批量操作"><a href="#4-批量操作" class="headerlink" title="4. 批量操作"></a>4. <strong>批量操作</strong></h5><ul><li><p><strong><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></strong></p><ul><li>将指定 <code>Map</code> 中的所有键值对添加到当前 <code>Map</code> 中。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; anotherMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>anotherMap.put(<span class="hljs-string">&quot;Four&quot;</span>, <span class="hljs-number">4</span>);<br>anotherMap.put(<span class="hljs-string">&quot;Five&quot;</span>, <span class="hljs-number">5</span>);<br><br>map.putAll(anotherMap);  <span class="hljs-comment">// 将 anotherMap 的所有键值对添加到 map 中</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>void clear()</code></strong></p><ul><li>移除 <code>Map</code> 中的所有键值对，使 <code>Map</code> 变为空。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.clear();  <span class="hljs-comment">// 清空 map</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="5-视图操作"><a href="#5-视图操作" class="headerlink" title="5. 视图操作"></a>5. <strong>视图操作</strong></h5><ul><li><p><strong><code>Set&lt;K&gt; keySet()</code></strong></p><ul><li>返回 <code>Map</code> 中所有键的集合。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; keys = map.keySet();  <span class="hljs-comment">// 获取 map 的所有键</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Collection&lt;V&gt; values()</code></strong></p><ul><li>返回 <code>Map</code> 中所有值的集合。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;Integer&gt; values = map.values();  <span class="hljs-comment">// 获取 map 的所有值</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></strong></p><ul><li>返回 <code>Map</code> 中所有键值对的集合，每个键值对作为 <code>Map.Entry</code> 对象存在。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="6-嵌套接口-Entry"><a href="#6-嵌套接口-Entry" class="headerlink" title="6. 嵌套接口 Entry"></a>6. <strong>嵌套接口 <code>Entry</code></strong></h5><ul><li><code>K getKey()</code><ul><li>返回 <code>Map.Entry</code> 对象中的键。</li></ul></li><li><code>V getValue()</code><ul><li>返回 <code>Map.Entry</code> 对象中的值。</li></ul></li><li><code>V setValue(V value)</code><ul><li>设置 <code>Map.Entry</code> 对象中的值，并返回之前的值。</li></ul></li><li><code>boolean equals(Object o)</code><ul><li>判断两个 <code>Map.Entry</code> 对象是否相等。</li></ul></li><li><code>int hashCode()</code><ul><li>返回 <code>Map.Entry</code> 对象的哈希码。</li></ul></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>比如我们可以做一个数组中单词的显示次数小程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(String a : args)&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> m.get(a);<br>    m.put( a, (freq == <span class="hljs-literal">null</span>) ? <span class="hljs-number">1</span> : freq+<span class="hljs-number">1</span> ); <span class="hljs-comment">//（键，值）</span><br>&#125;<br>System.out.println(m.size() + <span class="hljs-string">&quot;个不同的单词&quot;</span>);<br>System.out.println(m);<br></code></pre></td></tr></table></figure><p>args:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">java <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">be</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">if</span> <br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">5个不同的单词<br>&#123;<span class="hljs-attribute">java</span>=1, <span class="hljs-attribute">be</span>=1, <span class="hljs-attribute">is</span>=2, <span class="hljs-attribute">to</span>=1, <span class="hljs-attribute">if</span>=2&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoCAD学习笔记</title>
    <link href="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="AutoCAD学习笔记"><a href="#AutoCAD学习笔记" class="headerlink" title="AutoCAD学习笔记"></a>AutoCAD学习笔记</h2><p>这段时间在金工行业实习了一段时间，了解到一般机械制图是用到cad来绘画草图，然后再将画出的.dwg文件导入到ug(或者solidworks)中将其拉伸成3d图形。下面我将记录下这段时间使用cad的较多的快捷键以及指令操作。</p><h3 id="界面设置"><a href="#界面设置" class="headerlink" title="界面设置"></a>界面设置</h3><p>介于方便我们操作，免得每次都要点开找，我们可以将一些常用的操作直接放在边框layout处。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240826105405781.png" alt="可以像这样设置CAD界面"></p><p>那么怎么设置呢？我们可以右键上方layout处(灰色处)，然后将光标放到AutoCAD上：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d95b2a44155895695886f076c91876b.jpg" alt="如图会出现很多选项，对着上图勾选即可"></p><p>然后将出现的小框拖到上述界面的位置即可，这样方便我们使用。</p><h3 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h3><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><table><thead><tr><th>快捷键</th><th>操作</th><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>l (L)</td><td>直线</td><td>s</td><td>拉伸</td></tr><tr><td>e</td><td>清除</td><td>tr</td><td>修剪</td></tr><tr><td>co</td><td>复制</td><td>ex</td><td>延伸</td></tr><tr><td>m</td><td>移动</td><td>cha</td><td>倒直角</td></tr><tr><td>o</td><td>偏移</td><td>f</td><td>倒圆角</td></tr><tr><td>c</td><td>圆</td><td>dli</td><td>直线标注</td></tr></tbody></table><p>上面这些快捷键只需要对着界面输入然后按下空格(或者回车)后就可以触发。</p><p>还有一点，就是我们要是按下空格就可以<code>重复上一个操作</code>，比如我c完一个圆后还想画一个圆，那就再按下空格，就可以直接再画一个圆。</p><h5 id="c圆"><a href="#c圆" class="headerlink" title="c圆"></a>c圆</h5><p>我们对着界面输入c然后空格后，光标处就会变成十字形，然后只需在图中点一下就可以圆出来：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827095700961.png" alt="圆形示例"></p><p>注意我们可以看到下面命令框告诉我们可以输入圆的半径，比如我们想让圆的半径为10mm，那我们就可以输入10然后空格，或者想要直径为10mm，那就要输入d+空格，然后再输入10。</p><p>我们可以用旁边的标记列操作看下是否是10mm：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827100931131.png" alt="标注检查"></p><p>注意这里只是用于检查，实际标注不能用和轮廓线一样颜色的线。</p><h5 id="l直线"><a href="#l直线" class="headerlink" title="l直线"></a>l直线</h5><p>这里注意我们画下直线的时候会出现两个标注：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827104750508.png" alt="直线示例"></p><p>长度和角度可以用tab键来切换输入(如果没有这两个框是没有点开正交模式左边那个加号按钮)。</p><p>如果我们希望更方便操作角度我们可以开启下面的两个模式：</p><ul><li>正交模式 (f8)：点开后直线就是只能为直角(正交)状态。</li><li>极角模式 (f10)：可以设置角度，点开到相应角会有直线吸附。</li></ul><h5 id="e清除"><a href="#e清除" class="headerlink" title="e清除"></a>e清除</h5><p>这个很好理解，我们只需要选中需要被删除的线段，按下e+空格即可。</p><h5 id="co复制"><a href="#co复制" class="headerlink" title="co复制"></a>co复制</h5><p>我们co完后指令框显示：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827102741699.png" alt="注意指令框"></p><p>也就是告诉我们需要选中对象。比如我像copy一个圆，那我选择这个圆后，再按下空格，然后出现：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827102858555.png" alt="copy一下"></p><p>告诉我们寻找基准线，我以点圆的中心为例。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827103508094.png" alt="找到中心线后移动"></p><p>可以看到一个新圆已经被复制出来。</p><h5 id="m移动"><a href="#m移动" class="headerlink" title="m移动"></a>m移动</h5><p>移动跟复制同理，需要选中对象，然后确定基准点来移动。</p><h5 id="o偏移"><a href="#o偏移" class="headerlink" title="o偏移"></a>o偏移</h5><p>o+空格后出现下图</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827110346139.png" alt="指令框要求输入偏移距离"></p><p>当我们输入距离(比如8mm)，然后再空格，选中对象就可以了</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827110523011.png" alt="选中对象后就可以上下取偏移对象"></p><h5 id="ro旋转"><a href="#ro旋转" class="headerlink" title="ro旋转"></a>ro旋转</h5><p>和上一个一样，都是选中对象，然后选中基准点，再输入旋转角度。</p><h5 id="tr修剪"><a href="#tr修剪" class="headerlink" title="tr修剪"></a>tr修剪</h5><p>这个特殊点，比如我们要删除这段：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827111416454.png" alt="修剪删除"></p><p>我们就可以tr+两个空格(注意是两个空格)。然后就可以对这段点一下就可以删除了。</p><h5 id="ex延伸"><a href="#ex延伸" class="headerlink" title="ex延伸"></a>ex延伸</h5><p>这个需要选中两个对象，要求这两个对象是要有交点的，然后就可以延长一个对象直至相交。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827112258116.png" alt="光标放到上面的那个对象上就会延长至相交"></p><h5 id="f倒圆角、cha倒直角"><a href="#f倒圆角、cha倒直角" class="headerlink" title="f倒圆角、cha倒直角"></a>f倒圆角、cha倒直角</h5><p>倒角只需要我们输入f + r(倒角半径)，然后再指定两个对象即可。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827214628990.png" alt="两条边选中"></p><h5 id="dli正交直线标注"><a href="#dli正交直线标注" class="headerlink" title="dli正交直线标注"></a>dli正交直线标注</h5><p>也就是直线注释，这里注意是正交线，如果是斜线的话要输入dal。</p><h3 id="螺纹孔标注"><a href="#螺纹孔标注" class="headerlink" title="螺纹孔标注"></a>螺纹孔标注</h3><p>这里附上一张实习用到的表：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9479b108140e2595cbfb66b28cb0356.jpg" alt="螺纹标注表"></p><p>我们可以看到不同螺纹孔大小都是有标准的螺纹距离和深度的。比如我们想话一个M6的螺纹孔，我们要这样画：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827224311227.png" alt="注意图中内容"></p><p>由于螺纹只有长度的，因此我们在画实际钻孔时要减去螺纹的长度。注意图中标注的细节，这些可以在图层里设置，方便我们选用：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827225254858.png" alt="图层设置"></p><h3 id="阴影标注"><a href="#阴影标注" class="headerlink" title="阴影标注"></a>阴影标注</h3><p>找到左边列的打圈处，选中。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827225418023.png" alt="通过上图步骤选取"></p><p>点击“添加：拾取点”就可以选择需要阴影的位置了，选择成功再空格选择比例、样例，点击确定即可。</p><h3 id="一圆与两圆相切"><a href="#一圆与两圆相切" class="headerlink" title="一圆与两圆相切"></a>一圆与两圆相切</h3><p>同样我们c+空格打开圆的快捷键，然后选择图中操作。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231016906.png" alt="输入t，空格"></p><p>然后选择圆中需要相切的两个位置，再输入圆的半径即可。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231150002.png" alt="相切后的样子"></p><h3 id="块创建"><a href="#块创建" class="headerlink" title="块创建"></a>块创建</h3><p>块说白了就是自己写一个模板然后方便下次直接用。</p><p>比如我随便画一个矩形想作为块：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231640651.png" alt="点击创建"></p><p>我们可以点开绘画然后找到块创建</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231731280.png" alt="输入名称"></p><p>然后就可以输入名称保存了，需要时就i + 空格换出块就行了。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231826164.png" alt="按i唤出"></p><p>实际运用中比如这个粗糙度的标注符号在cad里是没有的，那就可以自己画一个然后创建块，方便后续使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>制图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/08/21/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/08/21/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><code>KMP:一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。——某位哲学大师(雾)</code></p><p>上面这句话很直观的体现了kmp算法的一个重要的特点：前后缀比较。比如我们看下面这道例题：</p><h4 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a>找出字符串中第一个匹配项的下标</h4><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;abxabcabcaby&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;abcaby&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-string">&quot;abcaby&quot;</span> 在下标 <span class="hljs-number">6</span> 处匹配。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;leeto&quot;</span><br>输出：-<span class="hljs-number">1</span><br>解释：<span class="hljs-string">&quot;leeto&quot;</span> 没有在 <span class="hljs-string">&quot;leetcode&quot;</span> 中出现，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h4 id="普通暴力解法"><a href="#普通暴力解法" class="headerlink" title="普通暴力解法"></a>普通暴力解法</h4><p>最直观的解法就是双循环，把haystack里面的字符都遍历一遍，然后再看这个字符后面是不是和needle匹配的，要是有不匹配的，直接break。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果 needle 是空字符串，则返回 0</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack.length() &lt; needle.length()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果 haystack 比 needle 短，则不能包含 needle</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; needle.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果字符不匹配，退出内层循环</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == needle.length()) &#123;<br>                <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 如果完整匹配，返回起始位置</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果没有找到 needle，返回 -1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里套了双层循环，假设m&#x3D;haystack.length() - needle.length() ,n&#x3D;needle.length()那么时间复杂度是O(mn)。但是如果我们使用kmp算法，就可以让时间复杂度控制到O(m+n)。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们想想当在字符串比较的时候，什么操作是多余的操作？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">text:</span> abxabcabcaby<br><span class="hljs-symbol">pattern:</span> abcaby<br></code></pre></td></tr></table></figure><p>以上述例子比较的时候可以发现：在text的[3:7]部分是和pattern[0:4]部分是重合的，由于最后一个y和text中的下一个c没对上，所以没有配对成功，但是在pattern这部分前面的[0:4]中前缀”ab”和后缀的”ab”是一样的，说明我们只需要重新比较text中[6:7]这个”ab”后面的与pattern[0:1]这个”ab”后面的即可，不用再重新比较”ab”。这样就可以优化算法。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/image-20240818132338112.png" alt="text中划线后缀和pattern中划线后缀是一样的"></p><h4 id="next表"><a href="#next表" class="headerlink" title="next表"></a>next表</h4><p>为了方便我们这样索引，我们将要建立一个next表，里面记录的是由后缀到前缀的索引值，也就是说当我们匹对字符串的时候，如果发现不对，那只需要通过索引值跳到需要比较的部分。</p><h5 id="建立思路"><a href="#建立思路" class="headerlink" title="建立思路"></a>建立思路</h5><p>首先我们给pattern字符串前面加上一个哨兵空字符，为什么要加这个呢？这里是由于之后我们比较的时候如果指针指的字符不匹配，那么我们就要找到指针前面那个字符的所对应的索引值，如果我们加上一个哨兵，那就可以每次不用指针减一，直接j就可以(有点拗口，之后看图会清楚点)。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/5ea9a4c4974af0f3bfd2860137c9b31.jpg" alt="初始状态，j+1指的字符不等于i，next[i]给0"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/c1b9f0ef796f237139fda9b1dc4177e.jpg" alt="由于两边不相等，i往前一位，j不往前"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/867ec80f42b7d7ee0a22629571dea4d.jpg" alt="现在i指向的字符和j+1指向的字符一样了"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/ef8c3230441c40e1d04d46f0d4cf555.jpg" alt="将next表中i指向的位置改成此时j的索引"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/0114a52dce83bfe8c3cc426a488be4a.jpg" alt="此时也是同上图一样两边的字符相等，改变next的值为j的索引值"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/4815ae5faf90986adbefa40013cf8b0.jpg" alt="给next赋值"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b5a2da634d9a40d193aff64c44fba2d.jpg" alt="j和i都向下移一位"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b5a2da634d9a40d193aff64c44fba2d.jpg" alt="发现j+1和i指向的字符不相等了"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/f873a65d6d109c53abd7bd20c67fc85.jpg" alt="然后j再通过其索引向前找有没有字符和i所指的是一样的"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/d3a97e6f3b75d2237737ff12a6930c6.jpg" alt="没有找到，于是就给next赋值0"></p><p>以上就是next表创建的手画过程，用代码来写就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>, j=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//p就是pattern的缩写，通过toCharArray()来变成字符数组</span><br>    <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; p[j+<span class="hljs-number">1</span>] != p[i]) j = next[j]; <span class="hljs-comment">//如果对不上，就让j不断往前找，直到找到能对上的数</span><br>    <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>] == p[i]) j++; <span class="hljs-comment">//如果对上了，就让j向后移动一位</span><br>    next[i] = j; <span class="hljs-comment">//next赋值操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到i就是从2开始的，所以我在途中所以为1的地方就没有写值。</p><h4 id="与字符串开始匹配"><a href="#与字符串开始匹配" class="headerlink" title="与字符串开始匹配"></a>与字符串开始匹配</h4><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b0db22bdf54f12abba917367f855d3f.jpg" alt="第一个字符进行比较(true)"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b1f333d3ecb0f0810828f7c7fa57b32.jpg" alt="与第二个字符比较(true)"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/8092a397846b7d90c5e5b677e0ed5b6.jpg" alt="&quot;c&quot;与&quot;x&quot;比较不上，j往后移动"></p><p>这里发现无法匹配后就直接通过b的前一个字符(a)的索引来向前找有没有为”x”的字符(然而没有)，于是j就停在哨兵字符上。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/af9bfccf12aadc677e04a209f112daf.jpg" alt="&quot;a&quot;与&quot;x&quot;不符"></p><p>发现不符，j不动(因为j已经是最上面了，找不上去了)，text中的字符再往后面找。然后重复上面的步骤不停往后比对。最后发现”y”和⑥的”c”不符，于是乎j就往下找(此时j下面的索引为2，因此j跳到”b”上，j+1为”c”)，此时我们就只需要比较”c”和text后面的值了(因为我们知到了”ab”肯定是一样的，不用再比较了)。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/2d208ae8221ec635341772e53d489e1.jpg" alt="&quot;c&quot;与后面的值作比较"></p><p>这一步就是kmp算法的核心，有了上面这个思路我们就可以解决上面的例题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String ss, String pp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pp.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ss.length(), m = pp.length(); <span class="hljs-comment">//注意长度的取值是在加入哨兵之前的</span><br>        ss = <span class="hljs-string">&quot; &quot;</span> + ss; <span class="hljs-comment">//加入哨兵</span><br>        pp = <span class="hljs-string">&quot; &quot;</span> + pp;<br>        <span class="hljs-type">char</span>[] s = ss.toCharArray(); <br>        <span class="hljs-type">char</span>[] p = pp.toCharArray();<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>]; <span class="hljs-comment">//创建next表</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>, j=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//填写next表</span><br>            <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; p[j+<span class="hljs-number">1</span>] != p[i]) j = next[j]; <span class="hljs-comment">//找不到的情况，让&quot;j&quot;往前找</span><br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>] == p[i]) j++; <span class="hljs-comment">//核对成功&quot;j&quot;往前走</span><br>            next[i] = j; <span class="hljs-comment">//将目前这个下标的值改成此时&quot;j&quot;的值</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//核对字符</span><br>            <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = next[j]; <span class="hljs-comment">//找不到的情况，让&quot;j&quot;往前找</span><br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>] == s[i]) j++; <span class="hljs-comment">//核对成功往前走</span><br>            <span class="hljs-keyword">if</span>(j == m)&#123; <span class="hljs-comment">//长度相等就return</span><br>                <span class="hljs-keyword">return</span> i - m; <span class="hljs-comment">//输出第一个元素下标</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static静态标签</title>
    <link href="/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/"/>
    <url>/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h3><p>我们都知道在测试文件中都需要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br></code></pre></td></tr></table></figure><p>这段文字，而文字中public void main这几个我都已经数值，但是这个static是什么意思呢？今天我们来一起探讨一下这个词语。</p><h4 id="属性静态调用"><a href="#属性静态调用" class="headerlink" title="属性静态调用"></a>属性静态调用</h4><p>当我们遇到不同的成员需要有相同的属性的时候，为了方便同时输入和调用属性，我们引入了static(静态)修饰符：</p><p>user:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">user</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String tea;  <span class="hljs-comment">//static修饰tea这个变量</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">user</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>test:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-number">123</span>);<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;ye&quot;</span>,<span class="hljs-number">11</span>);<br>        user.tea = <span class="hljs-string">&quot;black tea&quot;</span>;  <span class="hljs-comment">//直接对类进行调取</span><br>        System.out.println(u2.tea);  <span class="hljs-comment">//black tea</span><br>        System.out.println(u1.tea);  <span class="hljs-comment">//black tea</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到当我们给tea用static修饰了之后，在test文件中我们就可以直接用类来进行赋值而不需要用成员来赋值，并且赋值后每个成员所访问的值都是一样的。被static所修饰的成员变量叫做静态变量，它有这三个特点：</p><ul><li>被该类所有对象共享</li><li>不属于对象，属于类</li><li>随着类的加载而加载，优先于对象的存在</li></ul><p>当然被static修饰的成员方法，叫做静态方法，它有这些特点：</p><ul><li>多用在测试类和工具类中</li><li>Javabean类中很少会用到</li></ul><p>这里我们就可以讨论到工具类的创建。</p><h4 id="工具类创建"><a href="#工具类创建" class="headerlink" title="工具类创建"></a>工具类创建</h4><p>创建一个工具类，首先我们要将其私有化，这样外部就不会创建这个类的对象了(因为我们这个要让这个类作为工具，那我们就要写死在这里了，不能再让别人有所操作，不然工具变化会带来不便)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrUtil</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">arrUtil</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写一个工具类的例子：</p><p>ArrUtil: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;  <span class="hljs-comment">//集合list</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ArrUtil</span><span class="hljs-params">()</span>&#123;&#125;; <span class="hljs-comment">//工具类私有化</span><br>    <br><span class="hljs-comment">//设置为静态方便调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123; <span class="hljs-comment">//计算数组所有数据和</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            sum = sum + arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_num_sum</span><span class="hljs-params">(ArrayList&lt;user&gt; list)</span>&#123;  <span class="hljs-comment">//计算集合中所有对象的num属性和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            sum = sum + list.get(i).getNumber();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>test:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        System.out.println(ArrUtil.get_sum(a)); <span class="hljs-comment">//输出数组的数字和</span><br><br>        ArrayList&lt;user&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//这是个集合</span><br>        <span class="hljs-type">user</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;ye&quot;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;yee&quot;</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;yeee&quot;</span>,<span class="hljs-number">12</span>);<br><br>        list.add(u1); <span class="hljs-comment">//对象压入集合</span><br>        list.add(u2);<br>        list.add(u3);<br><br>        System.out.println(ArrUtil.get_num_sum(list)); <span class="hljs-comment">//输出集合中num的和</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到可以直接通过 类名.方法名() 来调用工具。</p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>其实，static有这几个注意事项：</p><ul><li>静态方法中，只能访问静态</li><li>非静态方法可以访问所有</li><li>静态方法中没有this关键字</li></ul><p>而这几个关键都和this关键字有关。以下我来举一些例子。</p><p>test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">methods_class</span> <span class="hljs-variable">pj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">methods_class</span>();<br>        pj.repeat();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>methods_class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">methods_class</span> &#123;<br><br>    String s;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repeat</span><span class="hljs-params">(methods_class <span class="hljs-built_in">this</span>)</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//输出com.bayeeaa.demo1.d9_static.methods_class@b4c966a</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">again</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//飘红，静态方法中没有this</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我在methods_class文件中输出了两个方法，一个是非静态方法，一个是静态方法，当我们分别用test文件来打印的时候会发现第一个repeat方法打印出了对象的地址，而第二个again方法会报错。</p><p><img src="/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/image-20240814091753742.png" alt="Build Output"></p><p>在我们平时使用非静态方法应该是不会在非静态方法中手动调入methods_class this这个值的，但是我们却可以直接用方法调用，这是因为在非静态方法中是默认包括this的，而this的赋值又由jvm调取。所以说在非静态方法中如果我们要调用参数，比如num，实际上应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repeat</span><span class="hljs-params">(methods_class <span class="hljs-built_in">this</span>)</span>&#123;<br>    System.out.println(<span class="hljs-built_in">this</span>.s);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是通过上图的报错我们可以看到静态方法中是没有this的。因此在其中要是强行引入this会导致报错。</p><p>有了这样的解释就可以理解上面的三个结论了。</p><h4 id="内存解释"><a href="#内存解释" class="headerlink" title="内存解释"></a>内存解释</h4><p>在作内存解释之前我们要知道：</p><h5 id="栈内存（Stack-Memory）"><a href="#栈内存（Stack-Memory）" class="headerlink" title="栈内存（Stack Memory）"></a>栈内存（Stack Memory）</h5><ol><li><strong>结构和管理方式</strong>：<ul><li>栈内存按照先进后出的原则进行管理（LIFO，即 Last In, First Out）。</li><li>内存分配和回收由系统自动管理。每当一个函数被调用时，系统会在栈上为其分配内存，函数返回时，这部分内存会被自动释放。</li></ul></li><li><strong>用途</strong>：<ul><li>用于存储局部变量、函数调用参数和返回地址等。</li><li>栈内存的管理非常高效，因为内存分配和释放的操作非常简单，只需调整栈顶指针即可。</li></ul></li><li><strong>特点</strong>：<ul><li>内存分配速度快。</li><li>栈内存的大小通常较小，固定大小，超过限制会导致栈溢出（stack overflow）。</li><li>数据的生命周期由函数调用的生命周期决定，一旦函数返回，栈内存中的数据就会失效。</li></ul></li></ol><h4 id="堆内存（Heap-Memory）"><a href="#堆内存（Heap-Memory）" class="headerlink" title="堆内存（Heap Memory）"></a>堆内存（Heap Memory）</h4><ol><li><strong>结构和管理方式</strong>：<ul><li>堆内存没有固定的管理顺序，分配和释放内存是由程序员或垃圾回收机制管理的。</li><li>内存的分配和释放可以发生在程序的任何地方，不像栈内存那样有固定的顺序。</li></ul></li><li><strong>用途</strong>：<ul><li>用于动态分配内存，比如创建对象、数组等，需要程序员显式地请求内存空间。</li><li>适用于需要在多个函数调用间共享数据的情况。</li></ul></li><li><strong>特点</strong>：<ul><li>内存分配和释放相对较慢，因为涉及到更复杂的管理机制。</li><li>堆内存的大小通常较大，由操作系统和系统配置决定。</li><li>需要程序员显式管理内存，未正确释放的内存会导致内存泄漏（memory leak），一些语言如 Java 和 Python 使用垃圾回收机制来自动处理这一问题。</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>栈内存</strong>适用于存储生命周期短、大小固定的数据，管理简单且高效。</li><li><strong>堆内存</strong>适用于存储生命周期长或大小不确定的数据，管理复杂但灵活。</li></ul><p>我们可以简单的将内存划为三个区域：</p><p><img src="/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/image-20240814100802874.png" alt="内存解释"></p><p>字节文件加载：引入main文件，加载里面的方法、类文件中的属性、静态属性等等。</p><p>然后开始创建对象，在堆内存中开辟一块地，并返回其地址给对象pj。</p><p>然后pj就可以根据地址去寻找所要找的元素。</p><h4 id="main的解释"><a href="#main的解释" class="headerlink" title="main的解释"></a>main的解释</h4><p>现在我们再来看下我们每次的入口文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br></code></pre></td></tr></table></figure><ul><li>public： 被JVM调用，访问权限足够大</li><li>static：被JVM调用，不用创建对象，直接类名访问。因为main方法是静态的，所以测试类中其他方法也需要是静态的。(这里注意下,不是静态的叫实例变量,非static方法需要new一个实例出来才能使用,这里意思是main默认只能调用静态方法,实例要new)</li><li>void：被JVM调用，不需要给JVM返回值</li><li>main：一个通用的名称，虽然不是关键字，但是被JVM识别</li><li>String[] args：以前用于接收键盘录入数据的，现在没有，被保留是为了上下版本兼容</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象编程封装</title>
    <link href="/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/"/>
    <url>/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程封装"><a href="#面向对象编程封装" class="headerlink" title="面向对象编程封装"></a>面向对象编程封装</h2><p>我们先从最简单的一个对象设置开始，设置一个phone对象，并赋予里面brand和number，为了进行比对，我让number私有化，而让brand变成public。</p><p>主入口文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newphone</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">phone</span>(); <span class="hljs-comment">//通过：类名 对象名 = new 类名()来自定义对象</span><br>        p.brand = <span class="hljs-string">&quot;小米&quot;</span>; <span class="hljs-comment">//这里为了形成对比没有让brand私有化</span><br>        p.setNumber(<span class="hljs-number">20</span>);<br>        System.out.println(p.getNumber());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number; <span class="hljs-comment">//private使这个number私有化，让其更改操作只能在本类中实现</span><br>    String brand;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//这里方便输出内容</span><br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123; <span class="hljs-comment">//通过方法使对象值在本函数中实现改变，函数名最好用set+双驼峰写法</span><br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">18</span> &amp;&amp; n&lt;<span class="hljs-number">50</span>)&#123;<br>            number = n;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;输入不被允许&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机在打电话&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到当number被私有化后，其值的修改就只能在类文件中发送，这样可以提高文件的安全性，我们只要通过调用getNumber和setNumber函数就可以实现值的传递并修改。</p><h3 id="两种不同的构造方式"><a href="#两种不同的构造方式" class="headerlink" title="两种不同的构造方式"></a>两种不同的构造方式</h3><h4 id="空参构造："><a href="#空参构造：" class="headerlink" title="空参构造："></a>空参构造：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">phone</span><span class="hljs-params">()</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>不带任何的参数。</p><h4 id="有参构造："><a href="#有参构造：" class="headerlink" title="有参构造："></a>有参构造：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">phone</span><span class="hljs-params">(String brand,<span class="hljs-type">int</span> number)</span>&#123;<br><span class="hljs-built_in">this</span>.brand = brand;   <span class="hljs-comment">//this.brand指的是类中的brand，是成员变量。右边的brand是方法里的局部变量(this遵循就近原则)</span><br><span class="hljs-built_in">this</span>.number = number;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的方法不带void或int等，没有return，是由于它的执行是由jvm调动的，所以主函数调用时候就会执行，无需手动执行。</p><p>主函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">phone</span>(<span class="hljs-string">&quot;小米&quot;</span>,<span class="hljs-number">20</span>);  <span class="hljs-comment">//有参函数直接可以传入数据</span><br></code></pre></td></tr></table></figure><p>这样就可以直接传入参数。</p><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br><span class="hljs-comment">// alt + INSERT就可以帮我们快速生成constructer和set,get函数</span><br>    <span class="hljs-comment">// ptg插件也可以帮我们快速构造JAVABEAN</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="alt-INSERT"><a href="#alt-INSERT" class="headerlink" title="alt + INSERT"></a>alt + INSERT</h4><p><img src="/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/image-20240804144657153.png" alt="键盘快捷键"></p><h4 id="ptg"><a href="#ptg" class="headerlink" title="ptg"></a>ptg</h4><p>这个方法需要在setting中下载ptg插件。</p><p><img src="/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/image-20240804144733984.png" alt="ptg"></p><p>通过快捷键我们可以快速的进行javabean构造。</p><h3 id="文字游戏的简单应用"><a href="#文字游戏的简单应用" class="headerlink" title="文字游戏的简单应用"></a>文字游戏的简单应用</h3><p>我们可以设置一个文字游戏，通过血量，攻击力等为对象创建属性，然后循环攻击最后输出结果。</p><p>类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d3; <span class="hljs-comment">//这里是package，不是import,这是类文件和主入口文件的区别</span><br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> blood;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    String[] attack_desc = &#123;<br>        <span class="hljs-string">&quot;虚弱地&quot;</span>, <span class="hljs-comment">//1~5</span><br>        <span class="hljs-string">&quot;小心地&quot;</span>, <span class="hljs-comment">//6~10</span><br>        <span class="hljs-string">&quot;用力地&quot;</span>, <span class="hljs-comment">//10~20</span><br>    &#125;;<br><br>    String[] injureds_desc = &#123;<br>        <span class="hljs-string">&quot;他似乎自信满满&quot;</span>, <span class="hljs-comment">//HP 100~80</span><br>        <span class="hljs-string">&quot;他认为还有胜算&quot;</span>, <span class="hljs-comment">//HP 79~50</span><br>        <span class="hljs-string">&quot;他还不肯认输&quot;</span>, <span class="hljs-comment">//HP 49~20</span><br>        <span class="hljs-string">&quot;他疲惫不堪&quot;</span> <span class="hljs-comment">//HP 20~0</span><br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Role</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Role</span><span class="hljs-params">(<span class="hljs-type">int</span> blood, String name)</span> &#123; <span class="hljs-comment">//有参构造</span><br>        <span class="hljs-built_in">this</span>.blood = blood; <span class="hljs-comment">//this所表示的就是这个对象的值</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBlood</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//得到血量</span><br>        <span class="hljs-keyword">return</span> blood;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlood</span><span class="hljs-params">(<span class="hljs-type">int</span> blood)</span> &#123; <span class="hljs-comment">//设置血量</span><br>        <span class="hljs-built_in">this</span>.blood = blood;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_attack_desc</span><span class="hljs-params">(<span class="hljs-type">int</span> hurt)</span> &#123; <span class="hljs-comment">//要注意这里函数最后无论如何都是要return 0的</span><br>        <span class="hljs-keyword">if</span>(hurt&lt;=<span class="hljs-number">5</span> &amp;&amp; hurt&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hurt&lt;=<span class="hljs-number">10</span> &amp;&amp; hurt&gt;<span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hurt&lt;=<span class="hljs-number">20</span> &amp;&amp; hurt&gt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_injureds_desc</span><span class="hljs-params">(<span class="hljs-type">int</span> remain)</span> &#123;<br>        <span class="hljs-keyword">if</span>(remain&lt;=<span class="hljs-number">100</span> &amp;&amp; remain&gt;=<span class="hljs-number">80</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(remain&lt;<span class="hljs-number">80</span> &amp;&amp; remain&gt;=<span class="hljs-number">50</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(remain&lt;<span class="hljs-number">50</span> &amp;&amp; remain&gt;=<span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(remain&lt;<span class="hljs-number">20</span> &amp;&amp; remain&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(Role role)</span>&#123; <span class="hljs-comment">//Role赋予role这个变量意义，也就是变成了对象</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hurt</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">20</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainblood</span> <span class="hljs-operator">=</span> role.getBlood() - hurt;<br>        remainblood = remainblood &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : remainblood; <span class="hljs-comment">//三元判断，&quot;?&quot;左边为结果，true就是左边的，false为右边</span><br>        role.setBlood(remainblood);<br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + attack_desc[get_attack_desc(hurt)] + <span class="hljs-string">&quot;打了&quot;</span> + role.getName() + <span class="hljs-string">&quot;&quot;</span> + hurt + <span class="hljs-string">&quot;点血，&quot;</span> + role.getName() +<span class="hljs-string">&quot;还剩&quot;</span> + role.getBlood() + <span class="hljs-string">&quot;，&quot;</span> + injureds_desc[get_injureds_desc(remainblood)]);<br>        <span class="hljs-comment">//this为调用对象，这里的role就是调入参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Role</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;500c&quot;</span>);<br>        <span class="hljs-type">Role</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;joker&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            r1.attack(r2);<br>            <span class="hljs-keyword">if</span>(r2.getBlood() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(r1.getName() + <span class="hljs-string">&quot; Win&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            r2.attack(r1);<br>            <span class="hljs-keyword">if</span>(r1.getBlood() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(r2.getName() + <span class="hljs-string">&quot; Win&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中一次运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">500c</span>用力地打了joker11点血，joker还剩<span class="hljs-number">89</span>，他似乎自信满满<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c16点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">84</span>，他似乎自信满满<br><span class="hljs-attribute">500c</span>虚弱地打了joker4点血，joker还剩<span class="hljs-number">85</span>，他似乎自信满满<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c17点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">67</span>，他认为还有胜算<br><span class="hljs-attribute">500c</span>虚弱地打了joker4点血，joker还剩<span class="hljs-number">81</span>，他似乎自信满满<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c16点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">51</span>，他认为还有胜算<br><span class="hljs-attribute">500c</span>小心地打了joker7点血，joker还剩<span class="hljs-number">74</span>，他认为还有胜算<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c19点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">32</span>，他还不肯认输<br><span class="hljs-attribute">500c</span>用力地打了joker17点血，joker还剩<span class="hljs-number">57</span>，他认为还有胜算<br><span class="hljs-attribute">joker</span>虚弱地打了<span class="hljs-number">500</span>c4点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">28</span>，他还不肯认输<br><span class="hljs-attribute">500c</span>小心地打了joker10点血，joker还剩<span class="hljs-number">47</span>，他还不肯认输<br><span class="hljs-attribute">joker</span>虚弱地打了<span class="hljs-number">500</span>c1点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">27</span>，他还不肯认输<br><span class="hljs-attribute">500c</span>用力地打了joker19点血，joker还剩<span class="hljs-number">28</span>，他还不肯认输<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c16点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">11</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span>小心地打了joker7点血，joker还剩<span class="hljs-number">21</span>，他还不肯认输<br><span class="hljs-attribute">joker</span>虚弱地打了<span class="hljs-number">500</span>c2点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">9</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span>虚弱地打了joker5点血，joker还剩<span class="hljs-number">16</span>，他疲惫不堪<br><span class="hljs-attribute">joker</span>小心地打了<span class="hljs-number">500</span>c8点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">1</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span>用力地打了joker17点血，joker还剩<span class="hljs-number">0</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span> Win<br><br><span class="hljs-attribute">Process</span> finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到我在类文件中先是设置了name和blood两个参数，而其攻击值是随机生成的。我也在类函数中加入了attack_desc和injureds_desc两个字符串数组来形容当前两人的状态。具体解释看代码中的注释。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的生命周期</title>
    <link href="/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p>通俗的讲就是：一个vue实例从创建到销毁的整个过程</p><p>①创建(响应式数据) ②挂载(渲染模板) ③更新(修改数据更新视图) ④销毁(关闭页面,销毁实例)</p><h3 id="Vue生命周期函数"><a href="#Vue生命周期函数" class="headerlink" title="Vue生命周期函数"></a>Vue生命周期函数</h3><ol><li><strong>创建阶段（Creation）</strong>：<ul><li>beforeCreate：实例刚被创建，数据观测和事件机制初始化之前被调用。</li><li>created：实例已经创建完成，完成数据观测、属性和方法的运算，初始化事件等。</li></ul></li><li><strong>挂载阶段（Mounting）</strong>：<ul><li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>mounted：实例已经挂载到 DOM 上后被调用。</li></ul></li><li><strong>更新阶段（Updating）</strong>：<ul><li>beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li><li>updated：数据更新后调用，发生在虚拟 DOM 重新渲染和打补丁之后。</li></ul></li><li><strong>销毁阶段（Destroying）</strong>：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：实例销毁后调用。在这一步，所有事件监听器被移除，所有子实例被销毁。</li></ul></li><li><strong>错误处理阶段（Error Handling）</strong>：<ul><li>errorCaptured：当子组件抛出错误时会触发该钩子。</li></ul></li></ol><p>为了深入的理解这段话，我们要知道什么是<code>实例</code></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在 Vue.js 中，”实例”（Instance）是指通过 Vue 构造函数创建的一个 Vue 实例对象。每个 Vue 应用都是通过创建一个 Vue 实例来实现的。当您使用 Vue 构造函数创建一个实例时，您可以传入一个选项对象，用于配置该实例的行为。</p><p>在 Vue 实例中，您可以定义数据、计算属性、方法、生命周期钩子函数等。这些属性和方法定义了该实例的行为和功能。Vue 实例还可以与 DOM 元素进行绑定，从而实现数据的双向绑定、事件处理等功能。</p><p>下面是一个简单的示例，演示了如何创建一个 Vue 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 Vue 实例</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-comment">// 选项对象</span><br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>, <span class="hljs-comment">// 指定要挂载的元素</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Vue 实例已创建&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个 Vue 实例 <code>vm</code>，并传入了一个选项对象，其中包含了 <code>el</code>、<code>data</code>、<code>methods</code> 和 <code>created</code> 等属性。这个实例可以通过 <code>vm</code> 来访问，并且可以调用定义的方法、访问数据等。</p><h3 id="Vue3-Composition-API"><a href="#Vue3-Composition-API" class="headerlink" title="Vue3 Composition API"></a>Vue3 Composition API</h3><p>进入到vue3后，组合式API大为推广，在这其中的生命钩子函数有了更灵活的运用，有了这样的变化：</p><ol><li><code>onBeforeMount</code>: 在组件挂载之前执行的函数，类似于 Vue 2.x 中的 <code>beforeMount</code> 钩子函数。</li><li><code>onMounted</code>: 在组件挂载到 DOM 后执行的函数，类似于 Vue 2.x 中的 <code>mounted</code> 钩子函数。</li><li><code>onBeforeUpdate</code>: 在组件更新之前执行的函数，类似于 Vue 2.x 中的 <code>beforeUpdate</code> 钩子函数。</li><li><code>onUpdated</code>: 在组件更新完成后执行的函数，类似于 Vue 2.x 中的 <code>updated</code> 钩子函数。</li><li><code>onBeforeUnmount</code>: 在组件卸载之前执行的函数，类似于 Vue 2.x 中的 <code>beforeUnmount</code> 钩子函数。</li><li><code>onUnmounted</code>: 在组件卸载后执行的函数，类似于 Vue 2.x 中的 <code>unmounted</code> 钩子函数。</li><li><code>onActivated</code>: 在组件被激活时执行的函数，用于配合 <code>&lt;keep-alive&gt;</code> 组件使用。</li><li><code>onDeactivated</code>: 在组件被停用时执行的函数，用于配合 <code>&lt;keep-alive&gt;</code> 组件使用。</li><li><code>onErrorCaptured</code>: 捕获子组件抛出的错误，类似于 Vue 2.x 中的 <code>errorCaptured</code> 钩子函数。</li></ol><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们分两组进行演示，分别是onBeforeMount和onMounted，onBeforeUpdate和onUpdated。其中用到比较多的就是Mounted这组。</p><p><img src="/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><h4 id="onMounted"><a href="#onMounted" class="headerlink" title="onMounted"></a>onMounted</h4><p>我们输入以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; onMounted, onBeforeMount &#125; from &#x27;vue&#x27;<br>const title = &#x27;hello&#x27;<br><br>onBeforeMount(() =&gt; &#123;<br>  console.log(&quot;onBeforeMount: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //undefined<br>&#125;)<br><br>onMounted(() =&gt; &#123;<br>  console.log(&quot;onMounted: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //hello<br>&#125;)<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>我们可以看到我们分别让两个生命周期函数打印出此时的值，可以看到注释里的结果，在onBeforeMount，也就是实例还挂载到DOM上，此时还没有开始渲染因此式undefined，在onMounted里，hello被打印了出来，说明此时已经完成了渲染，可以操作DOM了。因此我们平时都习惯将网页进入时就需要触发的函数放在onMounted里，防止函数无法准确获取到DOM元素。</p><h4 id="onUpdated"><a href="#onUpdated" class="headerlink" title="onUpdated"></a>onUpdated</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;&#123;&#123; count &#125;&#125;&lt;/h2&gt;&lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; onBeforeUpdate, onUpdated, ref &#125; from &#x27;vue&#x27;<br>let count = ref(1)<br><br>onBeforeUpdate(() =&gt; &#123;<br>  console.log(&quot;onBeforeUpdate&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML) //1<br>&#125;)<br><br>onUpdated(() =&gt; &#123;<br>  console.log(&quot;onUpdated&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML); //2<br>&#125;)<br><br>const add = () =&gt; &#123;<br>  count.value++  <br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>可以看到这里就是差异在内部数据更改和视图更新的区别，在onBeforeUpdate时数据并没有发生更新，而在onUpdated数据发生了更新并且可以显示出来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用时出现的问题小汇总</title>
    <link href="/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/"/>
    <url>/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="git提交"><a href="#git提交" class="headerlink" title="git提交"></a>git提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add * //将所有上传文件进入缓存区域<br>git commit -m <span class="hljs-string">&quot;submit&quot;</span> //提交申请注释，双引号里面就是注释内容<br>(*) git remote add origin https //关联远程仓库，关联后以后就可以不再重复关联<br>git push -u origin main //推入仓库main分支<br></code></pre></td></tr></table></figure><h4 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h4><p>在 <code>git commit</code> 命令中，<code>-m</code> 选项用于指定提交消息。Git 提交时需要一个消息来描述这次提交的目的或更改内容。使用 <code>-m</code> 选项可以让你在命令行中直接输入提交消息，而不是打开编辑器。使用 <code>-m</code> 选项可以快速地提供提交消息。</p><p>如果你不使用 <code>-m</code> 选项，Git 会打开你配置的默认文本编辑器（例如 Vim、Nano 等），让你在编辑器中输入提交消息。这适用于较长或复杂的提交消息，允许你在编辑器中进行详细描述和格式化。</p><h4 id="u"><a href="#u" class="headerlink" title="-u"></a>-u</h4><p>在git push -u origin main中我们可以看到有个-u，-u 是–set-upstream的缩写。它的作用是将本地分支与远程分支建立跟踪关系。它有一下这几点作用：</p><ul><li>将本地分支与远程分支关联起来，使得以后可以简化 <code>git push</code> 和 <code>git pull</code> 命令的使用。</li><li>设置当前分支的上游分支（即跟踪的远程分支），方便在以后的操作中，Git 可以自动推送和拉取数据。</li></ul><h3 id="error-failed-to-push-some-refs-to-‘http’"><a href="#error-failed-to-push-some-refs-to-‘http’" class="headerlink" title="error: failed to push some refs to ‘http’"></a>error: failed to push some refs to ‘http’</h3><p><img src="/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/image-20240702172843116.png" alt="rror: failed to push some refs to &#39;http&#39;"></p><p>这个报错是指本地的文件和仓库中有冲突的部分，所以要先拉取github上的，然后再推上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin<br>git push origin main   (或者master)<br></code></pre></td></tr></table></figure><h3 id="error-src-refspec-main-does-not-match-any"><a href="#error-src-refspec-main-does-not-match-any" class="headerlink" title="error: src refspec main does not match any"></a>error: src refspec main does not match any</h3><p>由于是新创建的仓库还没有main分支(或者是你还没切换到这个分支上面)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b main   <br></code></pre></td></tr></table></figure><p>切换到当前分支main。</p><h3 id="如何将msater的内容合并到main分支，并删除master？"><a href="#如何将msater的内容合并到main分支，并删除master？" class="headerlink" title="如何将msater的内容合并到main分支，并删除master？"></a>如何将msater的内容合并到main分支，并删除master？</h3><p>要将 <code>master</code> 分支的内容合并到 <code>main</code> 分支，并删除 <code>master</code> 分支，你可以按照以下步骤进行操作。这些步骤假设你已经在本地仓库中，并且你希望在本地和远程仓库中同步这些更改。</p><ol><li><p><strong>切换到 <code>main</code> 分支</strong>： 确保你在 <code>main</code> 分支上，使用以下命令切换到 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure></li><li><p><strong>更新 <code>main</code> 分支</strong>： 确保 <code>main</code> 分支是最新的。如果你正在使用远程仓库，先拉取远程更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure></li><li><p>**合并 <code>master</code> 分支到 <code>main</code>**： 使用以下命令将 <code>master</code> 分支的内容合并到 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge master<br></code></pre></td></tr></table></figure><p>如果有合并冲突，Git 会提示你解决冲突。解决所有冲突后，完成合并并提交更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;conflicted-files&gt;<br>git commit<br></code></pre></td></tr></table></figure></li><li><p><strong>推送合并后的 <code>main</code> 分支到远程仓库</strong>： 将合并后的 <code>main</code> 分支推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure></li><li><p><strong>删除 <code>master</code> 分支</strong>：</p><ul><li><p><strong>在本地删除 <code>master</code> 分支</strong>： 确保你已经切换到 <code>main</code> 分支后，可以删除本地的 <code>master</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d master<br></code></pre></td></tr></table></figure><p>如果 <code>master</code> 分支没有完全合并到 <code>main</code>，而你确定要删除，可以使用 <code>-D</code> 强制删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D master<br></code></pre></td></tr></table></figure></li><li><p><strong>在远程删除 <code>master</code> 分支</strong>： 使用以下命令将 <code>master</code> 分支从远程仓库删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --delete master<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal: refusing to merge unrelated histories"></a>fatal: refusing to merge unrelated histories</h3><h4 id="表示-Git-拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下："><a href="#表示-Git-拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下：" class="headerlink" title="表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下："></a>表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下：</h4><ol><li><strong>两个分支或仓库的历史完全不同</strong>：<ul><li>比如，你尝试合并两个完全不同的项目，或者一个是新创建的仓库，另一个是老的仓库。</li></ul></li><li><strong>从远程仓库克隆时历史不同</strong>：<ul><li>如果你从一个远程仓库克隆了一个新的仓库，而本地仓库中已经有一些历史记录，Git 会认为这些历史不相关。</li></ul></li></ol><p>可以使用 <code>--allow-unrelated-histories</code> 选项来允许合并不相关的历史。以下是详细的步骤：</p><ol><li><p><strong>切换到 <code>main</code> 分支</strong>： 确保你在目标分支（通常是 <code>main</code> 分支）上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure></li><li><p><strong>执行合并命令并允许不相关的历史</strong>： 使用 <code>--allow-unrelated-histories</code> 选项来合并 <code>master</code> 分支到 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge master --allow-unrelated-histories<br></code></pre></td></tr></table></figure><p>这会允许 Git 合并两个没有共同历史的分支。</p></li><li><p><strong>解决合并冲突</strong>： 如果在合并过程中遇到冲突，Git 会提示你解决这些冲突。解决冲突后，完成合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;conflicted-files&gt;<br>git commit<br></code></pre></td></tr></table></figure></li><li><p><strong>推送合并后的 <code>main</code> 分支到远程仓库</strong>： 将合并后的 <code>main</code> 分支推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3+ts项目的基本路由配置</title>
    <link href="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="导入router"><a href="#导入router" class="headerlink" title="导入router"></a>导入router</h3><p>首先在main.ts文件中导入router，并将其use入app中让其挂载。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>;<br>app.<span class="hljs-title function_">use</span>(router)<br></code></pre></td></tr></table></figure><p>这样就可以在app中导入router了。</p><h3 id="路由文件index-ts配置"><a href="#路由文件index-ts配置" class="headerlink" title="路由文件index.ts配置"></a>路由文件index.ts配置</h3><p>为了更标准，我们在src文件中创立一个router文件夹，然后在文件夹中创建index.ts文件。</p><p>在index文件中，我们就可以将组件的路径记录到其中，这样就可以按照需要访问组件了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>           <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;shouye&#x27;</span><br>           <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/Home&#x27;</span> ,<br>           <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>        &#125;<br>    ]<br>&#125;)<br><br><span class="hljs-comment">//将router暴露出去(default 默认)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>我们先导入createRouter和createWebHistory(或createWebHashHistory)，然后再const一个router对象，里面存入history和routes。像这里我导入的是Home.vue组件，然后就可以在routes中写入path和component(path可以和组件的名字不一样，而且浏览器地址栏是不区分大小写的)。在router中history是必不可少的，其中有两种模式可以选择，我们这里选择createWebHistory。</p><p>最后不要忘记将router方法暴露出去。</p><p>这样我们就已经可以访问”&#x2F;home”组件了，但是我们的组件应该要配合layout来显示，具体放在页面的那个地方才合适呢？</p><h3 id="控制组件存放位置"><a href="#控制组件存放位置" class="headerlink" title="控制组件存放位置"></a>控制组件存放位置</h3><p>使用中存放组件的位置用RouterView标签，触发标签用RouterLink标签。</p><p>首先我们还是一样要在script中导入RouterView，RouterLink：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RouterView</span>, <span class="hljs-title class_">RouterLink</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br></code></pre></td></tr></table></figure><p>然后就可以在template中使用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div :style=&quot;&#123; padding: &#x27;24px&#x27;, background: &#x27;#fff&#x27;, minHeight: &#x27;600px&#x27; &#125;&quot;&gt;<br>  &lt;RouterView&gt;&lt;/RouterView&gt;          <br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>其中组件都会在RouterView的位置显示。而我们触发事件就要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/home&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>这里需要配合button等来配合使用。</p><p>当然考虑到地址的变化，也可以这样写RouterLink：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink :to=&quot;&#123;path:/home&#125;&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink :to=&quot;&#123;name:shouye&#125;&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><h3 id="子路由配置"><a href="#子路由配置" class="headerlink" title="子路由配置"></a>子路由配置</h3><p>我们上面配置都是一级路由，而二级子路由要怎么配置呢？</p><p>首先我们找到index.ts文件，再里面添加children在path中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>           <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;shouye&#x27;</span>,<br>           <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/Home&#x27;</span> ,<br>           <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br>           <span class="hljs-attr">children</span>:[<br>            &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail&#x27;</span>, <span class="hljs-comment">//不要加斜杠</span><br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br>        &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后我们只需在RouterLink里面修改to的路径就可以了，也就是我们可以localhost&#x2F;home&#x2F;detail来访问子组件了。</p><h3 id="路由传参方法"><a href="#路由传参方法" class="headerlink" title="路由传参方法"></a>路由传参方法</h3><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>使用query传参我们需要在RouterLink的to中加入需要传入的值，比如我们想传给子组件“qq”一词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/detail?a=qq&amp;b=kk&quot;&gt;&lt;/RouterLink&gt;  <br></code></pre></td></tr></table></figure><p>可以看到我给子组件通过“路径?变量&#x3D;值”将值传递，然后在子组件中我们需要再导入router接收传递的信息，就可以使用了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">let</span> route = <span class="hljs-title function_">useRoute</span>()<br></code></pre></td></tr></table></figure><p>html:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; route.query.a &#125;&#125;<br></code></pre></td></tr></table></figure><p>这样就可以在页面中呈现了。</p><p>顺便我们log route一下就可以看到页面传递的值：</p><p><img src="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/image-20240719200614527.png" alt="query参数"></p><p>而如果我们需要通过for来改变传递的值，可以按照示例中这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink :to=&quot;`/detail?a=$&#123;shops.id&#125;`&quot;&gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink <br>  :to=&quot;&#123;<br>path:&#x27;/detail&#x27;                   <br>    query:&#123;<br>         a:shops.id,<br>        &#125;<br>    &#125;&quot;<br>  &gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>与query传参不同的是，params传参在index.ts中的path需要提前占位，在to中就可以对path中占的位对号入座。</p><p>比如我在path中用x占位：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:x?&#x27;</span>, <span class="hljs-comment">//这里的冒号表示占位，问号表示这个地方可能有展位也可能没有（问号不加也可以）</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br></code></pre></td></tr></table></figure><p>然后在template中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/detail/aa&quot;&gt;<br>&lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>&lt;/RouterLink&gt;  <br></code></pre></td></tr></table></figure><p>再在子组件中console.log(route)一下就可以发现：</p><p><img src="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/image-20240719214457064.png" alt="params参数"></p><p>最后用params接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; route.params.a &#125;&#125;<br></code></pre></td></tr></table></figure><p>然后同样可以用变量传递的方式传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink <br>  :to=&quot;&#123;<br>name:&#x27;xiangqing&#x27;                  <br>    query:&#123;<br>         a:shops.id,<br>        &#125;<br>    &#125;&quot;<br>  &gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><p>但注意这里不能用path，只能用name来判断路径。</p><h3 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h3><h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h4><p>在路由配置中加上props:true，再在组件中加入defineProps([… , … ,])就可以将路由收到的params参数作为props传给组件。</p><p>子路由：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:id/:title/:content&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><span class="hljs-attr">props</span>:<span class="hljs-literal">true</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;title&#x27;</span>,<span class="hljs-string">&#x27;content&#x27;</span>])<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; id &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h4><p>也可以传递query参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:id/:title/:content&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br><span class="hljs-keyword">return</span> route.<span class="hljs-property">query</span><br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>query不用占位，params需要占位。</p><p>本节使用RouterLink标签进行跳转，其中to属性解释来添加跳转的位置，可以用对象的方法书写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite构建的项目“@”地址无法解析问题</title>
    <link href="/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用vite构建项目后，发现无法识别”@”地址：</p><p><img src="/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/image-20240719223909893.png" alt="报错提示"></p><p>经过排查是由于config文件中没有配置”@”对应的路径：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>打开vite.config.ts文件，改成：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)) <span class="hljs-comment">//这里的配置就是可以让@可以读取成&#x27;./src&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>中间的reslove的alias所包含的就是”@”的配置项，这样我们就可以用@来代替.&#x2F;src。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP地址</title>
    <link href="/2024/07/10/IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/07/10/IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="内网ip和公网ip"><a href="#内网ip和公网ip" class="headerlink" title="内网ip和公网ip"></a>内网ip和公网ip</h4><p>内网IP（Internal Network IP）是指在局域网或者内部网络中使用的IP地址。在IPv4的网络中，内网IP地址通常属于私有IP地址范围，例如：</p><ul><li>10.0.0.0 到 10.255.255.255</li><li>172.16.0.0 到 172.31.255.255</li><li>192.168.0.0 到 192.168.255.255</li></ul><p>这些地址是专门为局域网内部使用而保留的，不会被分配到互联网上，因此可以重复使用。内网IP地址的作用是在局域网内部进行设备之间的通信和连接，比如连接本地打印机、路由器、局域网内的计算机等。</p><p>与内网IP相对的是公网IP（Public IP），公网IP是可以被全球互联网访问到的IP地址，用于在不同的网络之间进行通信。</p><p>我们可以通过</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ipconfig<br></code></pre></td></tr></table></figure><p>来访问我们电脑现在的内网ip(也就是ipv4地址)</p><p><img src="/2024/07/10/IP%E5%9C%B0%E5%9D%80/image-20240710152532331.png" alt="IP"></p><p>公网IP（Public IP）是指可以直接在全球互联网上访问到的IP地址。它是由互联网服务提供商（ISP，也就是移动，联通这些公司）分配给网络设备（如路由器、服务器等）的唯一标识符，用于在互联网上进行通信和数据交换。</p><p>公网IP地址是全球唯一的，不同的设备在互联网上需要具有不同的公网IP地址，这样才能保证它们之间能够正确地进行通信和数据传输。公网IP地址通常是静态或动态分配的，静态公网IP地址在一段时间内不会改变，而动态公网IP地址可能会在连接重新建立时发生变化。</p><p>通常情况下，个人用户使用的是动态公网IP地址，而企业或特定应用可能会使用静态公网IP地址，以便更稳定地提供服务和进行网络管理，一般情况下我们个人都是先使用内网然后再通过了路由将数据与公网进行交换，如果想要个人直接接入公网，需要向ISP特别申请。</p><p>通俗的说，内网ip与公网ip就好比寄快递，内网ip是几栋几号室，而公网ip是哪个省哪个市，有了这些ip地址后，我们才能把信息精确分配到每一个计算机个体。</p><h4 id="ipv4和ipv6"><a href="#ipv4和ipv6" class="headerlink" title="ipv4和ipv6"></a>ipv4和ipv6</h4><p>IPv4（Internet Protocol version 4）是互联网协议第四版，是当前广泛使用的互联网协议之一。IPv4定义了互联网上数据的传输方式，它使用32位（4个字节）的地址长度来标识网络上的每个设备或节点。</p><p>IPv4地址通常以点分十进制表示，例如：192.168.1.1。每个IPv4地址由四个八位组成，每个八位组可以表示0到255之间的数值，总共有约42亿个不同的IPv4地址。然而，由于互联网的迅速发展和设备的增多，IPv4地址已经逐渐不足以支持所有连接到互联网的设备。</p><p>为了解决IPv4地址耗尽的问题，IPv6（Internet Protocol version 6）被设计出来，它使用128位（16个字节）的地址长度，大大增加了可用的地址空间，预计能够长期解决IP地址耗尽的问题。IPv6的推广和采用逐渐增加，但目前仍然有大部分互联网流量使用IPv4协议。</p><p>总结起来，IPv4是互联网上广泛使用的网络协议之一，使用32位地址长度来标识网络上的设备或节点，其地址格式为点分十进制。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>由上面我们知道随着互联网的发展，ipv4逐渐枯竭。为了应对这样的情况，NAT（网络地址转换）技术孕育而生。</p><h5 id="NAT-的主要类型包括："><a href="#NAT-的主要类型包括：" class="headerlink" title="NAT 的主要类型包括："></a>NAT 的主要类型包括：</h5><ul><li>静态 NAT：静态NAT是将一个固定的私有IP地址映射到一个固定的公共IP地址的一种形式，通常用于需要特定设备具有公共IP地址的情况，如服务器。</li><li>动态 NAT：动态NAT是动态地将内部设备的私有IP地址映射到公共IP地址池中的一个可用地址，通常在需要大量设备同时访问互联网时使用。</li><li>PAT（端口地址转换）：也称为Overload NAT，它允许多个设备使用相同的公共IP地址访问互联网，但通过不同的端口号进行区分。</li></ul><p>一般情况我们我们就是通过路由器来将私有的ip地址映射到固定的公共ip地址，所以路由器在这里就充当了网关的作用。但是通过路由器传输的终端就不止一个，另一端接收方路由器对应的终端也不止一个，我们传输就无法一一对应，所以我们就要用到<strong>端口映射</strong>，通过端口号来确定我们要传输数据的终端彼此。</p><p><img src="/2024/07/10/IP%E5%9C%B0%E5%9D%80/image-20240710160048602.png" alt="大致是这样传递"></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>在知道子网掩码之前，我们要知道什么是<strong>子网</strong>。</p><p><strong>子网</strong>（Subnet）是指将一个大的IP地址块（IP地址空间）划分成若干个较小的子集，每个子集称为一个子网。在网络中，子网的作用是将一个大的网络划分成多个较小的、更易管理的部分，以便于组织和管理网络设备。</p><p>每个子网由一组连续的IP地址组成，这些IP地址共享一个公共的网络前缀（网络标识符）。这个网络前缀通常由IP地址和子网掩码（Subnet Mask）共同决定，子网掩码定义了IP地址中哪些部分是网络部分，哪些部分是主机部分。</p><p>子网的使用可以帮助网络管理员更有效地管理IP地址，减少广播风暴（Broadcast Storm）和冲突，提高网络的安全性和性能。常见的子网划分方式包括按照部门、功能或地理位置来划分子网，以便于根据需要对每个子网进行管理和配置。</p><p>那么如何确定这个ip是否在这个子网中呢？这就需要有子网掩码。子网掩码通过”&amp;”操作辨别子网：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&amp; X = X<br><span class="hljs-symbol">0 </span>&amp; X = X<br></code></pre></td></tr></table></figure><p>比如我们可以将：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.10</span> &amp; <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span> = <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br>IP &amp; 子网掩码 =&gt; 结果相同 =&gt; 同一子网<br></code></pre></td></tr></table></figure><p>如果我们通过ip和子网掩码的与操作都得到相同的结果，说明他们都在同一个子网当中。</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口（Port）是一种逻辑概念，用于区分不同应用程序或服务在同一台计算机上的通信终点。每个端口都有一个数字标识，称为端口号，用于标识特定的网络服务或应用程序。</p><h5 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h5><ol><li><strong>端口号</strong>：端口号是一个16位的整数，范围从0到65535。其中，0到1023的端口号被称为“系统端口”或“well-known端口”，它们通常分配给常见的网络服务，如HTTP（端口号80）、HTTPS（端口号443）、FTP（端口号21）等。</li><li><strong>通信终点</strong>：在一台计算机上，每个运行的应用程序或服务都可以通过一个或多个端口号来进行通信。例如，Web服务器使用HTTP协议通过端口号80接收Web请求，而电子邮件服务器使用SMTP协议通过端口号25接收邮件。</li><li><strong>传输层概念</strong>：端口属于传输层（第四层）协议的概念，在TCP&#x2F;IP模型中，这一层负责提供可靠的数据传输服务。TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们通过端口号来确定数据包应该被交付给哪个应用程序或服务。</li><li><strong>端口分类</strong>：<ul><li><strong>系统端口</strong>：0到1023，预留给众所周知的服务。</li><li><strong>注册端口</strong>：1024到49151，分配给用户进程或应用程序。</li><li><strong>动态&#x2F;私有端口</strong>：49152到65535，用于临时的短暂会话。</li></ul></li></ol><h5 id="端口的重要性："><a href="#端口的重要性：" class="headerlink" title="端口的重要性："></a>端口的重要性：</h5><ul><li><strong>多路复用</strong>：端口允许一台计算机上的多个应用程序同时进行网络通信，通过端口号区分不同的应用数据流。</li><li><strong>网络安全</strong>：端口号有助于防火墙和安全设备识别和控制不同类型的网络流量，提高网络安全性。</li><li><strong>网络管理</strong>：端口号使网络管理员可以轻松地监控和管理网络上的各种服务和应用程序。</li></ul><h4 id="以太网和因特网"><a href="#以太网和因特网" class="headerlink" title="以太网和因特网"></a>以太网和因特网</h4><p>以太网（Ethernet）和因特网（Internet）是两个不同的概念，它们在计算机网络中有着不同的角色和范围。</p><h5 id="以太网（Ethernet）："><a href="#以太网（Ethernet）：" class="headerlink" title="以太网（Ethernet）："></a>以太网（Ethernet）：</h5><ol><li><strong>定义</strong>：以太网是一种局域网（LAN）技术，用于在较小的范围内连接多台计算机和网络设备，如在办公室、校园或家庭内部。</li><li><strong>传输介质</strong>：以太网通常使用双绞线、光纤或者无线电波作为传输介质，传输速度可以从几百Mbps到几十Gbps不等。</li><li><strong>协议</strong>：以太网使用一组标准的数据链路层和物理层协议（如IEEE 802.3标准），定义了数据包在局域网内的传输方式。</li><li><strong>拓扑结构</strong>：以太网的拓扑结构可以是星型、总线型或者环型，其中最常见的是星型拓扑，每台设备连接到一个中央集线器或交换机。</li></ol><h5 id="因特网（Internet）："><a href="#因特网（Internet）：" class="headerlink" title="因特网（Internet）："></a>因特网（Internet）：</h5><ol><li><strong>定义</strong>：因特网是全球范围内的公共计算机网络，由许多不同的网络（包括以太网、光纤网络、卫星网络等）连接起来，通过TCP&#x2F;IP协议族进行数据传输和通信。</li><li><strong>范围</strong>：因特网是全球性的网络，连接了世界上几乎所有的计算机和网络设备，允许它们之间进行跨地域和跨国界的通信。</li><li><strong>协议</strong>：因特网使用TCP&#x2F;IP协议族，包括TCP（Transmission Control Protocol）和IP（Internet Protocol），定义了数据在全球范围内的传输和路由方式。</li><li><strong>服务和应用</strong>：因特网支持各种应用和服务，如电子邮件、网页浏览、文件传输、实时通信等，是人们日常生活中广泛使用的平台。</li></ol><p>简单的说以太网就是局域网，而因特网就是互联网。</p><h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）是一组通信协议，它定义了互联网和许多私有网络中数据如何传输和交换的标准。TCP&#x2F;IP协议族是现代互联网通信的基础，它包括多个协议，每个协议负责不同的功能。</p><ol><li><strong>IP（Internet Protocol）</strong>：<ul><li>IP协议负责在网络中传送数据包，并确保它们能够从源地址到目标地址安全地传输。</li><li>它定义了数据包的结构和格式，以及如何在网络中路由和转发数据包。</li></ul></li><li><strong>TCP（Transmission Control Protocol）</strong>：<ul><li>TCP协议是一种面向连接的协议，负责在通信的两端建立可靠的数据传输连接。</li><li>它确保数据包按顺序到达目的地，并处理丢失数据包的重传，以及流量控制和拥塞控制。</li></ul></li><li><strong>UDP（User Datagram Protocol）</strong>：<ul><li>UDP协议是一种无连接的协议，它提供了一种简单的数据传输服务，适用于实时应用程序和广播通信。</li><li>与TCP不同，UDP不保证数据的顺序和可靠性，但是它提供了较低的延迟和更高的传输速度。</li></ul></li><li><strong>其他协议</strong>：<ul><li><strong>ICMP（Internet Control Message Protocol）</strong>：用于在IP网络上发送控制消息，如错误报告和网络诊断。</li><li><strong>ARP（Address Resolution Protocol）</strong>：用于将IP地址映射为MAC地址（硬件地址）。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端如何将pdf等文件传入后端</title>
    <link href="/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/"/>
    <url>/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="前端如何将pdf等文件传入后端"><a href="#前端如何将pdf等文件传入后端" class="headerlink" title="前端如何将pdf等文件传入后端"></a>前端如何将pdf等文件传入后端</h2><p>我们知道在js中我们可以通过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> id=<span class="hljs-string">&quot;fileInput&quot;</span> accept=<span class="hljs-string">&quot;image/*&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>来输入文件。其中type指后端url，accept来限制传入类型。</p><h3 id="前端通过表单形式将其传入后端"><a href="#前端通过表单形式将其传入后端" class="headerlink" title="前端通过表单形式将其传入后端"></a>前端通过表单形式将其传入后端</h3><p>那么前端是怎么将这一整个文件打包传入后端的呢？</p><p>原来前端通过文件上传表单的方式将文件传输到后端。这通常涉及使用 HTML 的 <code>&lt;form&gt;</code> 元素和 <code>&lt;input type=&quot;file&quot;&gt;</code> 输入框，以及设置适当的表单属性来支持文件上传。</p><p><img src="/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/image-20240704204517908.png" alt="Payload截图"></p><p>可以看到我在使用ant design vue框架时其文件传输的内容包含状态，上传时间，文件名字等。</p><h4 id="文件上传的流程："><a href="#文件上传的流程：" class="headerlink" title="文件上传的流程："></a>文件上传的流程：</h4><ol><li>用户在文件输入框中选择一个文件。</li><li>用户点击提交按钮，浏览器将会把表单数据（包括选定的文件）打包成 <code>multipart/form-data</code> 格式的请求体。</li><li>请求被发送到指定的后端URL（在这个例子中是 <code>/upload</code>）。</li><li>后端接收到请求后，可以通过相应的框架或库来解析 <code>multipart/form-data</code>，获取到文件数据，并进行进一步处理，例如保存文件到服务器或者进行文件内容分析等操作。</li></ol><h4 id="文件上传表单示例："><a href="#文件上传表单示例：" class="headerlink" title="文件上传表单示例："></a>文件上传表单示例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;form id=<span class="hljs-string">&quot;uploadForm&quot;</span> action=<span class="hljs-string">&quot;/upload&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>&lt;form&gt;</code> 元素定义了一个表单，其中：<ul><li><code>action=&quot;/upload&quot;</code> 指定了表单提交的目标后端URL。</li><li><code>method=&quot;POST&quot;</code> 指定了使用POST方法提交表单。</li><li><code>enctype=&quot;multipart/form-data&quot;</code> 表示表单中包含文件上传，这是必需的，因为文件上传需要使用 <code>multipart/form-data</code> 类型来传输文件数据。</li></ul></li><li><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt;</code> 是文件上传的输入框，其中：<ul><li><code>type=&quot;file&quot;</code> 表示这是一个文件输入框，允许用户选择文件。</li><li><code>name=&quot;file&quot;</code> 指定了后端接收文件时的字段名称，这个名称在后端处理文件时很重要。</li><li><code>id=&quot;fileInput&quot;</code> 可以用来通过 JavaScript 获取文件输入框的引用，以便在用户选择文件后执行一些操作（例如显示文件名或大小）。</li></ul></li><li><code>&lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt;</code> 是一个提交按钮，点击它会触发表单提交操作。</li></ul><h4 id="后端处理文件上传的例子："><a href="#后端处理文件上传的例子：" class="headerlink" title="后端处理文件上传的例子："></a>后端处理文件上传的例子：</h4><ul><li><p><strong>Node.js（使用 Express 框架）：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">javascript复制代码<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>);<br><span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>(&#123; <span class="hljs-attr">dest</span>: <span class="hljs-string">&#x27;uploads/&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&#x27;file&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> file = req.<span class="hljs-property">file</span>;<br>    <span class="hljs-comment">// 处理文件，例如保存到服务器或者返回其他响应</span><br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;文件上传成功&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器运行在 http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，使用了 <code>multer</code> 中间件来处理单个文件上传，<code>upload.single(&#39;file&#39;)</code> 表示期望接收一个名为 <code>file</code> 的文件字段。</p></li><li><p><strong>PHP：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php">php复制代码<span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$target_dir</span> = <span class="hljs-string">&quot;uploads/&quot;</span>;<br><span class="hljs-variable">$target_file</span> = <span class="hljs-variable">$target_dir</span> . <span class="hljs-title function_ invoke__">basename</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);<br><span class="hljs-variable">$uploadOk</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>], <span class="hljs-variable">$target_file</span>)) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件上传成功&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件上传失败&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>PHP 示例使用了 <code>$_FILES</code> 超全局数组来接收上传的文件，并使用 <code>move_uploaded_file()</code> 函数将文件从临时位置移动到指定的目标位置。</p></li></ul><h3 id="用JS将文件传入后端"><a href="#用JS将文件传入后端" class="headerlink" title="用JS将文件传入后端"></a>用JS将文件传入后端</h3><p>上面以及展示了html文件上传表单的示例，下面再展示通过JavaScript监听文件选择事件来传递。</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;File&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="JS绑定事件"><a href="#JS绑定事件" class="headerlink" title="JS绑定事件"></a>JS绑定事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br><span class="hljs-keyword">let</span> fileList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#File&#x27;</span>).<span class="hljs-property">files</span><br>&#125;)<br><span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>,fileList[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>如果接口文档要求传递请求体(包括Content-Disposition, Content-Type等)我们使用window提供的FormData构造函数来实例化一个表单类型。</p><h4 id="axios传递"><a href="#axios传递" class="headerlink" title="axios传递"></a>axios传递</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br><span class="hljs-attr">data</span>: fd<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过ajax就可以将文件传入后端。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向JS的TypeScript</title>
    <link href="/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/"/>
    <url>/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/</url>
    
    <content type="html"><![CDATA[<h3 id="面向JS的TypeScript"><a href="#面向JS的TypeScript" class="headerlink" title="面向JS的TypeScript"></a>面向JS的TypeScript</h3><p>说到TypeScript，就不得不从Javascript说起。我们知道JavaScript（也称为 ECMAScript）最初是一种用于浏览器的简单脚本语言。在它被发明时，它被期望用于嵌入网页中的简短代码片段 - 编写几十行以上的代码有点不寻常。因此，早期的网络浏览器执行此类代码的速度非常慢。不过，随着时间的推移，JS 变得越来越流行，Web 开发者开始使用它来创建交互式体验。</p><p>JavaScript是一种为快速使用而设计的语言，与众不同的是，每种语言都有自己的“怪癖“，而 JavaScript 的卑微起步使其拥有许多这样的”怪癖“。</p><ul><li><p>JavaScript 的相等运算符 (<code>==</code>) 强制转换其操作对象，导致意外行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// It is! But why??</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt; x &lt; <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-comment">// True for any value of x!</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>JavaScript 还允许访问不存在的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-comment">// Why is this NaN? Spelling is hard!</span><br><span class="hljs-keyword">const</span> area = obj.<span class="hljs-property">width</span> * obj.<span class="hljs-property">heigth</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="TypeScript：静态类型检查器"><a href="#TypeScript：静态类型检查器" class="headerlink" title="TypeScript：静态类型检查器"></a>TypeScript：静态类型检查器</h4><p>静态检查：在不运行代码的情况下检测代码中的错误。</p><p>TypeScript 能在执行前检查程序是否有错误，并根据值的种类进行检查，使其成为静态类型检查器。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">const</span> area = obj.<span class="hljs-property">width</span> * obj.<span class="hljs-property">heigth</span>;<br><br>* <span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;heigth&#x27;</span> does not exist on type <span class="hljs-string">&#x27;&#123; width: number; height: number; &#125;&#x27;</span>. <span class="hljs-title class_">Did</span> you mean <span class="hljs-string">&#x27;height&#x27;</span>?<span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;heigth&#x27;</span> does not exist on type <span class="hljs-string">&#x27;&#123; width: number; height: number; &#125;&#x27;</span>. <span class="hljs-title class_">Did</span> you mean <span class="hljs-string">&#x27;height&#x27;</span>?<br></code></pre></td></tr></table></figure><h5 id="TypeScript是JavaScript的超集"><a href="#TypeScript是JavaScript的超集" class="headerlink" title="TypeScript是JavaScript的超集"></a>TypeScript是JavaScript的超集</h5><p>因此JS的许多语法在TS中是合法的。由于其语法，TypeScript 不会将任何 JavaScript 代码视为错误。这意味着你可以将任何有效的 JavaScript 代码放入 TypeScript 文件中，而不必担心它的具体编写方式。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = (<span class="hljs-number">4</span><br>         *<span class="hljs-string">&#x27;)&#x27;</span>expected.<br></code></pre></td></tr></table></figure><p>在TS中不会将任何JS代码看成错误。因此你可以将任何有效的JS都放入TS文件中，而不必担心其具体用法。</p><h5 id="类型化的JS超集"><a href="#类型化的JS超集" class="headerlink" title="类型化的JS超集"></a>类型化的JS超集</h5><p>TS是一个类型超集，这意味着它添加了关于如何使用不同类型的值的规则。比如在一些JS中的错误不是语法错误而是“以不正确的方式使用某种值（类型）的错误”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span> / []);<br></code></pre></td></tr></table></figure><p>这个语法上合法的程序记录了 <code>Infinity</code>。但是，TypeScript 将数字除以数组视为无意义的操作，并且会触发错误：“The right-hand side of an arithmetic operation must be of type ‘any’, ‘number’, ‘bigint’ or an enum type.”(分母必须是‘any’,’number’,’bigint’,’enum type’)。</p><h5 id="运行时的行为"><a href="#运行时的行为" class="headerlink" title="运行时的行为"></a>运行时的行为</h5><p>TypeScript 也是一种保留了 JavaScript 运行时行为的编程语言。例如，在 JavaScript 中除以零会产生 <code>Infinity</code> 而不是抛出运行时异常。原则上，TypeScript 不会改变 JavaScript 代码的运行时行为。</p><h5 id="擦除类型"><a href="#擦除类型" class="headerlink" title="擦除类型"></a>擦除类型</h5><p>一旦TS的编译器检查完代码，它就会擦除类型以生成结果的“编译”代码。这意味着一旦代码被TS编译后。生成的普通JS就没有类型信息了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的建立、遍历规则、以及节点计算</title>
    <link href="/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的建立、遍历规则、以及节点计算"><a href="#二叉树的建立、遍历规则、以及节点计算" class="headerlink" title="二叉树的建立、遍历规则、以及节点计算"></a>二叉树的建立、遍历规则、以及节点计算</h3><p>二叉树故名思意就是只有两个度的树，这里讨论其最基本的用法及逻辑。</p><p><img src="/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><h4 id="树的创立"><a href="#树的创立" class="headerlink" title="树的创立"></a>树的创立</h4><p>定义一颗二叉树首先要有一个度里的数据data，以及左右孩子，我们可以用结构体定义以方便其理解。</p><h5 id="结构体定义："><a href="#结构体定义：" class="headerlink" title="结构体定义："></a>结构体定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElementType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span><br><span class="hljs-keyword">typedef</span> Position BinTree;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span><br>    ElementType Data;<br>    BinTree Left;<br>    BinTree Right;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们给左右孩子分别定位Left和Right，这样我们就可以使用T-&gt;Left和T-&gt;Right等方式进行调用，利于理解。</p><h5 id="树的构建："><a href="#树的构建：" class="headerlink" title="树的构建："></a>树的构建：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">binTree <span class="hljs-title function_">creatBintree</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a;<br>binTree b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == a)<span class="hljs-comment">//如果输入0，则停止创建</span><br>b = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>b = (binTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binNode));<br>b-&gt;element = a;<br>b-&gt;leftChild = creatBintree();<br>b-&gt;rightChild = creatBintree();<br><br>&#125;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>当我们构建起了一个树后我们怎么对树进行遍历读取呢？可以用前、中、后序遍历，打比方我们用前序遍历就是通过（根、左、右）对树进行读取，也就是首先将最上面的节点作为root，然后将所有左边和右边的节点看作孩子，然后再将此时左孩子最上面的节点作为root进一步（根、左、右）读取，以此类推进行遍历。我们可以用<em>递归</em>的方式来实现代码。</p><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data); <span class="hljs-comment">//输出结果</span><br>    &#125;<br>    PreorderPrintLeaves(BT-&gt;Left);<br>    PreorderPrintLeaves(BT-&gt;Right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    PreorderPrintLeaves(BT-&gt;Left);<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data);<br>    &#125;    <br>    PreorderPrintLeaves(BT-&gt;Right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    PreorderPrintLeaves(BT-&gt;Left);  <br>    PreorderPrintLeaves(BT-&gt;Right);<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="节点的计算"><a href="#节点的计算" class="headerlink" title="节点的计算"></a>节点的计算</h4><p>节点的计算需要通过左右子树的孩子判断来对其进行加法运算，我们可以用T-&gt;lchild!&#x3D;NULL来表示没有左孩子，同理可以右孩子也是T-&gt;rchild!&#x3D;NULL，这样就可以区分度为1、2或叶子节点。</p><h5 id="计算节点数"><a href="#计算节点数" class="headerlink" title="计算节点数"></a>计算节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>; <span class="hljs-comment">//全部一次性+1</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算度为1的节点数"><a href="#计算度为1的节点数" class="headerlink" title="计算度为1的节点数"></a>计算度为1的节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(( T-&gt;lchild!=<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="hljs-literal">NULL</span>) || ( T-&gt;lchild==<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild!=<span class="hljs-literal">NULL</span>))<br>        <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>; <span class="hljs-comment">//这里次数+1</span><br>    <span class="hljs-keyword">return</span> NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); <span class="hljs-comment">//直接return，次数不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算度为2的节点数"><a href="#计算度为2的节点数" class="headerlink" title="计算度为2的节点数"></a>计算度为2的节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>( T-&gt;lchild!=<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);<br>    <span class="hljs-keyword">return</span> NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算叶子节点个数"><a href="#计算叶子节点个数" class="headerlink" title="计算叶子节点个数"></a>计算叶子节点个数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LeafCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild==<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树高计算"><a href="#树高计算" class="headerlink" title="树高计算"></a>树高计算</h4><p>我们可以定义两个整型m，n分别来表示左右两边的树高度，用递归的方式实现向下计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetHeight</span><span class="hljs-params">( BinTree BT )</span>&#123;<br>     <span class="hljs-type">int</span> m, n;<br>     <span class="hljs-keyword">if</span> (BT == <span class="hljs-literal">NULL</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">else</span>&#123;<br>         m = GetHeight(BT-&gt;Left);<br>         n = GetHeight(BT-&gt;Right);<br>         <span class="hljs-keyword">if</span> (m &gt; n)<br>             <span class="hljs-keyword">return</span> (m + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>             <span class="hljs-keyword">return</span> (n + <span class="hljs-number">1</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法-用Dijkstra和Prim求最小路径</title>
    <link href="/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="图算法-用Dijkstra和Prim求最小路径"><a href="#图算法-用Dijkstra和Prim求最小路径" class="headerlink" title="图算法-用Dijkstra和Prim求最小路径"></a>图算法-用Dijkstra和Prim求最小路径</h3><h4 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h4><p>在一个树中有多个节点和多条有向或无向的边，若我们给各个边附上权值，那么利用这两个算法可以计算从一个节点到所有节点的最小距离。实际中可以解决比如快递在区域配送最短的路径等问题。</p><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>例如以第1个节点为树根并循环整个树的节点，找到与1连接的所有点然后比较到这个点的距离是否小于原点(节点1)到这个点的距离(此时还没有)，若此时的距离比另一条路到这个点的距离小，则存入数据，以此类推。</p><h5 id="具体如下："><a href="#具体如下：" class="headerlink" title="具体如下："></a>具体如下：</h5><p>我们用dist数组来存入原点到所有点的最小距离，最开始的时候设置所有的点到原点的距离为无穷大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//原点到原点的距离为0</span><br></code></pre></td></tr></table></figure><p>用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。</p><p>首先用for遍历每个点，寻找到每一个点的到原点的距离。</p><p>再在用一个for来确定这个点是到原点的最短距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t</span><br>        <span class="hljs-keyword">if</span>(!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))t = j;<br>    &#125;<br>    state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i]置为1。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])&#123;<span class="hljs-comment">//遍历t所有可以到达的节点i</span><br>        <span class="hljs-type">int</span> i = e[j];<br>        dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新dist[j]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<span class="hljs-comment">//dist数组的各个元素为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//源点到源点的距离为置为 0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t</span><br>            <span class="hljs-keyword">if</span>(!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))t = j;<br>        &#125;<br>        state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i]置为1。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])&#123;<span class="hljs-comment">//遍历t所有可以到达的节点i</span><br>            <span class="hljs-type">int</span> i = e[j];<br>            dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新dist[j]</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。prim算法相比于dijkstra是贪心的，它要寻找的是每一个点之间的最短距离。</p><h5 id="具体如下"><a href="#具体如下" class="headerlink" title="具体如下"></a>具体如下</h5><p>与Dijkstra一样用dist存入距离，并最开始用无穷大赋值。</p><p>用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。</p><p>用pre数组来保存节点是和谁连通的。</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dist[n],state[n],pre[n];<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i : <span class="hljs-number">1</span> ~ n)<br>&#123;<br>    t &lt;- 没有连通起来，但是距离连通部分最近的点;<br>    state[t] = <span class="hljs-number">1</span>;<br>    更新 dist 和 pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在prim里面相当于是将树的每个点一个一个加入到一个集合中，这个集合就是生成的树。每次选择树都要看看是否在树中并且到树的距离最短，如果是则加入到集合中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dt,<span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dt));<span class="hljs-comment">//初始化距离数组为一个很大的数（10亿左右）</span><br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    dt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//从 1 号节点开始生成 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//每次循环选出一个点加入到生成树</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//每个节点一次判断</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dt[j] &lt; dt[t]))<span class="hljs-comment">//如果没有在树中，且到树的距离最短，则选择该点</span><br>                t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dt[t] == <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 选择该点</span><br>        res += dt[t];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">//更新生成树外的点到生成树的距离</span><br>            <span class="hljs-keyword">if</span>(dt[i] &gt; g[t][i] &amp;&amp; !st[i])&#123;<span class="hljs-comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span><br>                dt[i] = g[t][i];<span class="hljs-comment">//更新距离</span><br>                pre[i] = t;<span class="hljs-comment">//从 t 到 i 的距离更短，i 的前驱变为 t.</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地已经后端部署，前端response返回“Method Post not allowed”问题</title>
    <link href="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这次是在做前端的时候，前后端联调发生的问题。接口名前后都对的上然而显示“Post方法不被允许”：</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/82c4ccc79f7bcddc7c82641131305f5.png" alt="response返回的值"></p><p>第一反应是去看自定义端口最后的url是不是少一个“&#x2F;”：</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234225465.png" alt="自定义接口处"></p><p>发现并没有少。</p><p>最后经过排查发现前后端地址没有对上。前端地址没有连接本地的地址。</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234403334.png" alt="后端地址设置处"></p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234428092.png" alt="前端地址设置处"></p><p>修改target的请求地址为”<a href="http://127.0.0.1:3381“，成功解决。">http://127.0.0.1:3381“，成功解决。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise链式调用与async函数解决回调地狱问题</title>
    <link href="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在平时我们使用vue的时候经常会看到在请求接口的时候总是会有async与await：</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502211951935.png" alt="JS请求接口示例"></p><p>这是为什么呢？不能直接请求接口吗？</p><p>这里其实是为了避免出现<em>回调地狱</em>的问题。要理解清楚这个问题不妨从promise的链式调用开始讲起。</p><h4 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h4><p>概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调地狱。</p><p>我们知道一个axios函数中包含一些url等请求参数和一个.then的回调函数，由于其异步性，一个接口的请求需要等到回调函数成功调回才算结束。于是要是我们在.then里面在嵌入一个axios函数的话就需要等到上一层请求后再进入这层，再由这层回调到上层。代码量一多，不仅可读性差而且异常无法捕获，耦合性严重，牵一发动全身。比如看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city!&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>    &#125;)        <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我在第二个url中最后加了一个“!”让其错误，并让<a href="https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5">catch</a>寻找错误的地方。然而我们发现：</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502220418999.png" alt="catch无法捕获"></p><p>其错误直接来源于axios的源码处，而且显示Uncaught (in promise)，这就是回调地狱最直接的一个弊端处。</p><p>好了这里又涉及到一个词叫promise。</p><h4 id="何为Promise？"><a href="#何为Promise？" class="headerlink" title="何为Promise？"></a>何为Promise？</h4><p>mdn的解释是：“Promise是一个对象，它代表了一个异步操作的最终完成或者失败。”所以说Promise就是一个函数返回的对象，不然每次做回调操作都要自己手动传一个回调函数进去。</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/71edb8bc-87b4-4098-9e67-950ad55bb773.jpg" alt="promise工作原理"></p><p>解释：依靠then()方法回返回一个新生成的Promise对象特性，继续串联下一环任务，直到结束。而then()回调函数中的返回值会影响新生成的Promise对象最终状态和结果。这样通过链式调用，可以有效解决回调函数嵌套问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//设置时间模拟ajax请求</span><br>        <span class="hljs-title function_">reslove</span>(<span class="hljs-string">&#x27;北京市&#x27;</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//北京</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 === p); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>可以看到我们创建了一个新的promise对象并赋值给p，然后再用p触发回调函数，并生成了一个全新的promise对象并赋值给p2。</p><p>在最后一行的log中，使用了三等判断进行比较，我们知道三等判断，判断的是两个变量保存的内存地址，最后其返回了false更可以说明生成的是一个全新的promise对象。</p><p>所以知道了promise的工作原理，我们就可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city!&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>    &#125;)        <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>没错，就是在第二个axios前面多了一个return，就可以捕获到第二层的错误了。</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502225923733.png" alt="成功捕获error"></p><h4 id="async函数和await"><a href="#async函数和await" class="headerlink" title="async函数和await"></a>async函数和await</h4><p>我们现在知道了promise可以解决回调地狱，但是这还是在回调函数里面不断嵌套，可读性极差，这时async函数(意思为“异步”)的引入就极大的改善了这个问题。</p><p><em>定义：async函数是使用async关机字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键词。async和await关键词让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。</em></p><p>因此我们只需要这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> pObj = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;)<br>    <span class="hljs-keyword">const</span> pname = pObj.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-keyword">const</span> cObj = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;)<br>    <span class="hljs-keyword">const</span> cname = cObj.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>&#125;<br><span class="hljs-title function_">getData</span>() <span class="hljs-comment">//别忘了调用函数</span><br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pname = []<br><span class="hljs-keyword">let</span> cname = []<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    &#125;)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>    &#125;)        <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>&#125;<br><span class="hljs-title function_">getData</span>()<br></code></pre></td></tr></table></figure><p>注意上面第二个代码中pname和cname没有用const定义，是因为当我在外面用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pname = []<br><span class="hljs-keyword">const</span> cname = []<br></code></pre></td></tr></table></figure><p>定义时发现报出错误：Assignment to constant variable（把常量赋值给了变量）</p><p>这是因为我们使用 const 定义了变量且存在初始值。 后面又给这个变量赋值，所以报错了。ES6 标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域：使用 const 定义的常量，不能修改它的值，且定义的常量必须赋初值；let 定义的是变量，可以进行变量赋值操作，且不需要赋初值。这个错误就是因为我们修改了常量而引起的错误，虽然某些浏览器不报错，但是无效果！所以解决方法就是前面加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pname = []<br><span class="hljs-keyword">let</span> cname = []<br></code></pre></td></tr></table></figure><p>成功解决问题。</p><p>– 这里debug的时候发现const和let这块还有点含糊，const似乎最好是赋值一个对象或数组，再对对象进行赋值。等我哪天彻底搞明白了后单独出一期讲讲_(:3 ⌒ﾞ)__</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-ES6箭头函数使用细则</title>
    <link href="/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>我们知道在ES6之前使用函数要使用function：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">形参</span>) &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>然而在function中this指向的对象不够清晰明确，以及其表达不够简洁，于是引入的箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(形参) =&gt; &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>由于其重要性，以及在vue中的大量使用，我将着重讨论下<em>箭头函数的使用方法</em>，<em>函数参数</em>和<em>this指向问题</em>。</p><h3 id="使用方法以及简写条件"><a href="#使用方法以及简写条件" class="headerlink" title="使用方法以及简写条件"></a>使用方法以及简写条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//function写法</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//箭头写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当传入只有一个形参时，小括号可以省略:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+x)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>当函数体只有一行时可以省略大括号:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+x)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//4</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x,y</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+y)<br><span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//3</span><br><br><span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>)<br>form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.<span class="hljs-title function_">preventDefault</span>()) <span class="hljs-comment">//形参小括号和函数体大括号都省略</span><br><span class="hljs-comment">//阻止表单默认提交时事件</span><br></code></pre></td></tr></table></figure><p>箭头函数可以直接返回一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">uname</span>) =&gt; (&#123; <span class="hljs-attr">uname</span>: uname &#125;) <span class="hljs-comment">// 属性: 值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">uname</span>) =&gt; (&#123; uname &#125;) <span class="hljs-comment">//属性和值的名字一样的时候也可以简写</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;ye&#x27;</span>) <span class="hljs-comment">//&#123;uname: &#x27;ye&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>这里不用大括号包着是因为对象的大括号和其冲突了，所以用小括号代替了。</p><h3 id="箭头函数没有arguments动态参数"><a href="#箭头函数没有arguments动态参数" class="headerlink" title="箭头函数没有arguments动态参数"></a>箭头函数没有arguments动态参数</h3><p>箭头函数里面只有<em>剩余参数…arr</em>,所以只能用剩余参数来传入数组进行计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSum</span> = (<span class="hljs-params">...arr</span>) =&gt; &#123;<br><span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>sum +=arr[i]<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>那么何为动态参数，何为剩余参数呢？</p><h4 id="arguments动态参数"><a href="#arguments动态参数" class="headerlink" title="arguments动态参数"></a>arguments动态参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>) <span class="hljs-comment">//[2,3,4]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++)&#123;<br>sum +=<span class="hljs-variable language_">arguments</span>[i]<br>&#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>arguments动态参数只存在于function函数里面，其是个伪数组，在函数里充当傀儡。</p><h4 id="函数剩余参数"><a href="#函数剩余参数" class="headerlink" title="函数剩余参数"></a>函数剩余参数</h4><p>剩余参数没有的固定名字，这里以arr为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">a,b,...arr</span>) &#123; <span class="hljs-comment">//这里arr是名字，可以自定义</span><br>    <span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">//[4,5]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        sum += arr[i]<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>可以看到剩余参数顾名思义就是取剩下没有对号入座的参数。a&#x3D;2,b&#x3D;3,那么剩下的就由arr接收。注意前面的三个点是<em>展开运算符</em>，它可以让这几个数字组合成一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn = <span class="hljs-function">(<span class="hljs-params">...arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//[1,2,3]</span><br></code></pre></td></tr></table></figure><p>没有展开运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数this问题"><a href="#箭头函数this问题" class="headerlink" title="箭头函数this问题"></a>箭头函数this问题</h3><p>我们知道this是指向的是环境对象，比如我们输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//&#123;number: &#x27;1&#x27;, hello: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们定义了一个obj对象然后里面放了一个number和一个hello函数，当我们用obj调用hello函数时，this就指向了obj。那么我们就可以初次判断出谁调用的这个函数，this就指向谁。是不是这样呢？我们可以就单纯输入下面这行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>我们发现返回的是window，而我们知道window是作用域链的链头。因为我们清楚其实我们每次调用函数都应该要在前面加上window作为调用的对象，但是这样极其的重复与单调故将其省去了。这样也就说明了this确实是指向其调用的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>() <span class="hljs-comment">//window</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>() <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>回到这个论题，我们可以发现每一个新函数都要根据它是被如何调用的来定义这个函数的this值，非常让人讨厌。因此在箭头函数中，箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。</p><p>当我们再输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//Window</span><br></code></pre></td></tr></table></figure><p>hello的上一级时obj，而调用obj的对象是window，所以输出window。</p><p>再比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">count</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;<br>        <span class="hljs-title function_">count</span>()<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//&#123;number: &#x27;1&#x27;, hello: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>count函数的上一层是hello，而调用hello的是obj对象，所以输出obj。</p><p>然而在实际开发中，事件回调函数使用箭头函数时，this为全局的window。因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListner</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">//this指向btn</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX-axios库使用与http协议</title>
    <link href="/2024/04/26/axios/"/>
    <url>/2024/04/26/axios/</url>
    
    <content type="html"><![CDATA[<h3 id="AJAX-axios库使用与http协议"><a href="#AJAX-axios库使用与http协议" class="headerlink" title="AJAX-axios库使用与http协议"></a>AJAX-axios库使用与http协议</h3><p>当我们需要将前后端数据进行传递时，我们可以运用AJAX技术。AJAX也就是异步的JavaScript和XML(Asynchronous JavaScript And XML)。简单的说，就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON,XML,HTML和text文本等格式发送和接收数据。</p><h4 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h4><p><img src="/2024/04/26/axios/ajax.gif" alt="ajax工作原理"></p><ol><li>网页中发生一个事件（页面加载、按钮点击）</li><li>由 JavaScript 创建 XMLHttpRequest 对象</li><li>XMLHttpRequest 对象向 web 服务器发送请求</li><li>服务器处理该请求</li><li>服务器将响应发送回网页</li><li>由 JavaScript 读取响应</li><li>由 JavaScript 执行正确的动作（比如更新页面）</li></ol><h4 id="axios使用"><a href="#axios使用" class="headerlink" title="axios使用"></a>axios使用</h4><p>axios是基于Promise的HTTP客户端作用于浏览器和node.js，属于网络请求库。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>引入axios.js的两种方法：</p><p>使用 jsDelivr CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 unpkg CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>函数基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;目标地址&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//后端返回数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="axios-查询参数"><a href="#axios-查询参数" class="headerlink" title="axios-查询参数"></a>axios-查询参数</h5><p>使用axios提供的params选项(param是“参数”的意思)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">params</span>:&#123;<br>参数名:值<br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//返回值</span><br>    <span class="hljs-comment">//console.log(result)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://hmajax.itheima.net/api/city&#x27;</span>,<br>    <span class="hljs-attr">params</span>:&#123;<br>        <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;河北省&#x27;</span><br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/axios/image-20240426231418816.png" alt="返回的json格式文件"></p><p>查询完的数据就可以在Response里找到result值，一般情况是返回一个message和一个res，其返回的数据是个json文件。</p><h5 id="axios-请求配置"><a href="#axios-请求配置" class="headerlink" title="axios-请求配置"></a>axios-请求配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;请求方法&#x27;</span>,<br><span class="hljs-attr">data</span>:&#123;<br>参数名:值<br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//返回值</span><br>    <span class="hljs-comment">//console.log(result)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>axios将data对象的数据通过上述方式传入后端，后端就会根据其传入的关键词获得对应的res并在then后面得到。</p><h5 id="axios-错误处理"><a href="#axios-错误处理" class="headerlink" title="axios-错误处理"></a>axios-错误处理</h5><p>在then方法的后面，通过点语法调用catch方法，传入回调函数并定义形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-comment">//请求选项</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br><span class="hljs-comment">//处理数据</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-comment">//处理错误</span><br>    <span class="hljs-comment">//console.log(error)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>该方法可以捕捉到错误数据，并将数据传入error形参中，于是就可以将错误数据解析并返回客户端中显示。（其实error可以用console.log在控制台查看，但是catch可以将数据传入并可解析）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>) <span class="hljs-comment">//一般情况下可以通过这样解析json文件并弹出问题</span><br></code></pre></td></tr></table></figure><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h5><p>http协议规定了浏览器发送及服务器返回内容的格式，也就是如果你传入data对象，报文会将其转化为一个json文件打包传给后端，然后后端再传入对应的json文件。</p><p>如下图就是一个请求报文(也就是请求头)：</p><p><img src="/2024/04/26/axios/image-20240426232117702.png" alt="Request Headers"></p><p>Accept中可以看到返回的是个json文件，Host是域名，User-Agent是用来模仿用户登录。</p><h5 id="Resonpse-Headers"><a href="#Resonpse-Headers" class="headerlink" title="Resonpse Headers"></a>Resonpse Headers</h5><p>当我们后端受到前端的request headers后就会相应的传入response headers，这个headers包括：响应行，响应头，空行，响应体。响应体就包含了我们需要的json文件，浏览器会将该文件通过js渲染，显示于页面中。在文件传输的时候可能会有前后传递出错的时候，这时候就需要状态码来告知错误信息。</p><p>状态码有如下几种：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集其实解决的内容就是类似于集合合并的问题，然而如果用普通的数组去储存一个集合若数据量大，不仅调用时占用内存空间大，而且不便于插入或查询操作，因此引入并查集可以很好的解决这点。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>1.将两个集合合并</p><p>2.询问两个元素是否再一个集合当中</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>理解这个问题就需要把集合给看成一个树，然后这个树的树根就代表这个集合。当想询问其中一个节点时，我们只要访问这个节点father，然后再找这个father的grandfather直到到树根，就能确定这个点的树根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p[x]表示x的父节点</span><br><span class="hljs-keyword">if</span>(p[x]==x) <span class="hljs-comment">//判断树根</span><br><span class="hljs-keyword">while</span>(p[x]!=x) x=p[x] <span class="hljs-comment">//求x的集合编号</span><br></code></pre></td></tr></table></figure><h4 id="合并两个集合"><a href="#合并两个集合" class="headerlink" title="合并两个集合"></a>合并两个集合</h4><p>合并集合只需要将其中一个集合的树根的编号改成另一个集合的根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[x]=y<span class="hljs-comment">//px是x的集合编号，py是y的集合编号</span><br></code></pre></td></tr></table></figure><p>(俗称：给x的祖宗又认了一个爹)</p><p><img src="/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/find%E5%87%BD%E6%95%B0.png" alt="find函数"></p><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>当你找到这个节点的根节点时，就把这些节点的父亲全部变成根节点的编号，也就是让这些节点全部指向根节点。当实现了这个操作后，其查询操作直接将时间复杂度变成O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//寻找根+路径压缩</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1-合并集合"><a href="#1-合并集合" class="headerlink" title="1.合并集合"></a>1.合并集合</h4><p>一共有 n𝑛 个数，编号是 1∼n1∼𝑛，最开始每个数各自在一个集合中。</p><p>现在要进行 m𝑚 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a𝑎 和 b𝑏 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a𝑎 和 b𝑏 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n𝑛 和 m𝑚。</p><p>接下来 m𝑚 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a𝑎 和 b𝑏 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1051≤𝑛,𝑚≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br><span class="hljs-keyword">Yes</span><br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//核心函数，find(x)最终返回值就是x的根节点编号</span><br>    <span class="hljs-keyword">if</span>(x!=p[x]) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-type">int</span> n,m,a,b;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>        p[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;M&quot;</span>)&#123;<br>            p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//让a根节点的父亲变成b节点的根节点</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;Q&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))&#123; <span class="hljs-comment">//判断两个数是不是属于同一个集合，其实就是两个根编号是不是一样</span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-合并根"><a href="#2-合并根" class="headerlink" title="2.合并根"></a>2.合并根</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>w 星球的一个种植园，被分成 m<em>×</em>n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。</p><p>这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。</p><p>如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行，两个整数 <em>m</em>，<em>n</em>，用空格分开，表示格子的行数、列数（1&lt;<em>m</em>,<em>n</em>&lt;1000）。</p><p>接下来一行，一个整数 k，表示下面还有 <em>k</em> 行数据(0&lt;<em>k</em>&lt;1e5)。</p><p>接下来 <em>k</em> 行，每行两个整数 a<em>，</em>b<em>，表示编号为 a</em> 的小格子和编号为 b 的小格子合根了。</p><p>格子的编号一行一行，从上到下，从左到右编号。</p><p>比如：5×4 的小格子，编号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1  2  3  4<br>5  6  7  8<br>9  10 11 12<br>13 14 15 16<br>17 18 19 20<br></code></pre></td></tr></table></figure><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>一行一个整数，表示答案</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">5 4<br>16<br>2 3<br>1 5<br>5 9<br>4 8<br>7 8<br>9 10<br>10 11<br>11 12<br>10 14<br>12 16<br>14 18<br>17 18<br>15 19<br>19 20<br>9 13<br>13 17<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">1000005</span>],vis[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//寻找根</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,k,a,b,sum=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++) p[i]=i;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//合并集合</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++)&#123;<br>        <span class="hljs-comment">// cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-keyword">if</span>(i==p[i])sum++;<br>    &#125;<br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题使用并查集解题，核心主要两个步骤：寻找该元素的根、合并两个集合</p><p>然后最后判断是用if(i&#x3D;&#x3D;p[i])来判断这里的根有几个，因为我们知道只有p[x]&#x3D;&#x3D;x时，才是这个树的根(因为在数组上理解就是所有的数字比如：[-1，1，2，3，4] —&gt; [ -1，4，2，1，3]，我们可以发现数组的顺序表示数字，而对应上面的数字就是其根的索引，在并查集的操作下只有根节点是i&#x3D;&#x3D;p[i]，因此我们也可以将其作为判断几个集合的依据)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础数据结构之栈、队列、链表</title>
    <link href="/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="c-基础数据结构之栈、队列、链表"><a href="#c-基础数据结构之栈、队列、链表" class="headerlink" title="c++基础数据结构之栈、队列、链表"></a>c++基础数据结构之栈、队列、链表</h2><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q <span class="hljs-comment">//queue&lt;定义类型&gt;定义名称</span><br>q.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//出队</span><br>q.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//入队</span><br>q.<span class="hljs-built_in">front</span>()<span class="hljs-comment">//队首</span><br>q.<span class="hljs-built_in">rear</span>()<span class="hljs-comment">//队尾</span><br>q.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//队长(队长可以为0)</span><br>q.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//是否为空队(若是则返回1)</span><br></code></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt;st<br>st.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//出栈</span><br>st.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//入栈</span><br>st.<span class="hljs-built_in">top</span>()<span class="hljs-comment">//栈顶</span><br>st.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//栈长</span><br>st.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//判断是否为空栈</span><br></code></pre></td></tr></table></figure><h3 id="1-单链表-注意结构体写法"><a href="#1-单链表-注意结构体写法" class="headerlink" title="1.单链表(注意结构体写法)"></a>1.单链表(注意结构体写法)</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现一个单链表，链表初始为空，支持三种操作： </p><p>(1) 向链表头插入一个数；</p><p>(2) 删除第k个插入的数后面的数；</p><p>(3) 在第k个插入的数后插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 </p><p><a href="https://www.ixigua.com/7241418740699824643">https://www.ixigua.com/7241418740699824643</a></p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数M，表示操作次数。 </p><p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种： </p><p>(1) “H x”，表示向链表头插入一个数x。 </p><p>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 </p><p>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 </p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。 </p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。 </p><h4 id="输入样例-复制"><a href="#输入样例-复制" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制"><a href="#输出样例-复制" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6 4 6 5<br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-comment">//建立了一个对象</span><br>    <span class="hljs-type">int</span> num; <span class="hljs-comment">//节点值</span><br>    <span class="hljs-type">int</span> time; <span class="hljs-comment">//第几次插入</span><br>    node* next; <span class="hljs-comment">//定义下一个节点的指针位置</span><br>&#125;;<br>node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<span class="hljs-comment">//创建一个新对象叫head</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">headin</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    node* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<span class="hljs-comment">//创建一个新节点</span><br>    p-&gt;num=n;<span class="hljs-comment">//把值输入节点中，箭头写法表示对象的属性</span><br>    p-&gt;time=i;<span class="hljs-comment">//这是次数</span><br><br>    <span class="hljs-comment">//下面就是插入模板操作</span><br>    p-&gt;next=head-&gt;next;<br>    head-&gt;next=p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">de</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;<br>    node* p, * q;<span class="hljs-comment">//定义两个节点</span><br>    p=head-&gt;next;<span class="hljs-comment">//p为指向head的下一个节点</span><br>    <span class="hljs-keyword">if</span>(!t)&#123;<br>        head-&gt;next=p-&gt;next;<span class="hljs-comment">//head指的是头，里面没值，所以实际的链表头是p</span><br>        <span class="hljs-built_in">delete</span>(p);<span class="hljs-comment">//p是实际头节点</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(p)&#123;<span class="hljs-comment">//找到第t次插入的数</span><br>            <span class="hljs-keyword">if</span>(p-&gt;time==t)<span class="hljs-keyword">break</span>;<br>            p=p-&gt;next;<br>        &#125;<br>        q=p-&gt;next;<span class="hljs-comment">//让q在p的前面，辅助删除p后面的节点</span><br>        p-&gt;next=q-&gt;next;<br>        <span class="hljs-built_in">delete</span>(q);<span class="hljs-comment">//删除q</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    node* p=head-&gt;next; <span class="hljs-comment">//让p指针指向head的下一个，然后用p节点找欲插入的值</span><br>    <span class="hljs-comment">//下面三行是创建新节点然后给其赋值的操作</span><br>    node* q=<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>    q-&gt;num=n;<br>    q-&gt;time=i;<br>    <span class="hljs-comment">//从链表头开始找</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;time == t)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找第t次插入的数</span><br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//把q节点插到第t次插入的数后面</span><br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//开始时链表没有值</span><br>    <span class="hljs-type">int</span> m,i,x,k;<br>    <span class="hljs-type">char</span> op;<br>    i=<span class="hljs-number">1</span>;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">headin</span>(x,i);<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">de</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(k,x,i);<br>            i++;<span class="hljs-comment">//因为题目是记录第几次插入的数，所以要用i计数</span><br>        &#125;            <br>    &#125;<br>    node* p = head-&gt;next;<span class="hljs-comment">//让p指向实际头节点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        cout&lt;&lt; p-&gt;num &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        p=p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-简单计算器"><a href="#2-简单计算器" class="headerlink" title="2.简单计算器"></a>2.简单计算器</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。</p><p><a href="https://www.ixigua.com/7213692123635024436">https://www.ixigua.com/7213692123635024436</a></p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。</p><p>100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p><h4 id="输入样例-复制-1"><a href="#输入样例-复制-1" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4 + 2 * 5 - 7 / 11<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制-1"><a href="#输出样例-复制-1" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">13.36<br></code></pre></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">double</span>&gt;d_st;<br>stack&lt;<span class="hljs-type">char</span>&gt;op_st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">level</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;+&#x27;</span>||a==<span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;*&#x27;</span>||a==<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> c=op_st.<span class="hljs-built_in">top</span>();op_st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">double</span> a,b;<br>    a=d_st.<span class="hljs-built_in">top</span>();<br>    d_st.<span class="hljs-built_in">pop</span>();<br>    b=d_st.<span class="hljs-built_in">top</span>();<br>    d_st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;+&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b+a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b-a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;*&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b*a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;/&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b/a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-built_in">getline</span>(cin,str);<br>    <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(str[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-comment">//如果是数字</span><br>            x=str[i]-<span class="hljs-string">&#x27;0&#x27;</span>; <br>            <span class="hljs-keyword">while</span>(str[i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                x=x*<span class="hljs-number">10</span>+str[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            d_st.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//把字符串数字转化为整型并推入栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span> || str[i]==<span class="hljs-string">&#x27;-&#x27;</span> || str[i]==<span class="hljs-string">&#x27;*&#x27;</span> || str[i]==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(op_st.<span class="hljs-built_in">empty</span>()||<span class="hljs-built_in">level</span>(str[i])&gt;<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<span class="hljs-comment">//只有优先级高于栈顶的情况才能入栈</span><br>                op_st.<span class="hljs-built_in">push</span>(str[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!op_st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">level</span>(str[i])&lt;=<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<br>                <span class="hljs-keyword">while</span>(!op_st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">level</span>(str[i])&lt;=<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<span class="hljs-comment">//拿栈顶前两个计算</span><br>                    <span class="hljs-built_in">cal</span>();<br>                &#125;<br>                op_st.<span class="hljs-built_in">push</span>(str[i]);           <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!op_st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-built_in">cal</span>();<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>,d_st.<span class="hljs-built_in">top</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-约瑟夫环-队列解法"><a href="#3-约瑟夫环-队列解法" class="headerlink" title="3.约瑟夫环(队列解法)"></a>3.约瑟夫环(队列解法)</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>n和m。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4 17<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1 3 4 2<br></code></pre></td></tr></table></figure><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;qe;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        qe.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!qe.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br>            x=qe.<span class="hljs-built_in">front</span>();<br>            qe.<span class="hljs-built_in">pop</span>();qe.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//把队头放到对尾</span><br>        &#125;<br>        x=qe.<span class="hljs-built_in">front</span>();qe.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//数到的数彻底出队</span><br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-走出迷宫-bfs"><a href="#4-走出迷宫-bfs" class="headerlink" title="4.走出迷宫(bfs)"></a>4.走出迷宫(bfs)</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。</p><p>假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。</p><p>视频讲解：<a href="https://www.ixigua.com/7166253132702450212">https://www.ixigua.com/7166253132702450212</a></p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。</p><p>接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出从起点到出口最少需要走的步数。</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">3 3<br>S#T<br>.#.<br>...<br></code></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> a[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> r,c;<br>    <span class="hljs-type">int</span> step;<br>&#125;;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sr,<span class="hljs-type">int</span> sc,<span class="hljs-type">int</span> er,<span class="hljs-type">int</span> ec)</span></span>&#123;<br>    queue&lt;node&gt;qe;<span class="hljs-comment">//注意定义方式</span><br>    node q,t;<span class="hljs-comment">//t用来记录q的一圈4个方向</span><br>    q.r=sr,q.c=sc;<br>    q.step=<span class="hljs-number">0</span>;<br>    qe.<span class="hljs-built_in">push</span>(q);<br>    vis[q.r][q.c]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!qe.<span class="hljs-built_in">empty</span>())&#123;<br>        q=qe.<span class="hljs-built_in">front</span>();<br>        qe.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(q.r==er &amp;&amp; q.c==ec)&#123;<br>            cout&lt;&lt;q.step;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            t.r=q.r+dir[i][<span class="hljs-number">0</span>];<br>            t.c=q.c+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(a[t.r][t.c]==<span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; vis[t.r][t.c]==<span class="hljs-number">0</span> &amp;&amp; t.r&gt;=<span class="hljs-number">1</span>&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=<span class="hljs-number">1</span>&amp;&amp;t.c&lt;=n)&#123;<br>                t.step=q.step+<span class="hljs-number">1</span>;<br>                vis[t.r][t.c]=<span class="hljs-number">1</span>;<br>                qe.<span class="hljs-built_in">push</span>(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> sr,sc,er,ec;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>        cin&gt;&gt;a[i][j];<br>        <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)sr=i,sc=j;<br>        <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;T&#x27;</span>)er=i,ec=j,a[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>(sr,sc,er,ec);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-出入栈判断"><a href="#5-出入栈判断" class="headerlink" title="5.出入栈判断"></a>5.出入栈判断</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入第一行表示一个整数n, n&lt;&#x3D;100</p><p>接下来输入n行，每行表示一个a~z的排列。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。</p><h4 id="输入样例-复制-2"><a href="#输入样例-复制-2" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>abcdefghijklmnopqrstuvwxyz<br>zabcdefghijklmnopqrstuvwxy<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制-2"><a href="#输出样例-复制-2" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">yes<br>no<br></code></pre></td></tr></table></figure><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>5<br>abcdegfhijklnmopqrstuvwxyz<br>abcdegfhijklnmopqrstzyxwvu<br>dcbaegfhijklnmopqrstuvwxyz<br>abcdegfhijkwxyzlnmopqrstuv<br>abcdegfhijklnmouvwxyztsrqp</p><p>yes<br>yes<br>yes<br>no<br>yes</p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack &lt;<span class="hljs-type">char</span>&gt; st;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>(),j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> ch=i+<span class="hljs-string">&#x27;a&#x27;</span>;<br>            st.<span class="hljs-built_in">push</span>(ch);<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>()==s[j])&#123;<br>                st.<span class="hljs-built_in">pop</span>(),j++;<br>            &#125;<br> <br>        &#125;<br>        <span class="hljs-keyword">if</span>(j==len)cout&lt;&lt;<span class="hljs-string">&quot;yes\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;no\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基本语法</title>
    <link href="/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript基础语法介绍"><a href="#JavaScript基础语法介绍" class="headerlink" title="JavaScript基础语法介绍"></a>JavaScript基础语法介绍</h2><h3 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h3><h4 id="1-1-JavaScript是什么"><a href="#1-1-JavaScript是什么" class="headerlink" title="1.1 JavaScript是什么"></a>1.1 JavaScript是什么</h4><p>是一个运行在浏览器上的编程语言。</p><h4 id="1-2JavaScript书写位置"><a href="#1-2JavaScript书写位置" class="headerlink" title="1.2JavaScript书写位置"></a>1.2JavaScript书写位置</h4><p>内部式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)<span class="hljs-comment">//页面弹出警示框</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>外部式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./my.js&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>使用外部时，script标签里面不要写内容，否则会被忽略。</p><h4 id="1-3JavaScript输入输出语法"><a href="#1-3JavaScript输入输出语法" class="headerlink" title="1.3JavaScript输入输出语法"></a>1.3JavaScript输入输出语法</h4><p>输出语法1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>输出语法2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)<span class="hljs-comment">//页面弹出警示框</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出语法3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;haha&#x27;</span>)<span class="hljs-comment">//控制台输出语法，程序员调试使用</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>输入语法1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入&#x27;</span>)<span class="hljs-comment">//弹出一个对话框</span><br></code></pre></td></tr></table></figure><p>prompt输入类型为字符串。</p><h4 id="1-4-字面量"><a href="#1-4-字面量" class="headerlink" title="1.4 字面量"></a>1.4 字面量</h4><p>比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="2-1-变量是什么"><a href="#2-1-变量是什么" class="headerlink" title="2.1 变量是什么"></a>2.1 变量是什么</h4><p>白话：用来装数据的盒子。可以用来存放数据。</p><h4 id="2-2-变量的基本使用"><a href="#2-2-变量的基本使用" class="headerlink" title="2.2 变量的基本使用"></a>2.2 变量的基本使用</h4><p>(与c语言定义类似)</p><h5 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1.声明变量"></a>1.声明变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> variable <span class="hljs-comment">//var存在与老版的JavaScript中</span><br></code></pre></td></tr></table></figure><p>age为变量。</p><h5 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2.变量赋值"></a>2.变量赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">variable = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>variable为变量，18为字面量。</p><p>变量不允许多次定义。</p><p>小小的变量使用一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> n=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(n)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="2-3-变量命名规则与规范"><a href="#2-3-变量命名规则与规范" class="headerlink" title="2.3 变量命名规则与规范"></a>2.3 变量命名规则与规范</h4><h5 id="1-规则"><a href="#1-规则" class="headerlink" title="1. 规则"></a>1. 规则</h5><p>①不能用关键字。</p><p>②只能用下划线、字母、数字、＄组成，且不能用数字开头。</p><p>③字母严格区分大小写。</p><h5 id="2-规范"><a href="#2-规范" class="headerlink" title="2.规范"></a>2.规范</h5><p>①起名要有意义。</p><p>②遵守小驼峰命名法。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-1-声明数组"><a href="#1-1-声明数组" class="headerlink" title="1.1 声明数组"></a>1.1 声明数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h4 id="1-2-数组的基本使用"><a href="#1-2-数组的基本使用" class="headerlink" title="1.2 数组的基本使用"></a>1.2 数组的基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">//索引</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>) <span class="hljs-comment">//获取长度</span><br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> G = <span class="hljs-number">9.8</span><br></code></pre></td></tr></table></figure><p>常量不允许重新赋值，声明的时候必须赋值。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>js为弱数据类型语言，只有赋值了才知道是什么数据类型。</p><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>number 数字型</p><p>string 字符串型</p><p>boolean 布尔型</p><p>undefined 未定义型</p><p>null 空类型</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>object 对象</p><h4 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1.数字类型"></a>1.数字类型</h4><p>数字类型可以由+ - * &#x2F; %各个符号进行运算。</p><p>NaN (not a number)：表示计算错误。</p><p>NaN是粘性的，任何对NaN的操作都会返回NaN。</p><h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h4><p>通过单引号、双引号或反引号包裹的数据都叫字符串。</p><h5 id="字符串拼接："><a href="#字符串拼接：" class="headerlink" title="字符串拼接："></a>字符串拼接：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>+<span class="hljs-string">&#x27;34&#x27;</span>) <span class="hljs-comment">//字符串可以用加号拼接</span><br><span class="hljs-keyword">let</span> a=<span class="hljs-string">&#x27;k&#x27;</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-string">&#x27;q&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k+q)<br></code></pre></td></tr></table></figure><h5 id="模板字符串："><a href="#模板字符串：" class="headerlink" title="模板字符串："></a>模板字符串：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`大家好，我叫<span class="hljs-subst">$&#123;name&#125;</span>,今年<span class="hljs-subst">$&#123;age&#125;</span>岁`</span>) <span class="hljs-comment">//用反引号,变量用＄&#123;&#125;包裹</span><br></code></pre></td></tr></table></figure><h4 id="3-布尔型-bollean"><a href="#3-布尔型-bollean" class="headerlink" title="3.布尔型 (bollean)"></a>3.布尔型 (bollean)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n=<span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br></code></pre></td></tr></table></figure><h4 id="4-未定义类型-undefined"><a href="#4-未定义类型-undefined" class="headerlink" title="4.未定义类型 (undefined)"></a>4.未定义类型 (undefined)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">//输出undefined</span><br></code></pre></td></tr></table></figure><h4 id="5-空类型-null"><a href="#5-空类型-null" class="headerlink" title="5.空类型 (null)"></a>5.空类型 (null)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj=<span class="hljs-literal">null</span> <span class="hljs-comment">//表示赋值了一个空的内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj) <br></code></pre></td></tr></table></figure><p>如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null</p><h4 id="6-检测数据类型"><a href="#6-检测数据类型" class="headerlink" title="6.检测数据类型"></a>6.检测数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> num <span class="hljs-comment">//num为变量</span><br><span class="hljs-title function_">typeof</span>(num)<br></code></pre></td></tr></table></figure><h4 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7.类型转换"></a>7.类型转换</h4><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>+号两边只要有一个是字符串，都会把另外一个转成字符串。</p><p>除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数字&#x27;</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">//返回&#x27;数字1&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">//返回&#x27;11&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>) <span class="hljs-comment">//返回0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">//返回123</span><br></code></pre></td></tr></table></figure><h5 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h5><p>通过函数来进行数据转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>(str) <span class="hljs-comment">//转换为数字类型</span><br><span class="hljs-keyword">let</span> num = +<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入&#x27;</span>) <span class="hljs-comment">//输入的可以转换为数字类型</span><br></code></pre></td></tr></table></figure><p>parse系列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(num) <span class="hljs-comment">//只保留数字且只保留整数</span><br><span class="hljs-built_in">parseFloat</span>(num) <span class="hljs-comment">//保留数字并保留小数</span><br><span class="hljs-built_in">parseInt</span>(12px) <span class="hljs-comment">//12 </span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-number">12.</span>86px) <span class="hljs-comment">//12.86</span><br></code></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><h5 id="前置自增"><a href="#前置自增" class="headerlink" title="前置自增"></a>前置自增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++i + <span class="hljs-number">2</span>) <span class="hljs-comment">//2+2=4</span><br></code></pre></td></tr></table></figure><p>先自加再使用。</p><h5 id="后置自增"><a href="#后置自增" class="headerlink" title="后置自增"></a>后置自增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i++ + <span class="hljs-number">2</span>) <span class="hljs-comment">//1+2=3 此时i已经为2，但是没有参与运算</span><br></code></pre></td></tr></table></figure><p>先使用再自加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i++ + ++i + i) <span class="hljs-comment">//1+3+3=7 第二个i时i为2</span><br></code></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<br>&lt;<br>&gt;=<br>&lt;=<br>== <span class="hljs-comment">//左右两边值是否相等</span><br>===<span class="hljs-comment">//左右两边是否类型和值都相等</span><br>!== <span class="hljs-comment">//左右两边是否不全等</span><br></code></pre></td></tr></table></figure><p>NaN不等于任何人，包括它自己。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (条件) &#123;<br>满足条件执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>条件中只有数字0或者空字符会触发false，其余都是true。</p><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>可以代替if双分支。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">条件 ? 满足条件执行的代码 : 不满足条件执行的代码<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-number">3</span>&lt;<span class="hljs-number">5</span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;真的&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;假的&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span>&lt;<span class="hljs-number">5</span> ? <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;真的&#x27;</span>) : <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;假的&#x27;</span>)<br></code></pre></td></tr></table></figure><p>等价。</p><p>还可以作赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">5</span> <span class="hljs-comment">//sum=3</span><br></code></pre></td></tr></table></figure><h4 id="数字补0例子"><a href="#数字补0例子" class="headerlink" title="数字补0例子"></a>数字补0例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请您输入一个数字&#x27;</span>) <span class="hljs-comment">//类型为string</span><br>num = num &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> + num : num <span class="hljs-comment">//判断小于10才补0</span><br><span class="hljs-title function_">alert</span>(num)<br></code></pre></td></tr></table></figure><p>输入9，输出09</p><p>输入11，输出11</p><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">//[3,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>push() 添加数组末尾</p><p>unshift() 添加数组开头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">//[1,2,3,4]</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[1,2,3,4,5]</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">//[0,1,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>pop() 弹出最后一个元素</p><p>shift() 弹出第一个元素</p><p>splice() 切片删除  &#x2F;&#x2F;arr.plice(起始位置，删除几个)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">//[1,2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">pop</span>()) <span class="hljs-comment">//3</span><br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">//[2,3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">shift</span>) <span class="hljs-comment">//1</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">//[1,3]</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//[1] 删除索引1后面的所有</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//[1]</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">函数名</span>() &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">函数名<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> sayhi&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">sayhi</span>()<br></code></pre></td></tr></table></figure><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">throw</span> expression;<br></code></pre></td></tr></table></figure><p>使用这个语句后就会弹出error：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;not 4&quot;</span>; <span class="hljs-comment">//Uncaught not 4</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try…catch语句"><a href="#try…catch语句" class="headerlink" title="try…catch语句"></a>try…catch语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span>&#123;<br>...<br><br>&#125; <span class="hljs-keyword">catch</span> (error)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>&#125;<br></code></pre></td></tr></table></figure><p>catch块可以用来处理所有try块总产生的异常。</p><h4 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">openMyFile</span>();<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title function_">writeMyFile</span>(theData); <span class="hljs-comment">//This may throw a error</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-title function_">handleError</span>(e); <span class="hljs-comment">// If we got a error we handle it</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-title function_">closeMyFile</span>(); <span class="hljs-comment">// always close the resource</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>finally</code>块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。<code>finally</code>块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，<code>finally</code>块里的语句也会执行。</p><h3 id="循环与迭代"><a href="#循环与迭代" class="headerlink" title="循环与迭代"></a>循环与迭代</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for_%E8%AF%AD%E5%8F%A5">for 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#do...while_%E8%AF%AD%E5%8F%A5">do…while 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#while_%E8%AF%AD%E5%8F%A5">while 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#label_%E8%AF%AD%E5%8F%A5">label 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#break_%E8%AF%AD%E5%8F%A5">break 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_%E8%AF%AD%E5%8F%A5">continue 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_%E8%AF%AD%E5%8F%A5">for…in 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_%E8%AF%AD%E5%8F%A5">for…of 语句</a></li></ul><p>其循环方式与c语言相似，不再一一赘述。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为<em>方法</em>。</p><p>对象及其属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>myCar.<span class="hljs-property">make</span> = <span class="hljs-string">&quot;Ford&quot;</span>;<br>myCar.<span class="hljs-property">model</span> = <span class="hljs-string">&quot;Mustang&quot;</span>;<br>myCar.<span class="hljs-property">year</span> = <span class="hljs-number">1969</span>;<br></code></pre></td></tr></table></figure><p>可以按如下方法访问对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">myCar[<span class="hljs-string">&quot;make&quot;</span>] = <span class="hljs-string">&quot;Ford&quot;</span>;<br>myCar[<span class="hljs-string">&quot;model&quot;</span>] = <span class="hljs-string">&quot;Mustang&quot;</span>;<br>myCar[<span class="hljs-string">&quot;year&quot;</span>] = <span class="hljs-number">1969</span>;<br></code></pre></td></tr></table></figure><h4 id="创建新对象"><a href="#创建新对象" class="headerlink" title="创建新对象"></a>创建新对象</h4><h5 id="使用对象初始化器创建"><a href="#使用对象初始化器创建" class="headerlink" title="使用对象初始化器创建"></a>使用对象初始化器创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">property_1</span>: value_1, <span class="hljs-comment">// property_# 可以是一个标识符...</span><br>  <span class="hljs-number">2</span>: value_2, <span class="hljs-comment">// 或一个数字...</span><br>  [<span class="hljs-string">&quot;property&quot;</span> + <span class="hljs-number">3</span>]: value_3, <span class="hljs-comment">//  或一个可计算的 key 名...</span><br>  <span class="hljs-comment">// ...,</span><br>  <span class="hljs-string">&quot;property n&quot;</span>: value_n,<br>&#125;; <span class="hljs-comment">// 或一个字符串</span><br></code></pre></td></tr></table></figure><h5 id="使用构造函数创建"><a href="#使用构造函数创建" class="headerlink" title="使用构造函数创建"></a>使用构造函数创建</h5><p>用构造函数创建分两种：</p><ol><li>通过创建一个构造函数来定义对象的类型。(建议首字母大写)</li><li>通过 <code>new</code> 创建对象实例。</li></ol><p>这里首先定义一个<em>对象类型</em>，并且赋予其make,model,year属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里是通过this来给对象类型属性值赋值</p><p>然后你就可以创建一个新对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mycar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Eagle&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>);<br></code></pre></td></tr></table></figure><p>或者你也可以让类中加入一个owner：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year, owner</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = owner;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么你就可以这样创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Eagle&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>, rand);<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Nissan&quot;</span>, <span class="hljs-string">&quot;300ZX&quot;</span>, <span class="hljs-number">1992</span>, ken);<br></code></pre></td></tr></table></figure><p>就可以这样索引读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car2.<span class="hljs-property">owner</span>.<span class="hljs-property">name</span>;<br></code></pre></td></tr></table></figure><p>你也可以为之前定义的对象增加新的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car1.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;black&quot;</span>;<br></code></pre></td></tr></table></figure><p>注意这里只是这个car1增加了新属性，不影响其他car1,car3</p><h5 id="使用Object-create方法创建"><a href="#使用Object-create方法创建" class="headerlink" title="使用Object.create方法创建"></a>使用Object.create方法创建</h5><p>及使用Object.create()函数创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Invertebrates&quot;</span>, <span class="hljs-comment">// 属性默认值(无脊椎动物)</span><br>  <span class="hljs-attr">displayType</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类里面可以包含函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>); <span class="hljs-comment">//该函数用来显示type的值</span><br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// 创建一种新的动物——animal1</span><br><span class="hljs-keyword">var</span> animal1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>);<br>animal1.<span class="hljs-title function_">displayType</span>(); <span class="hljs-comment">// 输出:Invertebrates(因为没有没有给type赋值)</span><br><br><span class="hljs-comment">// 创建一种新的动物——Fishes</span><br><span class="hljs-keyword">var</span> fish = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>);<br>fish.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;Fishes&quot;</span>;<br>fish.<span class="hljs-title function_">displayType</span>(); <span class="hljs-comment">// 输出:Fishes</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的将秒换算成-时:分:秒？</title>
    <link href="/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/"/>
    <url>/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="如何优雅的将秒换算成-时-分-秒？"><a href="#如何优雅的将秒换算成-时-分-秒？" class="headerlink" title="如何优雅的将秒换算成-时:分:秒？"></a>如何优雅的将秒换算成-时:分:秒？</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先看一下题目，发现就是一道模拟题，但是又一些细节的。</p><p>首先是数据的规模：时间不超过 10^18,所以需要开 long long。</p><p>然后首先要忽略掉毫秒。</p><p>这里普及一个知识:1<em>s</em> &#x3D; 1000ms</p><p>所以需要忽略后面的三位。直接整除 1000 就可以了。</p><p>之后就是处理时分秒了：</p><h4 id="1-小时"><a href="#1-小时" class="headerlink" title="1.小时"></a>1.小时</h4><p>由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用<code>24*60*60</code>来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数<code>60*60</code>（也就是3600），就是小时值了。</p><h4 id="2-分钟"><a href="#2-分钟" class="headerlink" title="2.分钟"></a>2.分钟</h4><p>分钟要先对每小时的秒数<code>60*60</code>取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。</p><h4 id="3-秒"><a href="#3-秒" class="headerlink" title="3.秒"></a>3.秒</h4><p>直接对60取余，剩下的就是秒了。</p><p>时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。</p><p>当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。</p><p>要用到两个函数：</p><p>一个是<code>setw()</code>函数，这个函数可以限定域宽，宽度就是括号里的数字。</p><p>另外一个<code>setfill()</code>函数，这个函数可以设置当实际的宽度不足<code>setw()</code>函数的值时，用某个字符来补足。（<code>setfill()</code>函数最好放在<code>setw()</code>函数前面）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,h,m,s;<br>    cin&gt;&gt;n;<br>    n=n/<span class="hljs-number">1000</span>;<br>    h=n%(<span class="hljs-number">24</span>*<span class="hljs-number">3600</span>)/<span class="hljs-number">3600</span>;<br>    m=n%<span class="hljs-number">3600</span>/<span class="hljs-number">60</span>;<br>    s=n%<span class="hljs-number">60</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;h&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;m&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css背景</title>
    <link href="/2024/01/20/css-bgc/"/>
    <url>/2024/01/20/css-bgc/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color(bgc)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p>颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制…</p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>background-image(bgi)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;图片的路径&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>①背景图片中url可以省略引号。</p><p>②背景图片默认是在水平和垂直方向平铺的。</p><p>③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。</p><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p>background-repeat(bgr)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-repeat</span>:no-repeat;<br>&#125;<br></code></pre></td></tr></table></figure><p>repeat (默认值)水平和垂直方向都平铺</p><p>no-repeat 不平铺</p><p>repeat-x 沿着水平方向(x轴)平铺</p><p>repeat-y 沿着垂直方向(y轴)平铺</p><h3 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h3><p>background-position(bgp)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方位名词"><a href="#方位名词" class="headerlink" title="方位名词"></a>方位名词</h4><h5 id="水平方向"><a href="#水平方向" class="headerlink" title="水平方向"></a>水平方向</h5><p>left、center、right</p><h5 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h5><p>top、center、bottom</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>: right bottom; //水平位置 垂直位置<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字-px"><a href="#数字-px" class="headerlink" title="数字+px"></a>数字+px</h4><h5 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h5><p>①原点(0,0) 盒子左上角</p><p>②x轴 水平向右</p><p>③y轴 垂直向下</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>将图片左上角与坐标点重合即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">50px</span> <span class="hljs-number">100px</span>; //水平位置 垂直位置<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背景相关属性连写"><a href="#背景相关属性连写" class="headerlink" title="背景相关属性连写"></a>背景相关属性连写</h3><p>background: color image repeat position</p><p>可以不按顺序写。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background</span>: pink <span class="hljs-built_in">url</span>(<span class="hljs-string">./images/1.jpg</span>) no-repeat bottom center ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="与img的区别"><a href="#与img的区别" class="headerlink" title="与img的区别"></a>与img的区别</h4><p>①img标签是一个标签，不设置宽高默认会以原尺寸显示。</p><p>②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归——深度优先搜索(dfs)</title>
    <link href="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/"/>
    <url>/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/</url>
    
    <content type="html"><![CDATA[<h2 id="递归——深度优先搜索-dfs"><a href="#递归——深度优先搜索-dfs" class="headerlink" title="递归——深度优先搜索(dfs)"></a>递归——深度优先搜索(dfs)</h2><p>区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索：</p><p>递归方法类似于栈，将数据一直递取到底后自下往上出栈。</p><p>大致框架如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">viod <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(输出条件)&#123;<br>        cout&lt;&lt;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)&#123;<br>                a[k]=数字,vis[i]=<span class="hljs-number">1</span><span class="hljs-comment">//标记使用;</span><br>                <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//向下递取</span><br>                vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将其拿出，返回原先状态</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下列题目方式解决一些排列组合问题。</p><h4 id="组合输出-–5个数字组合输入3个盒子"><a href="#组合输出-–5个数字组合输入3个盒子" class="headerlink" title="组合输出 –5个数字组合输入3个盒子"></a>组合输出 –5个数字组合输入3个盒子</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231018142215689.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m,n,r;<br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>],vis[<span class="hljs-number">200</span>];<span class="hljs-comment">//a用来记录牌子，vis用来记录牌子的使用情况</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_rise</span><span class="hljs-params">(<span class="hljs-type">int</span> b[])</span></span>&#123;<span class="hljs-comment">//判断是否是递增数组</span><br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;r;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&gt;a[i+<span class="hljs-number">1</span>])&#123;<br>            flag=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//k为盒子的编号，或可以理解为步数</span><br>    <span class="hljs-keyword">if</span>(k==r+<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">is_rise</span>(a))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。</span><br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)&#123;<br>            a[k]=i,vis[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将牌子拿出来，此时就要把vis归回0</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;r;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。</p><h4 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a>素数环</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231017155808693.png"></p><p>eg：输入8 输出4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],vis[<span class="hljs-number">25</span>];<br><span class="hljs-type">int</span> n,cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isPrime</span>(a[<span class="hljs-number">1</span>]+a[n]))&#123;<span class="hljs-comment">//是否超出边界&amp;&amp;是否头尾相加是素数</span><br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isPrime</span>(i+a[k<span class="hljs-number">-1</span>]))&#123;<span class="hljs-comment">//vis用来看有没有用过这个数字</span><br>            a[k]=i,vis[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//a用来保存数字</span><br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前的这个数字清除，再向下dfs</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;cnt; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231012224152754.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>]; <span class="hljs-comment">//a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//depth first search</span><br><span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//i是指拿在你手上的牌的数字，没用0为了更好理解</span><br><span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//看看这个牌用过没有，b数组用来看这个牌用过没有用的</span><br>a[k]=i,b[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了</span><br><span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里</span><br>b[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推</span><br>&#125;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231024213457892.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,cnt;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],vis[<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//      cout&lt;&lt;sum&lt;&lt;&quot; &quot;;</span><br>        vis[sum]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,sum+a[k]);<br>    <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i])cnt++;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若把上面代码的注释删除则可以得到：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>由此可知上面深度搜索遍历的顺序是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span>+<span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">3</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">4</span><br><span class="hljs-attribute">0</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231107093250409.png"></p><p>以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。</p><p>相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬取pixiv日前十图片并下载至本地</title>
    <link href="/2023/09/11/pixiv-crawler/"/>
    <url>/2023/09/11/pixiv-crawler/</url>
    
    <content type="html"><![CDATA[<h1 id="爬取pixivic日前十图片"><a href="#爬取pixivic日前十图片" class="headerlink" title="爬取pixivic日前十图片"></a>爬取pixivic日前十图片</h1><p>实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910131905687.png" alt="image-20230910131905687.png"></p><h4 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h4><p>首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910132233727.png" alt="image-20230910132233727.png"></p><p>于是我们就可以向这个api发送请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;</span><br>reponse = requests.get(url)<br><span class="hljs-built_in">print</span>(reponse)  <span class="hljs-comment">#返回&lt;Response [200]&gt;</span><br></code></pre></td></tr></table></figure><p>因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。</p><h4 id="2-解析数据"><a href="#2-解析数据" class="headerlink" title="2.解析数据"></a>2.解析数据</h4><p>返回数据长这个样子：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910132826060.png" alt="image-20230910132826060.png"></p><h5 id="json使用"><a href="#json使用" class="headerlink" title="json使用"></a>json使用</h5><p>这就是标准的json形式文件，但还不是一个字典(其实很像)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。</p><p>我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">response.json()[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>]<br><span class="hljs-comment">#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png</span><br><span class="hljs-comment">#就是日排行第一的图</span><br></code></pre></td></tr></table></figure><p>但是当你将网站复制进浏览器时你会发现打不开。</p><h5 id="url拼接"><a href="#url拼接" class="headerlink" title="url拼接"></a>url拼接</h5><p>也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910133814148.png" alt="image-20230910133814148.png"></p><p><img src="/2023/09/11/pixiv-crawler/image-20230910133823700.png" alt="image-20230910133823700.png"></p><p>图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。</p><h4 id="3-下载图片至本地"><a href="#3-下载图片至本地" class="headerlink" title="3.下载图片至本地"></a>3.下载图片至本地</h4><p>目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img_url = <span class="hljs-string">&quot;https://acgpic.net/c/540x540_70/img-master&quot;</span>+response.json()[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>][<span class="hljs-number">32</span>:-<span class="hljs-number">4</span>]+<span class="hljs-string">&quot;_master1200.jpg&quot;</span><br><br>img = requests.get(img_url)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./top1.jpg&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#&quot;wb&quot;是以二进制写入</span><br>f.write(img.content)  <span class="hljs-comment">#content是指获取二进制内容</span><br></code></pre></td></tr></table></figure><p>此时你已经可以看到top1的图片下载当前文件夹了。</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910135314561.png" alt="image-20230910135314561.png"></p><p>同理，下载前十的图片只需要加入for循环就可以了，以下省略。</p><h4 id="4-下载至指定文件夹"><a href="#4-下载至指定文件夹" class="headerlink" title="4.下载至指定文件夹"></a>4.下载至指定文件夹</h4><p>这里就需要导入os包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>path = <span class="hljs-string">&#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27;</span>  <span class="hljs-comment">#这是我的绝对地址</span><br><span class="hljs-keyword">if</span>(os.path.exists(path)==<span class="hljs-literal">False</span>):  <span class="hljs-comment">#判断是否存在该文件夹</span><br>    os.mkdir(path)  <span class="hljs-comment">#创建该文件夹，文件夹名字为2023-9-7</span><br></code></pre></td></tr></table></figure><h5 id="path书写"><a href="#path书写" class="headerlink" title="path书写"></a>path书写</h5><p>这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910140553967.png" alt="image-20230910140553967.png"></p><p>第二条中的r是用来申明不是转义字符。</p><p>这样就可以创建一个文件夹了~</p><p>然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。</p><h4 id="5-关于api中日期的变化"><a href="#5-关于api中日期的变化" class="headerlink" title="5.关于api中日期的变化"></a>5.关于api中日期的变化</h4><p>因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>day = datetime.date.today()<br>api_day = day-datetime.timedelta(days=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>然后只需要再拼接如url中就可以啦~</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> datetime<br><br>day = datetime.date.today()<br>api_day = day-datetime.timedelta(days=<span class="hljs-number">3</span>)<br><br>url = <span class="hljs-string">&quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;</span>+<span class="hljs-built_in">str</span>(api_day)+<span class="hljs-string">&quot;&amp;mode=day&amp;pageSize=302&quot;</span><br>response = requests.get(url)<br>date = url[<span class="hljs-number">40</span>:<span class="hljs-number">50</span>]<br>path = <span class="hljs-string">&#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;</span>+date  <span class="hljs-comment">#linux写法</span><br><br><span class="hljs-keyword">if</span>(os.path.exists(path)==<span class="hljs-literal">False</span>):  <span class="hljs-comment">#判断是否存在该文件夹</span><br>    os.mkdir(path)  <span class="hljs-comment">#创建该文件夹</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img_url = <span class="hljs-string">&quot;https://acgpic.net/c/540x540_70/img-master&quot;</span>+response.json()[<span class="hljs-string">&quot;data&quot;</span>][i][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>][<span class="hljs-number">32</span>:-<span class="hljs-number">4</span>]+<span class="hljs-string">&quot;_master1200.jpg&quot;</span><br>    img = requests.get(img_url)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path+<span class="hljs-string">&quot;/top&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;.jpg&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(img.content)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存top&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;中...&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫 --- 以爬取笔趣阁小说为例</title>
    <link href="/2023/08/31/biquge/"/>
    <url>/2023/08/31/biquge/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫-—-以爬取笔趣阁小说为例"><a href="#爬虫-—-以爬取笔趣阁小说为例" class="headerlink" title="爬虫 — 以爬取笔趣阁小说为例"></a>爬虫 — 以爬取笔趣阁小说为例</h1><h4 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/5418/2610707.html&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>&#125;<br>response = requests.get(url,headers)<br></code></pre></td></tr></table></figure><p>这是requests请求，若返回response值为200，则表示请求成功</p><h4 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">response = requests.get(url,headers).text<br></code></pre></td></tr></table></figure><p>可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析</p><h4 id="3-解析数据"><a href="#3-解析数据" class="headerlink" title="3.解析数据"></a>3.解析数据</h4><p>有以下几种途径：css、xpath、re正则表达 等等</p><p>让我们来看看分别用这三种方法怎么去解析到一个章节的标题</p><h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br>selector = parsel.Selector(response)<br>novel_title = selector.css(<span class="hljs-string">&quot;.bookname h1::text&quot;</span>).get()<br></code></pre></td></tr></table></figure><p>这种方法通过css选择器进行选择</p><h5 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br>selector = parsel.Selector(response)<br>novel_title = selector.xpath(<span class="hljs-string">&quot;//*[@class=&quot;</span>bookname<span class="hljs-string">&quot;]/h1/text()&quot;</span>).get()<br></code></pre></td></tr></table></figure><p>注意text后面的()</p><h5 id="re"><a href="#re" class="headerlink" title="re"></a>re</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>novel_title = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串</p><p>*注意：以上方法各有利弊，选择合适的方式来解析数据</p><h4 id="4-保存数据"><a href="#4-保存数据" class="headerlink" title="4.保存数据"></a>4.保存数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file_name&quot;</span>+<span class="hljs-string">&quot;.txt&quot;</span>,mode=<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入</span><br>f.write(novel_context)  <span class="hljs-comment">#写入文件</span><br></code></pre></td></tr></table></figure><p>with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径</p><h4 id="以上思路已经理清楚了，下面开始实践："><a href="#以上思路已经理清楚了，下面开始实践：" class="headerlink" title="以上思路已经理清楚了，下面开始实践："></a>以上思路已经理清楚了，下面开始实践：</h4><h3 id="爬取一章"><a href="#爬取一章" class="headerlink" title="爬取一章"></a>爬取一章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/5418/2610707.html&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>&#125;<br>response = requests.get(url,headers).text<br><br>selector = parsel.Selector(response)<br>novel_title = selector.css(<span class="hljs-string">&quot;.bookname h1::text&quot;</span>).get() <span class="hljs-comment">#css方法解析数据</span><br><br>novel_context_list = selector.css(<span class="hljs-string">&quot;#htmlContent p::text&quot;</span>).getall() <br>novel_context = <span class="hljs-string">&quot;\n&quot;</span>.join(novel_context_list)<br></code></pre></td></tr></table></figure><p>注意：join函数的使用：</p><p><img src="/2023/08/31/biquge/p1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(a))  <span class="hljs-comment">#输出1 2 8 9</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>.join(a))  <span class="hljs-comment">#输出1(换行)2(换行)8(换行)9</span><br><br>b=&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(a))  <span class="hljs-comment">#输出a b</span><br></code></pre></td></tr></table></figure><p>（注意seq不能是int整形）</p><h3 id="爬取各章url"><a href="#爬取各章url" class="headerlink" title="爬取各章url"></a>爬取各章url</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/18753/&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>    &#125;<br>response = requests.get(url,headers).text<br>novel_name = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br>novel_info = re.findall(<span class="hljs-string">&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,response)<br><span class="hljs-keyword">for</span> novel_url_part,novel_title <span class="hljs-keyword">in</span> novel_info:<br>    novel_url = <span class="hljs-string">&quot;https://www.xzmncy.com&quot;</span>+novel_url_part[<span class="hljs-number">0</span>:<span class="hljs-number">24</span>]<br>    <span class="hljs-built_in">print</span>(novel_url)<br>    <span class="hljs-built_in">print</span>(novel_title)<br></code></pre></td></tr></table></figure><p>在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的：</p><p><img src="/2023/08/31/biquge/image-20230831120348951.png" alt="image-20230831120348951"></p><p>我们就可以用re来解析到各个章节的url和title</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> parsel<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/18753/&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>    &#125;<br>response = requests.get(url,headers).text<br>novel_name = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br>novel_info = re.findall(<span class="hljs-string">&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,response)<br><span class="hljs-keyword">for</span> novel_url_part,novel_title <span class="hljs-keyword">in</span> novel_info:<br>    novel_url = <span class="hljs-string">&quot;https://www.xzmncy.com&quot;</span>+novel_url_part[<span class="hljs-number">0</span>:<span class="hljs-number">24</span>]<br>    novel_response = requests.get(novel_url, headers).text<br>    selectors = parsel.Selector(novel_response)<br>    novel_context_list = selectors.css(<span class="hljs-string">&quot;#htmlContent p::text&quot;</span>).getall()<br>    novel_context = <span class="hljs-string">&quot;\n&quot;</span>.join(novel_context_list)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存&quot;</span>+novel_title)<br>    novel_title = <span class="hljs-string">&quot;*&quot;</span> + novel_title<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(novel_name+<span class="hljs-string">&quot;.txt&quot;</span>,mode=<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(novel_title)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>        f.write(novel_context)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器</title>
    <link href="/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><p>引入方式有以下三种：</p><p>1.内嵌式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!-- 内嵌式 --&gt;<br>&lt;!DOCTYPE <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span> lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-<span class="hljs-number">8</span>&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-scale=<span class="hljs-number">1.0</span>&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>        colour&#123;<br>colour:pink;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>2.外联式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 外联式 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./111.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 111为引入文件名 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.行内式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 行内式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;colour&quot;</span>&gt;</span><br>        abcd<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: aqua;font-size: large;&quot;</span>&gt;</span>abab<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>一共有4种：标签选择器、类选择器、id选择器、通符选择器</p><p>注：一下选择器均是在style标签下的</p><h4 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div)</p><h4 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2.类选择器"></a>2.类选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.color-choose</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其html调用方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;color-choose&quot;</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3.id选择器"></a>3.id选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#color</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其html调用方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：id只得调用一次</p><h4 id="4-通符选择器"><a href="#4-通符选择器" class="headerlink" title="4.通符选择器"></a>4.通符选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br>&lt;!-- 清除内外边距 --&gt;<br></code></pre></td></tr></table></figure><p>对全局内容生效</p><h2 id="选择器的选择"><a href="#选择器的选择" class="headerlink" title="选择器的选择"></a>选择器的选择</h2><h4 id="1-后代-（后面所有代）"><a href="#1-后代-（后面所有代）" class="headerlink" title="1.后代  （后面所有代）"></a>1.后代  （后面所有代）</h4><p>问题如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 哈哈哈 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>欲选择div中的p标签，而不是外部的p</p><p>以如下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>        <span class="hljs-attribute">color</span>:blue;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="2-子代-（后面一代）"><a href="#2-子代-（后面一代）" class="headerlink" title="2.子代  （后面一代）"></a>2.子代  （后面一代）</h4><p>问题是要选中div后面的一代</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> dd <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span> ddd <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以如下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-并集"><a href="#3-并集" class="headerlink" title="3.并集"></a>3.并集</h4><p>问题：想要让以下这些标签被选到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> p <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> div <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> span <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> haha <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下面方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">span</span>,<span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-交集"><a href="#4-交集" class="headerlink" title="4.交集"></a>4.交集</h4><p>问题：只想要选中下面p中带class&#x3D;”c”的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>abcd<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下面方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.c</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>p是标签，c是类名（前面带个.的）</p><h4 id="5-伪类"><a href="#5-伪类" class="headerlink" title="5.伪类"></a>5.伪类</h4><p>问题：想要让鼠标悬停在如下超链接上能够变色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;~~~&quot;</span>&gt;</span>传送<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br><span class="hljs-attribute">color</span>:red;<br><span class="hljs-attribute">background-color</span>:yellow;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破壳啦</title>
    <link href="/2023/08/21/page1/"/>
    <url>/2023/08/21/page1/</url>
    
    <content type="html"><![CDATA[<p>终于创建好一个博客啦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
