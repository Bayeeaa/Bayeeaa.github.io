<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git使用时出现的问题小汇总</title>
    <link href="/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/"/>
    <url>/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="git提交"><a href="#git提交" class="headerlink" title="git提交"></a>git提交</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">git add * <span class="hljs-regexp">//</span>将所有上传文件进入缓存区域<br>git commit -m <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-regexp">//</span>提交申请注释，双引号里面就是注释内容<br>(*) git remote add origin https <span class="hljs-regexp">//</span>关联远程仓库，关联后以后就可以不再重复关联<br>git push -u origin main <span class="hljs-regexp">//</span>推入仓库main分支<br></code></pre></td></tr></table></figure><h4 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h4><p>在 <code>git commit</code> 命令中，<code>-m</code> 选项用于指定提交消息。Git 提交时需要一个消息来描述这次提交的目的或更改内容。使用 <code>-m</code> 选项可以让你在命令行中直接输入提交消息，而不是打开编辑器。使用 <code>-m</code> 选项可以快速地提供提交消息。</p><p>如果你不使用 <code>-m</code> 选项，Git 会打开你配置的默认文本编辑器（例如 Vim、Nano 等），让你在编辑器中输入提交消息。这适用于较长或复杂的提交消息，允许你在编辑器中进行详细描述和格式化。</p><h4 id="u"><a href="#u" class="headerlink" title="-u"></a>-u</h4><p>在git push -u origin main中我们可以看到有个-u，-u 是–set-upstream的缩写。它的作用是将本地分支与远程分支建立跟踪关系。它有一下这几点作用：</p><ul><li>将本地分支与远程分支关联起来，使得以后可以简化 <code>git push</code> 和 <code>git pull</code> 命令的使用。</li><li>设置当前分支的上游分支（即跟踪的远程分支），方便在以后的操作中，Git 可以自动推送和拉取数据。</li></ul><h3 id="error-failed-to-push-some-refs-to-‘http’"><a href="#error-failed-to-push-some-refs-to-‘http’" class="headerlink" title="error: failed to push some refs to ‘http’"></a>error: failed to push some refs to ‘http’</h3><p><img src="/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/image-20240702172843116.png" alt="rror: failed to push some refs to &#39;http&#39;"></p><p>这个报错是指本地的文件和仓库中有冲突的部分，所以要先拉取github上的，然后再推上去。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git pull <span class="hljs-built_in">origin</span><br>git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main   (或者master)<br></code></pre></td></tr></table></figure><h3 id="error-src-refspec-main-does-not-match-any"><a href="#error-src-refspec-main-does-not-match-any" class="headerlink" title="error: src refspec main does not match any"></a>error: src refspec main does not match any</h3><p>由于是新创建的仓库还没有main分支(或者是你还没切换到这个分支上面)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git checkout -<span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">main</span>   <br></code></pre></td></tr></table></figure><p>切换到当前分支main。</p><h3 id="如何将msater的内容合并到main分支，并删除master？"><a href="#如何将msater的内容合并到main分支，并删除master？" class="headerlink" title="如何将msater的内容合并到main分支，并删除master？"></a>如何将msater的内容合并到main分支，并删除master？</h3><p>要将 <code>master</code> 分支的内容合并到 <code>main</code> 分支，并删除 <code>master</code> 分支，你可以按照以下步骤进行操作。这些步骤假设你已经在本地仓库中，并且你希望在本地和远程仓库中同步这些更改。</p><ol><li><p><strong>切换到 <code>main</code> 分支</strong>： 确保你在 <code>main</code> 分支上，使用以下命令切换到 <code>main</code> 分支：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git checkout <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure></li><li><p><strong>更新 <code>main</code> 分支</strong>： 确保 <code>main</code> 分支是最新的。如果你正在使用远程仓库，先拉取远程更新：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git pull origin <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure></li><li><p>**合并 <code>master</code> 分支到 <code>main</code>**： 使用以下命令将 <code>master</code> 分支的内容合并到 <code>main</code> 分支：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> master<br></code></pre></td></tr></table></figure><p>如果有合并冲突，Git 会提示你解决冲突。解决所有冲突后，完成合并并提交更改：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> &lt;conflicted-<span class="hljs-built_in">files</span>&gt;<br>git commit<br></code></pre></td></tr></table></figure></li><li><p><strong>推送合并后的 <code>main</code> 分支到远程仓库</strong>： 将合并后的 <code>main</code> 分支推送到远程仓库：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure></li><li><p><strong>删除 <code>master</code> 分支</strong>：</p><ul><li><p><strong>在本地删除 <code>master</code> 分支</strong>： 确保你已经切换到 <code>main</code> 分支后，可以删除本地的 <code>master</code> 分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git branch -d <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><p>如果 <code>master</code> 分支没有完全合并到 <code>main</code>，而你确定要删除，可以使用 <code>-D</code> 强制删除：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git branch -D <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure></li><li><p><strong>在远程删除 <code>master</code> 分支</strong>： 使用以下命令将 <code>master</code> 分支从远程仓库删除：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal: refusing to merge unrelated histories"></a>fatal: refusing to merge unrelated histories</h3><h4 id="表示-Git-拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下："><a href="#表示-Git-拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下：" class="headerlink" title="表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下："></a>表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下：</h4><ol><li><strong>两个分支或仓库的历史完全不同</strong>：<ul><li>比如，你尝试合并两个完全不同的项目，或者一个是新创建的仓库，另一个是老的仓库。</li></ul></li><li><strong>从远程仓库克隆时历史不同</strong>：<ul><li>如果你从一个远程仓库克隆了一个新的仓库，而本地仓库中已经有一些历史记录，Git 会认为这些历史不相关。</li></ul></li></ol><p>可以使用 <code>--allow-unrelated-histories</code> 选项来允许合并不相关的历史。以下是详细的步骤：</p><ol><li><p><strong>切换到 <code>main</code> 分支</strong>： 确保你在目标分支（通常是 <code>main</code> 分支）上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git checkout <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure></li><li><p><strong>执行合并命令并允许不相关的历史</strong>： 使用 <code>--allow-unrelated-histories</code> 选项来合并 <code>master</code> 分支到 <code>main</code> 分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git merge <span class="hljs-keyword">master</span> <span class="hljs-title">--allow-unrelated-histories</span><br></code></pre></td></tr></table></figure><p>这会允许 Git 合并两个没有共同历史的分支。</p></li><li><p><strong>解决合并冲突</strong>： 如果在合并过程中遇到冲突，Git 会提示你解决这些冲突。解决冲突后，完成合并：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> &lt;conflicted-<span class="hljs-built_in">files</span>&gt;<br>git commit<br></code></pre></td></tr></table></figure></li><li><p><strong>推送合并后的 <code>main</code> 分支到远程仓库</strong>： 将合并后的 <code>main</code> 分支推送到远程仓库：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3+ts项目的基本路由配置</title>
    <link href="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="导入router"><a href="#导入router" class="headerlink" title="导入router"></a>导入router</h3><p>首先在main.ts文件中导入router，并将其use入app中让其挂载。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>;<br>app.<span class="hljs-title function_">use</span>(router)<br></code></pre></td></tr></table></figure><p>这样就可以在app中导入router了。</p><h3 id="路由文件index-ts配置"><a href="#路由文件index-ts配置" class="headerlink" title="路由文件index.ts配置"></a>路由文件index.ts配置</h3><p>为了更标准，我们在src文件中创立一个router文件夹，然后在文件夹中创建index.ts文件。</p><p>在index文件中，我们就可以将组件的路径记录到其中，这样就可以按照需要访问组件了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>           <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;shouye&#x27;</span><br>           <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/Home&#x27;</span> ,<br>           <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>        &#125;<br>    ]<br>&#125;)<br><br><span class="hljs-comment">//将router暴露出去(default 默认)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>我们先导入createRouter和createWebHistory(或createWebHashHistory)，然后再const一个router对象，里面存入history和routes。像这里我导入的是Home.vue组件，然后就可以在routes中写入path和component(path可以和组件的名字不一样，而且浏览器地址栏是不区分大小写的)。在router中history是必不可少的，其中有两种模式可以选择，我们这里选择createWebHistory。</p><p>最后不要忘记将router方法暴露出去。</p><p>这样我们就已经可以访问”&#x2F;home”组件了，但是我们的组件应该要配合layout来显示，具体放在页面的那个地方才合适呢？</p><h3 id="控制组件存放位置"><a href="#控制组件存放位置" class="headerlink" title="控制组件存放位置"></a>控制组件存放位置</h3><p>使用中存放组件的位置用RouterView标签，触发标签用RouterLink标签。</p><p>首先我们还是一样要在script中导入RouterView，RouterLink：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RouterView</span>, <span class="hljs-title class_">RouterLink</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br></code></pre></td></tr></table></figure><p>然后就可以在template中使用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div :style=&quot;&#123; padding: &#x27;24px&#x27;, background: &#x27;#fff&#x27;, minHeight: &#x27;600px&#x27; &#125;&quot;&gt;<br>  &lt;RouterView&gt;&lt;/RouterView&gt;          <br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>其中组件都会在RouterView的位置显示。而我们触发事件就要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/home&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>这里需要配合button等来配合使用。</p><p>当然考虑到地址的变化，也可以这样写RouterLink：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink :to=&quot;&#123;path:/home&#125;&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink :to=&quot;&#123;name:shouye&#125;&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><h3 id="子路由配置"><a href="#子路由配置" class="headerlink" title="子路由配置"></a>子路由配置</h3><p>我们上面配置都是一级路由，而二级子路由要怎么配置呢？</p><p>首先我们找到index.ts文件，再里面添加children在path中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>           <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;shouye&#x27;</span>,<br>           <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/Home&#x27;</span> ,<br>           <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br>           <span class="hljs-attr">children</span>:[<br>            &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail&#x27;</span>, <span class="hljs-comment">//不要加斜杠</span><br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br>        &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后我们只需在RouterLink里面修改to的路径就可以了，也就是我们可以localhost&#x2F;home&#x2F;detail来访问子组件了。</p><h3 id="路由传参方法"><a href="#路由传参方法" class="headerlink" title="路由传参方法"></a>路由传参方法</h3><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>使用query传参我们需要在RouterLink的to中加入需要传入的值，比如我们想传给子组件“qq”一词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/detail?a=qq&amp;b=kk&quot;&gt;&lt;/RouterLink&gt;  <br></code></pre></td></tr></table></figure><p>可以看到我给子组件通过“路径?变量&#x3D;值”将值传递，然后在子组件中我们需要再导入router接收传递的信息，就可以使用了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">let</span> route = <span class="hljs-title function_">useRoute</span>()<br></code></pre></td></tr></table></figure><p>html:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; route.query.a &#125;&#125;<br></code></pre></td></tr></table></figure><p>这样就可以在页面中呈现了。</p><p>顺便我们log route一下就可以看到页面传递的值：</p><p><img src="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/image-20240719200614527.png" alt="query参数"></p><p>而如果我们需要通过for来改变传递的值，可以按照示例中这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink :to=&quot;`/detail?a=$&#123;shops.id&#125;`&quot;&gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink <br>  :to=&quot;&#123;<br>path:&#x27;/detail&#x27;                   <br>    query:&#123;<br>         a:shops.id,<br>        &#125;<br>    &#125;&quot;<br>  &gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>与query传参不同的是，params传参在index.ts中的path需要提前占位，在to中就可以对path中占的位对号入座。</p><p>比如我在path中用x占位：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:x?&#x27;</span>, <span class="hljs-comment">//这里的冒号表示占位，问号表示这个地方可能有展位也可能没有（问号不加也可以）</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br></code></pre></td></tr></table></figure><p>然后在template中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/detail/aa&quot;&gt;<br>&lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>&lt;/RouterLink&gt;  <br></code></pre></td></tr></table></figure><p>再在子组件中console.log(route)一下就可以发现：</p><p><img src="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/image-20240719214457064.png" alt="params参数"></p><p>最后用params接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; route.params.a &#125;&#125;<br></code></pre></td></tr></table></figure><p>然后同样可以用变量传递的方式传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink <br>  :to=&quot;&#123;<br>name:&#x27;xiangqing&#x27;                  <br>    query:&#123;<br>         a:shops.id,<br>        &#125;<br>    &#125;&quot;<br>  &gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><p>但注意这里不能用path，只能用name来判断路径。</p><h3 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h3><h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h4><p>在路由配置中加上props:true，再在组件中加入defineProps([… , … ,])就可以将路由收到的params参数作为props传给组件。</p><p>子路由：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:id/:title/:content&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><span class="hljs-attr">props</span>:<span class="hljs-literal">true</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;title&#x27;</span>,<span class="hljs-string">&#x27;content&#x27;</span>])<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; id &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h4><p>也可以传递query参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:id/:title/:content&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br><span class="hljs-keyword">return</span> route.<span class="hljs-property">query</span><br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>query不用占位，params需要占位。</p><p>本节使用RouterLink标签进行跳转，其中to属性解释来添加跳转的位置，可以用对象的方法书写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite构建的项目“@”地址无法解析问题</title>
    <link href="/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用vite构建项目后，发现无法识别”@”地址：</p><p><img src="/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/image-20240719223909893.png" alt="报错提示"></p><p>经过排查是由于config文件中没有配置”@”对应的路径：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>打开vite.config.ts文件，改成：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)) <span class="hljs-comment">//这里的配置就是可以让@可以读取成&#x27;./src&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>中间的reslove的alias所包含的就是”@”的配置项，这样我们就可以用@来代替.&#x2F;src。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP地址</title>
    <link href="/2024/07/10/IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/07/10/IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="内网ip和公网ip"><a href="#内网ip和公网ip" class="headerlink" title="内网ip和公网ip"></a>内网ip和公网ip</h4><p>内网IP（Internal Network IP）是指在局域网或者内部网络中使用的IP地址。在IPv4的网络中，内网IP地址通常属于私有IP地址范围，例如：</p><ul><li>10.0.0.0 到 10.255.255.255</li><li>172.16.0.0 到 172.31.255.255</li><li>192.168.0.0 到 192.168.255.255</li></ul><p>这些地址是专门为局域网内部使用而保留的，不会被分配到互联网上，因此可以重复使用。内网IP地址的作用是在局域网内部进行设备之间的通信和连接，比如连接本地打印机、路由器、局域网内的计算机等。</p><p>与内网IP相对的是公网IP（Public IP），公网IP是可以被全球互联网访问到的IP地址，用于在不同的网络之间进行通信。</p><p>我们可以通过</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ipconfig<br></code></pre></td></tr></table></figure><p>来访问我们电脑现在的内网ip(也就是ipv4地址)</p><p><img src="/2024/07/10/IP%E5%9C%B0%E5%9D%80/image-20240710152532331.png" alt="IP"></p><p>公网IP（Public IP）是指可以直接在全球互联网上访问到的IP地址。它是由互联网服务提供商（ISP，也就是移动，联通这些公司）分配给网络设备（如路由器、服务器等）的唯一标识符，用于在互联网上进行通信和数据交换。</p><p>公网IP地址是全球唯一的，不同的设备在互联网上需要具有不同的公网IP地址，这样才能保证它们之间能够正确地进行通信和数据传输。公网IP地址通常是静态或动态分配的，静态公网IP地址在一段时间内不会改变，而动态公网IP地址可能会在连接重新建立时发生变化。</p><p>通常情况下，个人用户使用的是动态公网IP地址，而企业或特定应用可能会使用静态公网IP地址，以便更稳定地提供服务和进行网络管理，一般情况下我们个人都是先使用内网然后再通过了路由将数据与公网进行交换，如果想要个人直接接入公网，需要向ISP特别申请。</p><p>通俗的说，内网ip与公网ip就好比寄快递，内网ip是几栋几号室，而公网ip是哪个省哪个市，有了这些ip地址后，我们才能把信息精确分配到每一个计算机个体。</p><h4 id="ipv4和ipv6"><a href="#ipv4和ipv6" class="headerlink" title="ipv4和ipv6"></a>ipv4和ipv6</h4><p>IPv4（Internet Protocol version 4）是互联网协议第四版，是当前广泛使用的互联网协议之一。IPv4定义了互联网上数据的传输方式，它使用32位（4个字节）的地址长度来标识网络上的每个设备或节点。</p><p>IPv4地址通常以点分十进制表示，例如：192.168.1.1。每个IPv4地址由四个八位组成，每个八位组可以表示0到255之间的数值，总共有约42亿个不同的IPv4地址。然而，由于互联网的迅速发展和设备的增多，IPv4地址已经逐渐不足以支持所有连接到互联网的设备。</p><p>为了解决IPv4地址耗尽的问题，IPv6（Internet Protocol version 6）被设计出来，它使用128位（16个字节）的地址长度，大大增加了可用的地址空间，预计能够长期解决IP地址耗尽的问题。IPv6的推广和采用逐渐增加，但目前仍然有大部分互联网流量使用IPv4协议。</p><p>总结起来，IPv4是互联网上广泛使用的网络协议之一，使用32位地址长度来标识网络上的设备或节点，其地址格式为点分十进制。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>由上面我们知道随着互联网的发展，ipv4逐渐枯竭。为了应对这样的情况，NAT（网络地址转换）技术孕育而生。</p><h5 id="NAT-的主要类型包括："><a href="#NAT-的主要类型包括：" class="headerlink" title="NAT 的主要类型包括："></a>NAT 的主要类型包括：</h5><ul><li>静态 NAT：静态NAT是将一个固定的私有IP地址映射到一个固定的公共IP地址的一种形式，通常用于需要特定设备具有公共IP地址的情况，如服务器。</li><li>动态 NAT：动态NAT是动态地将内部设备的私有IP地址映射到公共IP地址池中的一个可用地址，通常在需要大量设备同时访问互联网时使用。</li><li>PAT（端口地址转换）：也称为Overload NAT，它允许多个设备使用相同的公共IP地址访问互联网，但通过不同的端口号进行区分。</li></ul><p>一般情况我们我们就是通过路由器来将私有的ip地址映射到固定的公共ip地址，所以路由器在这里就充当了网关的作用。但是通过路由器传输的终端就不止一个，另一端接收方路由器对应的终端也不止一个，我们传输就无法一一对应，所以我们就要用到<strong>端口映射</strong>，通过端口号来确定我们要传输数据的终端彼此。</p><p><img src="/2024/07/10/IP%E5%9C%B0%E5%9D%80/image-20240710160048602.png" alt="大致是这样传递"></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>在知道子网掩码之前，我们要知道什么是<strong>子网</strong>。</p><p><strong>子网</strong>（Subnet）是指将一个大的IP地址块（IP地址空间）划分成若干个较小的子集，每个子集称为一个子网。在网络中，子网的作用是将一个大的网络划分成多个较小的、更易管理的部分，以便于组织和管理网络设备。</p><p>每个子网由一组连续的IP地址组成，这些IP地址共享一个公共的网络前缀（网络标识符）。这个网络前缀通常由IP地址和子网掩码（Subnet Mask）共同决定，子网掩码定义了IP地址中哪些部分是网络部分，哪些部分是主机部分。</p><p>子网的使用可以帮助网络管理员更有效地管理IP地址，减少广播风暴（Broadcast Storm）和冲突，提高网络的安全性和性能。常见的子网划分方式包括按照部门、功能或地理位置来划分子网，以便于根据需要对每个子网进行管理和配置。</p><p>那么如何确定这个ip是否在这个子网中呢？这就需要有子网掩码。子网掩码通过”&amp;”操作辨别子网：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&amp; X = X<br><span class="hljs-symbol">0 </span>&amp; X = X<br></code></pre></td></tr></table></figure><p>比如我们可以将：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.10</span> &amp; <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span> = <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br>IP &amp; 子网掩码 =&gt; 结果相同 =&gt; 同一子网<br></code></pre></td></tr></table></figure><p>如果我们通过ip和子网掩码的与操作都得到相同的结果，说明他们都在同一个子网当中。</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口（Port）是一种逻辑概念，用于区分不同应用程序或服务在同一台计算机上的通信终点。每个端口都有一个数字标识，称为端口号，用于标识特定的网络服务或应用程序。</p><h5 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h5><ol><li><strong>端口号</strong>：端口号是一个16位的整数，范围从0到65535。其中，0到1023的端口号被称为“系统端口”或“well-known端口”，它们通常分配给常见的网络服务，如HTTP（端口号80）、HTTPS（端口号443）、FTP（端口号21）等。</li><li><strong>通信终点</strong>：在一台计算机上，每个运行的应用程序或服务都可以通过一个或多个端口号来进行通信。例如，Web服务器使用HTTP协议通过端口号80接收Web请求，而电子邮件服务器使用SMTP协议通过端口号25接收邮件。</li><li><strong>传输层概念</strong>：端口属于传输层（第四层）协议的概念，在TCP&#x2F;IP模型中，这一层负责提供可靠的数据传输服务。TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们通过端口号来确定数据包应该被交付给哪个应用程序或服务。</li><li><strong>端口分类</strong>：<ul><li><strong>系统端口</strong>：0到1023，预留给众所周知的服务。</li><li><strong>注册端口</strong>：1024到49151，分配给用户进程或应用程序。</li><li><strong>动态&#x2F;私有端口</strong>：49152到65535，用于临时的短暂会话。</li></ul></li></ol><h5 id="端口的重要性："><a href="#端口的重要性：" class="headerlink" title="端口的重要性："></a>端口的重要性：</h5><ul><li><strong>多路复用</strong>：端口允许一台计算机上的多个应用程序同时进行网络通信，通过端口号区分不同的应用数据流。</li><li><strong>网络安全</strong>：端口号有助于防火墙和安全设备识别和控制不同类型的网络流量，提高网络安全性。</li><li><strong>网络管理</strong>：端口号使网络管理员可以轻松地监控和管理网络上的各种服务和应用程序。</li></ul><h4 id="以太网和因特网"><a href="#以太网和因特网" class="headerlink" title="以太网和因特网"></a>以太网和因特网</h4><p>以太网（Ethernet）和因特网（Internet）是两个不同的概念，它们在计算机网络中有着不同的角色和范围。</p><h5 id="以太网（Ethernet）："><a href="#以太网（Ethernet）：" class="headerlink" title="以太网（Ethernet）："></a>以太网（Ethernet）：</h5><ol><li><strong>定义</strong>：以太网是一种局域网（LAN）技术，用于在较小的范围内连接多台计算机和网络设备，如在办公室、校园或家庭内部。</li><li><strong>传输介质</strong>：以太网通常使用双绞线、光纤或者无线电波作为传输介质，传输速度可以从几百Mbps到几十Gbps不等。</li><li><strong>协议</strong>：以太网使用一组标准的数据链路层和物理层协议（如IEEE 802.3标准），定义了数据包在局域网内的传输方式。</li><li><strong>拓扑结构</strong>：以太网的拓扑结构可以是星型、总线型或者环型，其中最常见的是星型拓扑，每台设备连接到一个中央集线器或交换机。</li></ol><h5 id="因特网（Internet）："><a href="#因特网（Internet）：" class="headerlink" title="因特网（Internet）："></a>因特网（Internet）：</h5><ol><li><strong>定义</strong>：因特网是全球范围内的公共计算机网络，由许多不同的网络（包括以太网、光纤网络、卫星网络等）连接起来，通过TCP&#x2F;IP协议族进行数据传输和通信。</li><li><strong>范围</strong>：因特网是全球性的网络，连接了世界上几乎所有的计算机和网络设备，允许它们之间进行跨地域和跨国界的通信。</li><li><strong>协议</strong>：因特网使用TCP&#x2F;IP协议族，包括TCP（Transmission Control Protocol）和IP（Internet Protocol），定义了数据在全球范围内的传输和路由方式。</li><li><strong>服务和应用</strong>：因特网支持各种应用和服务，如电子邮件、网页浏览、文件传输、实时通信等，是人们日常生活中广泛使用的平台。</li></ol><p>简单的说以太网就是局域网，而因特网就是互联网。</p><h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）是一组通信协议，它定义了互联网和许多私有网络中数据如何传输和交换的标准。TCP&#x2F;IP协议族是现代互联网通信的基础，它包括多个协议，每个协议负责不同的功能。</p><ol><li><strong>IP（Internet Protocol）</strong>：<ul><li>IP协议负责在网络中传送数据包，并确保它们能够从源地址到目标地址安全地传输。</li><li>它定义了数据包的结构和格式，以及如何在网络中路由和转发数据包。</li></ul></li><li><strong>TCP（Transmission Control Protocol）</strong>：<ul><li>TCP协议是一种面向连接的协议，负责在通信的两端建立可靠的数据传输连接。</li><li>它确保数据包按顺序到达目的地，并处理丢失数据包的重传，以及流量控制和拥塞控制。</li></ul></li><li><strong>UDP（User Datagram Protocol）</strong>：<ul><li>UDP协议是一种无连接的协议，它提供了一种简单的数据传输服务，适用于实时应用程序和广播通信。</li><li>与TCP不同，UDP不保证数据的顺序和可靠性，但是它提供了较低的延迟和更高的传输速度。</li></ul></li><li><strong>其他协议</strong>：<ul><li><strong>ICMP（Internet Control Message Protocol）</strong>：用于在IP网络上发送控制消息，如错误报告和网络诊断。</li><li><strong>ARP（Address Resolution Protocol）</strong>：用于将IP地址映射为MAC地址（硬件地址）。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端如何将pdf等文件传入后端</title>
    <link href="/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/"/>
    <url>/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="前端如何将pdf等文件传入后端"><a href="#前端如何将pdf等文件传入后端" class="headerlink" title="前端如何将pdf等文件传入后端"></a>前端如何将pdf等文件传入后端</h2><p>我们知道在js中我们可以通过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> id=<span class="hljs-string">&quot;fileInput&quot;</span> accept=<span class="hljs-string">&quot;image/*&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>来输入文件。其中type指后端url，accept来限制传入类型。</p><h3 id="前端通过表单形式将其传入后端"><a href="#前端通过表单形式将其传入后端" class="headerlink" title="前端通过表单形式将其传入后端"></a>前端通过表单形式将其传入后端</h3><p>那么前端是怎么将这一整个文件打包传入后端的呢？</p><p>原来前端通过文件上传表单的方式将文件传输到后端。这通常涉及使用 HTML 的 <code>&lt;form&gt;</code> 元素和 <code>&lt;input type=&quot;file&quot;&gt;</code> 输入框，以及设置适当的表单属性来支持文件上传。</p><p><img src="/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/image-20240704204517908.png" alt="Payload截图"></p><p>可以看到我在使用ant design vue框架时其文件传输的内容包含状态，上传时间，文件名字等。</p><h4 id="文件上传的流程："><a href="#文件上传的流程：" class="headerlink" title="文件上传的流程："></a>文件上传的流程：</h4><ol><li>用户在文件输入框中选择一个文件。</li><li>用户点击提交按钮，浏览器将会把表单数据（包括选定的文件）打包成 <code>multipart/form-data</code> 格式的请求体。</li><li>请求被发送到指定的后端URL（在这个例子中是 <code>/upload</code>）。</li><li>后端接收到请求后，可以通过相应的框架或库来解析 <code>multipart/form-data</code>，获取到文件数据，并进行进一步处理，例如保存文件到服务器或者进行文件内容分析等操作。</li></ol><h4 id="文件上传表单示例："><a href="#文件上传表单示例：" class="headerlink" title="文件上传表单示例："></a>文件上传表单示例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;form id=<span class="hljs-string">&quot;uploadForm&quot;</span> action=<span class="hljs-string">&quot;/upload&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>&lt;form&gt;</code> 元素定义了一个表单，其中：<ul><li><code>action=&quot;/upload&quot;</code> 指定了表单提交的目标后端URL。</li><li><code>method=&quot;POST&quot;</code> 指定了使用POST方法提交表单。</li><li><code>enctype=&quot;multipart/form-data&quot;</code> 表示表单中包含文件上传，这是必需的，因为文件上传需要使用 <code>multipart/form-data</code> 类型来传输文件数据。</li></ul></li><li><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt;</code> 是文件上传的输入框，其中：<ul><li><code>type=&quot;file&quot;</code> 表示这是一个文件输入框，允许用户选择文件。</li><li><code>name=&quot;file&quot;</code> 指定了后端接收文件时的字段名称，这个名称在后端处理文件时很重要。</li><li><code>id=&quot;fileInput&quot;</code> 可以用来通过 JavaScript 获取文件输入框的引用，以便在用户选择文件后执行一些操作（例如显示文件名或大小）。</li></ul></li><li><code>&lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt;</code> 是一个提交按钮，点击它会触发表单提交操作。</li></ul><h4 id="后端处理文件上传的例子："><a href="#后端处理文件上传的例子：" class="headerlink" title="后端处理文件上传的例子："></a>后端处理文件上传的例子：</h4><ul><li><p><strong>Node.js（使用 Express 框架）：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">javascript复制代码<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>);<br><span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>(&#123; <span class="hljs-attr">dest</span>: <span class="hljs-string">&#x27;uploads/&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&#x27;file&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> file = req.<span class="hljs-property">file</span>;<br>    <span class="hljs-comment">// 处理文件，例如保存到服务器或者返回其他响应</span><br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;文件上传成功&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器运行在 http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，使用了 <code>multer</code> 中间件来处理单个文件上传，<code>upload.single(&#39;file&#39;)</code> 表示期望接收一个名为 <code>file</code> 的文件字段。</p></li><li><p><strong>PHP：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php">php复制代码<span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$target_dir</span> = <span class="hljs-string">&quot;uploads/&quot;</span>;<br><span class="hljs-variable">$target_file</span> = <span class="hljs-variable">$target_dir</span> . <span class="hljs-title function_ invoke__">basename</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);<br><span class="hljs-variable">$uploadOk</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>], <span class="hljs-variable">$target_file</span>)) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件上传成功&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件上传失败&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>PHP 示例使用了 <code>$_FILES</code> 超全局数组来接收上传的文件，并使用 <code>move_uploaded_file()</code> 函数将文件从临时位置移动到指定的目标位置。</p></li></ul><h3 id="用JS将文件传入后端"><a href="#用JS将文件传入后端" class="headerlink" title="用JS将文件传入后端"></a>用JS将文件传入后端</h3><p>上面以及展示了html文件上传表单的示例，下面再展示通过JavaScript监听文件选择事件来传递。</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;File&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="JS绑定事件"><a href="#JS绑定事件" class="headerlink" title="JS绑定事件"></a>JS绑定事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br><span class="hljs-keyword">let</span> fileList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#File&#x27;</span>).<span class="hljs-property">files</span><br>&#125;)<br><span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>,fileList[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>如果接口文档要求传递请求体(包括Content-Disposition, Content-Type等)我们使用window提供的FormData构造函数来实例化一个表单类型。</p><h4 id="axios传递"><a href="#axios传递" class="headerlink" title="axios传递"></a>axios传递</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br><span class="hljs-attr">data</span>: fd<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过ajax就可以将文件传入后端。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向JS的TypeScript</title>
    <link href="/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/"/>
    <url>/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/</url>
    
    <content type="html"><![CDATA[<h3 id="面向JS的TypeScript"><a href="#面向JS的TypeScript" class="headerlink" title="面向JS的TypeScript"></a>面向JS的TypeScript</h3><p>说到TypeScript，就不得不从Javascript说起。我们知道JavaScript（也称为 ECMAScript）最初是一种用于浏览器的简单脚本语言。在它被发明时，它被期望用于嵌入网页中的简短代码片段 - 编写几十行以上的代码有点不寻常。因此，早期的网络浏览器执行此类代码的速度非常慢。不过，随着时间的推移，JS 变得越来越流行，Web 开发者开始使用它来创建交互式体验。</p><p>JavaScript是一种为快速使用而设计的语言，与众不同的是，每种语言都有自己的“怪癖“，而 JavaScript 的卑微起步使其拥有许多这样的”怪癖“。</p><ul><li><p>JavaScript 的相等运算符 (<code>==</code>) 强制转换其操作对象，导致意外行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// It is! But why??</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt; x &lt; <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-comment">// True for any value of x!</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>JavaScript 还允许访问不存在的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-comment">// Why is this NaN? Spelling is hard!</span><br><span class="hljs-keyword">const</span> area = obj.<span class="hljs-property">width</span> * obj.<span class="hljs-property">heigth</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="TypeScript：静态类型检查器"><a href="#TypeScript：静态类型检查器" class="headerlink" title="TypeScript：静态类型检查器"></a>TypeScript：静态类型检查器</h4><p>静态检查：在不运行代码的情况下检测代码中的错误。</p><p>TypeScript 能在执行前检查程序是否有错误，并根据值的种类进行检查，使其成为静态类型检查器。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">const</span> area = obj.<span class="hljs-property">width</span> * obj.<span class="hljs-property">heigth</span>;<br><br>* <span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;heigth&#x27;</span> does not exist on type <span class="hljs-string">&#x27;&#123; width: number; height: number; &#125;&#x27;</span>. <span class="hljs-title class_">Did</span> you mean <span class="hljs-string">&#x27;height&#x27;</span>?<span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;heigth&#x27;</span> does not exist on type <span class="hljs-string">&#x27;&#123; width: number; height: number; &#125;&#x27;</span>. <span class="hljs-title class_">Did</span> you mean <span class="hljs-string">&#x27;height&#x27;</span>?<br></code></pre></td></tr></table></figure><h5 id="TypeScript是JavaScript的超集"><a href="#TypeScript是JavaScript的超集" class="headerlink" title="TypeScript是JavaScript的超集"></a>TypeScript是JavaScript的超集</h5><p>因此JS的许多语法在TS中是合法的。由于其语法，TypeScript 不会将任何 JavaScript 代码视为错误。这意味着你可以将任何有效的 JavaScript 代码放入 TypeScript 文件中，而不必担心它的具体编写方式。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = (<span class="hljs-number">4</span><br>         *<span class="hljs-string">&#x27;)&#x27;</span>expected.<br></code></pre></td></tr></table></figure><p>在TS中不会将任何JS代码看成错误。因此你可以将任何有效的JS都放入TS文件中，而不必担心其具体用法。</p><h5 id="类型化的JS超集"><a href="#类型化的JS超集" class="headerlink" title="类型化的JS超集"></a>类型化的JS超集</h5><p>TS是一个类型超集，这意味着它添加了关于如何使用不同类型的值的规则。比如在一些JS中的错误不是语法错误而是“以不正确的方式使用某种值（类型）的错误”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span> / []);<br></code></pre></td></tr></table></figure><p>这个语法上合法的程序记录了 <code>Infinity</code>。但是，TypeScript 将数字除以数组视为无意义的操作，并且会触发错误：“The right-hand side of an arithmetic operation must be of type ‘any’, ‘number’, ‘bigint’ or an enum type.”(分母必须是‘any’,’number’,’bigint’,’enum type’)。</p><h5 id="运行时的行为"><a href="#运行时的行为" class="headerlink" title="运行时的行为"></a>运行时的行为</h5><p>TypeScript 也是一种保留了 JavaScript 运行时行为的编程语言。例如，在 JavaScript 中除以零会产生 <code>Infinity</code> 而不是抛出运行时异常。原则上，TypeScript 不会改变 JavaScript 代码的运行时行为。</p><h5 id="擦除类型"><a href="#擦除类型" class="headerlink" title="擦除类型"></a>擦除类型</h5><p>一旦TS的编译器检查完代码，它就会擦除类型以生成结果的“编译”代码。这意味着一旦代码被TS编译后。生成的普通JS就没有类型信息了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的建立、遍历规则、以及节点计算</title>
    <link href="/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的建立、遍历规则、以及节点计算"><a href="#二叉树的建立、遍历规则、以及节点计算" class="headerlink" title="二叉树的建立、遍历规则、以及节点计算"></a>二叉树的建立、遍历规则、以及节点计算</h3><p>二叉树故名思意就是只有两个度的树，这里讨论其最基本的用法及逻辑。</p><p><img src="/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><h4 id="树的创立"><a href="#树的创立" class="headerlink" title="树的创立"></a>树的创立</h4><p>定义一颗二叉树首先要有一个度里的数据data，以及左右孩子，我们可以用结构体定义以方便其理解。</p><h5 id="结构体定义："><a href="#结构体定义：" class="headerlink" title="结构体定义："></a>结构体定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElementType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span><br><span class="hljs-keyword">typedef</span> Position BinTree;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span><br>    ElementType Data;<br>    BinTree Left;<br>    BinTree Right;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们给左右孩子分别定位Left和Right，这样我们就可以使用T-&gt;Left和T-&gt;Right等方式进行调用，利于理解。</p><h5 id="树的构建："><a href="#树的构建：" class="headerlink" title="树的构建："></a>树的构建：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">binTree <span class="hljs-title function_">creatBintree</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a;<br>binTree b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == a)<span class="hljs-comment">//如果输入0，则停止创建</span><br>b = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>b = (binTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binNode));<br>b-&gt;element = a;<br>b-&gt;leftChild = creatBintree();<br>b-&gt;rightChild = creatBintree();<br><br>&#125;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>当我们构建起了一个树后我们怎么对树进行遍历读取呢？可以用前、中、后序遍历，打比方我们用前序遍历就是通过（根、左、右）对树进行读取，也就是首先将最上面的节点作为root，然后将所有左边和右边的节点看作孩子，然后再将此时左孩子最上面的节点作为root进一步（根、左、右）读取，以此类推进行遍历。我们可以用<em>递归</em>的方式来实现代码。</p><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data); <span class="hljs-comment">//输出结果</span><br>    &#125;<br>    PreorderPrintLeaves(BT-&gt;Left);<br>    PreorderPrintLeaves(BT-&gt;Right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    PreorderPrintLeaves(BT-&gt;Left);<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data);<br>    &#125;    <br>    PreorderPrintLeaves(BT-&gt;Right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    PreorderPrintLeaves(BT-&gt;Left);  <br>    PreorderPrintLeaves(BT-&gt;Right);<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="节点的计算"><a href="#节点的计算" class="headerlink" title="节点的计算"></a>节点的计算</h4><p>节点的计算需要通过左右子树的孩子判断来对其进行加法运算，我们可以用T-&gt;lchild!&#x3D;NULL来表示没有左孩子，同理可以右孩子也是T-&gt;rchild!&#x3D;NULL，这样就可以区分度为1、2或叶子节点。</p><h5 id="计算节点数"><a href="#计算节点数" class="headerlink" title="计算节点数"></a>计算节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>; <span class="hljs-comment">//全部一次性+1</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算度为1的节点数"><a href="#计算度为1的节点数" class="headerlink" title="计算度为1的节点数"></a>计算度为1的节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(( T-&gt;lchild!=<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="hljs-literal">NULL</span>) || ( T-&gt;lchild==<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild!=<span class="hljs-literal">NULL</span>))<br>        <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>; <span class="hljs-comment">//这里次数+1</span><br>    <span class="hljs-keyword">return</span> NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); <span class="hljs-comment">//直接return，次数不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算度为2的节点数"><a href="#计算度为2的节点数" class="headerlink" title="计算度为2的节点数"></a>计算度为2的节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>( T-&gt;lchild!=<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);<br>    <span class="hljs-keyword">return</span> NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算叶子节点个数"><a href="#计算叶子节点个数" class="headerlink" title="计算叶子节点个数"></a>计算叶子节点个数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LeafCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild==<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树高计算"><a href="#树高计算" class="headerlink" title="树高计算"></a>树高计算</h4><p>我们可以定义两个整型m，n分别来表示左右两边的树高度，用递归的方式实现向下计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetHeight</span><span class="hljs-params">( BinTree BT )</span>&#123;<br>     <span class="hljs-type">int</span> m, n;<br>     <span class="hljs-keyword">if</span> (BT == <span class="hljs-literal">NULL</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">else</span>&#123;<br>         m = GetHeight(BT-&gt;Left);<br>         n = GetHeight(BT-&gt;Right);<br>         <span class="hljs-keyword">if</span> (m &gt; n)<br>             <span class="hljs-keyword">return</span> (m + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>             <span class="hljs-keyword">return</span> (n + <span class="hljs-number">1</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法-用Dijkstra和Prim求最小路径</title>
    <link href="/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="图算法-用Dijkstra和Prim求最小路径"><a href="#图算法-用Dijkstra和Prim求最小路径" class="headerlink" title="图算法-用Dijkstra和Prim求最小路径"></a>图算法-用Dijkstra和Prim求最小路径</h3><h4 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h4><p>在一个树中有多个节点和多条有向或无向的边，若我们给各个边附上权值，那么利用这两个算法可以计算从一个节点到所有节点的最小距离。实际中可以解决比如快递在区域配送最短的路径等问题。</p><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>例如以第1个节点为树根并循环整个树的节点，找到与1连接的所有点然后比较到这个点的距离是否小于原点(节点1)到这个点的距离(此时还没有)，若此时的距离比另一条路到这个点的距离小，则存入数据，以此类推。</p><h5 id="具体如下："><a href="#具体如下：" class="headerlink" title="具体如下："></a>具体如下：</h5><p>我们用dist数组来存入原点到所有点的最小距离，最开始的时候设置所有的点到原点的距离为无穷大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//原点到原点的距离为0</span><br></code></pre></td></tr></table></figure><p>用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。</p><p>首先用for遍历每个点，寻找到每一个点的到原点的距离。</p><p>再在用一个for来确定这个点是到原点的最短距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t</span><br>        <span class="hljs-keyword">if</span>(!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))t = j;<br>    &#125;<br>    state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i]置为1。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])&#123;<span class="hljs-comment">//遍历t所有可以到达的节点i</span><br>        <span class="hljs-type">int</span> i = e[j];<br>        dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新dist[j]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<span class="hljs-comment">//dist数组的各个元素为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//源点到源点的距离为置为 0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t</span><br>            <span class="hljs-keyword">if</span>(!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))t = j;<br>        &#125;<br>        state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i]置为1。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])&#123;<span class="hljs-comment">//遍历t所有可以到达的节点i</span><br>            <span class="hljs-type">int</span> i = e[j];<br>            dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新dist[j]</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。prim算法相比于dijkstra是贪心的，它要寻找的是每一个点之间的最短距离。</p><h5 id="具体如下"><a href="#具体如下" class="headerlink" title="具体如下"></a>具体如下</h5><p>与Dijkstra一样用dist存入距离，并最开始用无穷大赋值。</p><p>用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。</p><p>用pre数组来保存节点是和谁连通的。</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dist[n],state[n],pre[n];<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i : <span class="hljs-number">1</span> ~ n)<br>&#123;<br>    t &lt;- 没有连通起来，但是距离连通部分最近的点;<br>    state[t] = <span class="hljs-number">1</span>;<br>    更新 dist 和 pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在prim里面相当于是将树的每个点一个一个加入到一个集合中，这个集合就是生成的树。每次选择树都要看看是否在树中并且到树的距离最短，如果是则加入到集合中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dt,<span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dt));<span class="hljs-comment">//初始化距离数组为一个很大的数（10亿左右）</span><br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    dt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//从 1 号节点开始生成 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//每次循环选出一个点加入到生成树</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//每个节点一次判断</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dt[j] &lt; dt[t]))<span class="hljs-comment">//如果没有在树中，且到树的距离最短，则选择该点</span><br>                t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dt[t] == <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 选择该点</span><br>        res += dt[t];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">//更新生成树外的点到生成树的距离</span><br>            <span class="hljs-keyword">if</span>(dt[i] &gt; g[t][i] &amp;&amp; !st[i])&#123;<span class="hljs-comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span><br>                dt[i] = g[t][i];<span class="hljs-comment">//更新距离</span><br>                pre[i] = t;<span class="hljs-comment">//从 t 到 i 的距离更短，i 的前驱变为 t.</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地已经后端部署，前端response返回“Method Post not allowed”问题</title>
    <link href="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这次是在做前端的时候，前后端联调发生的问题。接口名前后都对的上然而显示“Post方法不被允许”：</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/82c4ccc79f7bcddc7c82641131305f5.png" alt="response返回的值"></p><p>第一反应是去看自定义端口最后的url是不是少一个“&#x2F;”：</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234225465.png" alt="自定义接口处"></p><p>发现并没有少。</p><p>最后经过排查发现前后端地址没有对上。前端地址没有连接本地的地址。</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234403334.png" alt="后端地址设置处"></p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234428092.png" alt="前端地址设置处"></p><p>修改target的请求地址为”<a href="http://127.0.0.1:3381“，成功解决。">http://127.0.0.1:3381“，成功解决。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise链式调用与async函数解决回调地狱问题</title>
    <link href="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在平时我们使用vue的时候经常会看到在请求接口的时候总是会有async与await：</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502211951935.png" alt="JS请求接口示例"></p><p>这是为什么呢？不能直接请求接口吗？</p><p>这里其实是为了避免出现<em>回调地狱</em>的问题。要理解清楚这个问题不妨从promise的链式调用开始讲起。</p><h4 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h4><p>概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调地狱。</p><p>我们知道一个axios函数中包含一些url等请求参数和一个.then的回调函数，由于其异步性，一个接口的请求需要等到回调函数成功调回才算结束。于是要是我们在.then里面在嵌入一个axios函数的话就需要等到上一层请求后再进入这层，再由这层回调到上层。代码量一多，不仅可读性差而且异常无法捕获，耦合性严重，牵一发动全身。比如看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city!&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>    &#125;)        <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我在第二个url中最后加了一个“!”让其错误，并让<a href="https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5">catch</a>寻找错误的地方。然而我们发现：</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502220418999.png" alt="catch无法捕获"></p><p>其错误直接来源于axios的源码处，而且显示Uncaught (in promise)，这就是回调地狱最直接的一个弊端处。</p><p>好了这里又涉及到一个词叫promise。</p><h4 id="何为Promise？"><a href="#何为Promise？" class="headerlink" title="何为Promise？"></a>何为Promise？</h4><p>mdn的解释是：“Promise是一个对象，它代表了一个异步操作的最终完成或者失败。”所以说Promise就是一个函数返回的对象，不然每次做回调操作都要自己手动传一个回调函数进去。</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/71edb8bc-87b4-4098-9e67-950ad55bb773.jpg" alt="promise工作原理"></p><p>解释：依靠then()方法回返回一个新生成的Promise对象特性，继续串联下一环任务，直到结束。而then()回调函数中的返回值会影响新生成的Promise对象最终状态和结果。这样通过链式调用，可以有效解决回调函数嵌套问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//设置时间模拟ajax请求</span><br>        <span class="hljs-title function_">reslove</span>(<span class="hljs-string">&#x27;北京市&#x27;</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//北京</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 === p); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>可以看到我们创建了一个新的promise对象并赋值给p，然后再用p触发回调函数，并生成了一个全新的promise对象并赋值给p2。</p><p>在最后一行的log中，使用了三等判断进行比较，我们知道三等判断，判断的是两个变量保存的内存地址，最后其返回了false更可以说明生成的是一个全新的promise对象。</p><p>所以知道了promise的工作原理，我们就可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city!&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>    &#125;)        <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>没错，就是在第二个axios前面多了一个return，就可以捕获到第二层的错误了。</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502225923733.png" alt="成功捕获error"></p><h4 id="async函数和await"><a href="#async函数和await" class="headerlink" title="async函数和await"></a>async函数和await</h4><p>我们现在知道了promise可以解决回调地狱，但是这还是在回调函数里面不断嵌套，可读性极差，这时async函数(意思为“异步”)的引入就极大的改善了这个问题。</p><p><em>定义：async函数是使用async关机字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键词。async和await关键词让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。</em></p><p>因此我们只需要这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> pObj = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;)<br>    <span class="hljs-keyword">const</span> pname = pObj.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-keyword">const</span> cObj = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;)<br>    <span class="hljs-keyword">const</span> cname = cObj.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>&#125;<br><span class="hljs-title function_">getData</span>() <span class="hljs-comment">//别忘了调用函数</span><br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pname = []<br><span class="hljs-keyword">let</span> cname = []<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    &#125;)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>    &#125;)        <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>&#125;<br><span class="hljs-title function_">getData</span>()<br></code></pre></td></tr></table></figure><p>注意上面第二个代码中pname和cname没有用const定义，是因为当我在外面用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pname = []<br><span class="hljs-keyword">const</span> cname = []<br></code></pre></td></tr></table></figure><p>定义时发现报出错误：Assignment to constant variable（把常量赋值给了变量）</p><p>这是因为我们使用 const 定义了变量且存在初始值。 后面又给这个变量赋值，所以报错了。ES6 标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域：使用 const 定义的常量，不能修改它的值，且定义的常量必须赋初值；let 定义的是变量，可以进行变量赋值操作，且不需要赋初值。这个错误就是因为我们修改了常量而引起的错误，虽然某些浏览器不报错，但是无效果！所以解决方法就是前面加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pname = []<br><span class="hljs-keyword">let</span> cname = []<br></code></pre></td></tr></table></figure><p>成功解决问题。</p><p>– 这里debug的时候发现const和let这块还有点含糊，const似乎最好是赋值一个对象或数组，再对对象进行赋值。等我哪天彻底搞明白了后单独出一期讲讲_(:3 ⌒ﾞ)__</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-ES6箭头函数使用细则</title>
    <link href="/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>我们知道在ES6之前使用函数要使用function：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">形参</span>) &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>然而在function中this指向的对象不够清晰明确，以及其表达不够简洁，于是引入的箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(形参) =&gt; &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>由于其重要性，以及在vue中的大量使用，我将着重讨论下<em>箭头函数的使用方法</em>，<em>函数参数</em>和<em>this指向问题</em>。</p><h3 id="使用方法以及简写条件"><a href="#使用方法以及简写条件" class="headerlink" title="使用方法以及简写条件"></a>使用方法以及简写条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//function写法</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//箭头写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当传入只有一个形参时，小括号可以省略:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+x)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>当函数体只有一行时可以省略大括号:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+x)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//4</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x,y</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+y)<br><span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//3</span><br><br><span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>)<br>form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.<span class="hljs-title function_">preventDefault</span>()) <span class="hljs-comment">//形参小括号和函数体大括号都省略</span><br><span class="hljs-comment">//阻止表单默认提交时事件</span><br></code></pre></td></tr></table></figure><p>箭头函数可以直接返回一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">uname</span>) =&gt; (&#123; <span class="hljs-attr">uname</span>: uname &#125;) <span class="hljs-comment">// 属性: 值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">uname</span>) =&gt; (&#123; uname &#125;) <span class="hljs-comment">//属性和值的名字一样的时候也可以简写</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;ye&#x27;</span>) <span class="hljs-comment">//&#123;uname: &#x27;ye&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>这里不用大括号包着是因为对象的大括号和其冲突了，所以用小括号代替了。</p><h3 id="箭头函数没有arguments动态参数"><a href="#箭头函数没有arguments动态参数" class="headerlink" title="箭头函数没有arguments动态参数"></a>箭头函数没有arguments动态参数</h3><p>箭头函数里面只有<em>剩余参数…arr</em>,所以只能用剩余参数来传入数组进行计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSum</span> = (<span class="hljs-params">...arr</span>) =&gt; &#123;<br><span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>sum +=arr[i]<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>那么何为动态参数，何为剩余参数呢？</p><h4 id="arguments动态参数"><a href="#arguments动态参数" class="headerlink" title="arguments动态参数"></a>arguments动态参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>) <span class="hljs-comment">//[2,3,4]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++)&#123;<br>sum +=<span class="hljs-variable language_">arguments</span>[i]<br>&#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>arguments动态参数只存在于function函数里面，其是个伪数组，在函数里充当傀儡。</p><h4 id="函数剩余参数"><a href="#函数剩余参数" class="headerlink" title="函数剩余参数"></a>函数剩余参数</h4><p>剩余参数没有的固定名字，这里以arr为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">a,b,...arr</span>) &#123; <span class="hljs-comment">//这里arr是名字，可以自定义</span><br>    <span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">//[4,5]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        sum += arr[i]<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>可以看到剩余参数顾名思义就是取剩下没有对号入座的参数。a&#x3D;2,b&#x3D;3,那么剩下的就由arr接收。注意前面的三个点是<em>展开运算符</em>，它可以让这几个数字组合成一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn = <span class="hljs-function">(<span class="hljs-params">...arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//[1,2,3]</span><br></code></pre></td></tr></table></figure><p>没有展开运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数this问题"><a href="#箭头函数this问题" class="headerlink" title="箭头函数this问题"></a>箭头函数this问题</h3><p>我们知道this是指向的是环境对象，比如我们输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//&#123;number: &#x27;1&#x27;, hello: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们定义了一个obj对象然后里面放了一个number和一个hello函数，当我们用obj调用hello函数时，this就指向了obj。那么我们就可以初次判断出谁调用的这个函数，this就指向谁。是不是这样呢？我们可以就单纯输入下面这行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>我们发现返回的是window，而我们知道window是作用域链的链头。因为我们清楚其实我们每次调用函数都应该要在前面加上window作为调用的对象，但是这样极其的重复与单调故将其省去了。这样也就说明了this确实是指向其调用的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>() <span class="hljs-comment">//window</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>() <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>回到这个论题，我们可以发现每一个新函数都要根据它是被如何调用的来定义这个函数的this值，非常让人讨厌。因此在箭头函数中，箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。</p><p>当我们再输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//Window</span><br></code></pre></td></tr></table></figure><p>hello的上一级时obj，而调用obj的对象是window，所以输出window。</p><p>再比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">count</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;<br>        <span class="hljs-title function_">count</span>()<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//&#123;number: &#x27;1&#x27;, hello: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>count函数的上一层是hello，而调用hello的是obj对象，所以输出obj。</p><p>然而在实际开发中，事件回调函数使用箭头函数时，this为全局的window。因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListner</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">//this指向btn</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX-axios库使用与http协议</title>
    <link href="/2024/04/26/axios/"/>
    <url>/2024/04/26/axios/</url>
    
    <content type="html"><![CDATA[<h3 id="AJAX-axios库使用与http协议"><a href="#AJAX-axios库使用与http协议" class="headerlink" title="AJAX-axios库使用与http协议"></a>AJAX-axios库使用与http协议</h3><p>当我们需要将前后端数据进行传递时，我们可以运用AJAX技术。AJAX也就是异步的JavaScript和XML(Asynchronous JavaScript And XML)。简单的说，就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON,XML,HTML和text文本等格式发送和接收数据。</p><h4 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h4><p><img src="/2024/04/26/axios/ajax.gif" alt="ajax工作原理"></p><ol><li>网页中发生一个事件（页面加载、按钮点击）</li><li>由 JavaScript 创建 XMLHttpRequest 对象</li><li>XMLHttpRequest 对象向 web 服务器发送请求</li><li>服务器处理该请求</li><li>服务器将响应发送回网页</li><li>由 JavaScript 读取响应</li><li>由 JavaScript 执行正确的动作（比如更新页面）</li></ol><h4 id="axios使用"><a href="#axios使用" class="headerlink" title="axios使用"></a>axios使用</h4><p>axios是基于Promise的HTTP客户端作用于浏览器和node.js，属于网络请求库。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>引入axios.js的两种方法：</p><p>使用 jsDelivr CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 unpkg CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>函数基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;目标地址&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//后端返回数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="axios-查询参数"><a href="#axios-查询参数" class="headerlink" title="axios-查询参数"></a>axios-查询参数</h5><p>使用axios提供的params选项(param是“参数”的意思)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">params</span>:&#123;<br>参数名:值<br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//返回值</span><br>    <span class="hljs-comment">//console.log(result)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://hmajax.itheima.net/api/city&#x27;</span>,<br>    <span class="hljs-attr">params</span>:&#123;<br>        <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;河北省&#x27;</span><br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/axios/image-20240426231418816.png" alt="返回的json格式文件"></p><p>查询完的数据就可以在Response里找到result值，一般情况是返回一个message和一个res，其返回的数据是个json文件。</p><h5 id="axios-请求配置"><a href="#axios-请求配置" class="headerlink" title="axios-请求配置"></a>axios-请求配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;请求方法&#x27;</span>,<br><span class="hljs-attr">data</span>:&#123;<br>参数名:值<br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//返回值</span><br>    <span class="hljs-comment">//console.log(result)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>axios将data对象的数据通过上述方式传入后端，后端就会根据其传入的关键词获得对应的res并在then后面得到。</p><h5 id="axios-错误处理"><a href="#axios-错误处理" class="headerlink" title="axios-错误处理"></a>axios-错误处理</h5><p>在then方法的后面，通过点语法调用catch方法，传入回调函数并定义形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-comment">//请求选项</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br><span class="hljs-comment">//处理数据</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-comment">//处理错误</span><br>    <span class="hljs-comment">//console.log(error)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>该方法可以捕捉到错误数据，并将数据传入error形参中，于是就可以将错误数据解析并返回客户端中显示。（其实error可以用console.log在控制台查看，但是catch可以将数据传入并可解析）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>) <span class="hljs-comment">//一般情况下可以通过这样解析json文件并弹出问题</span><br></code></pre></td></tr></table></figure><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h5><p>http协议规定了浏览器发送及服务器返回内容的格式，也就是如果你传入data对象，报文会将其转化为一个json文件打包传给后端，然后后端再传入对应的json文件。</p><p>如下图就是一个请求报文(也就是请求头)：</p><p><img src="/2024/04/26/axios/image-20240426232117702.png" alt="Request Headers"></p><p>Accept中可以看到返回的是个json文件，Host是域名，User-Agent是用来模仿用户登录。</p><h5 id="Resonpse-Headers"><a href="#Resonpse-Headers" class="headerlink" title="Resonpse Headers"></a>Resonpse Headers</h5><p>当我们后端受到前端的request headers后就会相应的传入response headers，这个headers包括：响应行，响应头，空行，响应体。响应体就包含了我们需要的json文件，浏览器会将该文件通过js渲染，显示于页面中。在文件传输的时候可能会有前后传递出错的时候，这时候就需要状态码来告知错误信息。</p><p>状态码有如下几种：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集其实解决的内容就是类似于集合合并的问题，然而如果用普通的数组去储存一个集合若数据量大，不仅调用时占用内存空间大，而且不便于插入或查询操作，因此引入并查集可以很好的解决这点。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>1.将两个集合合并</p><p>2.询问两个元素是否再一个集合当中</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>理解这个问题就需要把集合给看成一个树，然后这个树的树根就代表这个集合。当想询问其中一个节点时，我们只要访问这个节点father，然后再找这个father的grandfather直到到树根，就能确定这个点的树根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p[x]表示x的父节点</span><br><span class="hljs-keyword">if</span>(p[x]==x) <span class="hljs-comment">//判断树根</span><br><span class="hljs-keyword">while</span>(p[x]!=x) x=p[x] <span class="hljs-comment">//求x的集合编号</span><br></code></pre></td></tr></table></figure><h4 id="合并两个集合"><a href="#合并两个集合" class="headerlink" title="合并两个集合"></a>合并两个集合</h4><p>合并集合只需要将其中一个集合的树根的编号改成另一个集合的根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[x]=y<span class="hljs-comment">//px是x的集合编号，py是y的集合编号</span><br></code></pre></td></tr></table></figure><p>(俗称：给x的祖宗又认了一个爹)</p><p><img src="/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/find%E5%87%BD%E6%95%B0.png" alt="find函数"></p><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>当你找到这个节点的根节点时，就把这些节点的父亲全部变成根节点的编号，也就是让这些节点全部指向根节点。当实现了这个操作后，其查询操作直接将时间复杂度变成O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//寻找根+路径压缩</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1-合并集合"><a href="#1-合并集合" class="headerlink" title="1.合并集合"></a>1.合并集合</h4><p>一共有 n𝑛 个数，编号是 1∼n1∼𝑛，最开始每个数各自在一个集合中。</p><p>现在要进行 m𝑚 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a𝑎 和 b𝑏 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a𝑎 和 b𝑏 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n𝑛 和 m𝑚。</p><p>接下来 m𝑚 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a𝑎 和 b𝑏 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1051≤𝑛,𝑚≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br><span class="hljs-keyword">Yes</span><br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//核心函数，find(x)最终返回值就是x的根节点编号</span><br>    <span class="hljs-keyword">if</span>(x!=p[x]) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-type">int</span> n,m,a,b;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>        p[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;M&quot;</span>)&#123;<br>            p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//让a根节点的父亲变成b节点的根节点</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;Q&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))&#123; <span class="hljs-comment">//判断两个数是不是属于同一个集合，其实就是两个根编号是不是一样</span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-合并根"><a href="#2-合并根" class="headerlink" title="2.合并根"></a>2.合并根</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>w 星球的一个种植园，被分成 m<em>×</em>n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。</p><p>这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。</p><p>如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行，两个整数 <em>m</em>，<em>n</em>，用空格分开，表示格子的行数、列数（1&lt;<em>m</em>,<em>n</em>&lt;1000）。</p><p>接下来一行，一个整数 k，表示下面还有 <em>k</em> 行数据(0&lt;<em>k</em>&lt;1e5)。</p><p>接下来 <em>k</em> 行，每行两个整数 a<em>，</em>b<em>，表示编号为 a</em> 的小格子和编号为 b 的小格子合根了。</p><p>格子的编号一行一行，从上到下，从左到右编号。</p><p>比如：5×4 的小格子，编号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1  2  3  4<br>5  6  7  8<br>9  10 11 12<br>13 14 15 16<br>17 18 19 20<br></code></pre></td></tr></table></figure><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>一行一个整数，表示答案</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">5 4<br>16<br>2 3<br>1 5<br>5 9<br>4 8<br>7 8<br>9 10<br>10 11<br>11 12<br>10 14<br>12 16<br>14 18<br>17 18<br>15 19<br>19 20<br>9 13<br>13 17<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">1000005</span>],vis[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//寻找根</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,k,a,b,sum=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++) p[i]=i;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//合并集合</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++)&#123;<br>        <span class="hljs-comment">// cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-keyword">if</span>(i==p[i])sum++;<br>    &#125;<br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题使用并查集解题，核心主要两个步骤：寻找该元素的根、合并两个集合</p><p>然后最后判断是用if(i&#x3D;&#x3D;p[i])来判断这里的根有几个，因为我们知道只有p[x]&#x3D;&#x3D;x时，才是这个树的根(因为在数组上理解就是所有的数字比如：[-1，1，2，3，4] —&gt; [ -1，4，2，1，3]，我们可以发现数组的顺序表示数字，而对应上面的数字就是其根的索引，在并查集的操作下只有根节点是i&#x3D;&#x3D;p[i]，因此我们也可以将其作为判断几个集合的依据)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础数据结构之栈、队列、链表</title>
    <link href="/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="c-基础数据结构之栈、队列、链表"><a href="#c-基础数据结构之栈、队列、链表" class="headerlink" title="c++基础数据结构之栈、队列、链表"></a>c++基础数据结构之栈、队列、链表</h2><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q <span class="hljs-comment">//queue&lt;定义类型&gt;定义名称</span><br>q.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//出队</span><br>q.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//入队</span><br>q.<span class="hljs-built_in">front</span>()<span class="hljs-comment">//队首</span><br>q.<span class="hljs-built_in">rear</span>()<span class="hljs-comment">//队尾</span><br>q.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//队长(队长可以为0)</span><br>q.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//是否为空队(若是则返回1)</span><br></code></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt;st<br>st.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//出栈</span><br>st.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//入栈</span><br>st.<span class="hljs-built_in">top</span>()<span class="hljs-comment">//栈顶</span><br>st.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//栈长</span><br>st.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//判断是否为空栈</span><br></code></pre></td></tr></table></figure><h3 id="1-单链表-注意结构体写法"><a href="#1-单链表-注意结构体写法" class="headerlink" title="1.单链表(注意结构体写法)"></a>1.单链表(注意结构体写法)</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现一个单链表，链表初始为空，支持三种操作： </p><p>(1) 向链表头插入一个数；</p><p>(2) 删除第k个插入的数后面的数；</p><p>(3) 在第k个插入的数后插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 </p><p><a href="https://www.ixigua.com/7241418740699824643">https://www.ixigua.com/7241418740699824643</a></p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数M，表示操作次数。 </p><p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种： </p><p>(1) “H x”，表示向链表头插入一个数x。 </p><p>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 </p><p>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 </p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。 </p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。 </p><h4 id="输入样例-复制"><a href="#输入样例-复制" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制"><a href="#输出样例-复制" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6 4 6 5<br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> num; <span class="hljs-comment">//节点值</span><br>    <span class="hljs-type">int</span> time; <span class="hljs-comment">//第几次插入</span><br>    node* next; <span class="hljs-comment">//定义下一个节点的位置</span><br>&#125;;<br>node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<span class="hljs-comment">//创建一个新节点叫head</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">headin</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    node* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<span class="hljs-comment">//创建一个新节点</span><br>    p-&gt;num=n;<span class="hljs-comment">//把值输入节点中</span><br>    p-&gt;time=i;<span class="hljs-comment">//这是次数</span><br><br>    <span class="hljs-comment">//下面就是插入模板操作</span><br>    p-&gt;next=head-&gt;next;<br>    head-&gt;next=p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">de</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;<br>    node* p, * q;<span class="hljs-comment">//定义两个节点</span><br>    p=head-&gt;next;<span class="hljs-comment">//p为指向head的下一个节点</span><br>    <span class="hljs-keyword">if</span>(!t)&#123;<br>        head-&gt;next=p-&gt;next;<span class="hljs-comment">//head指的是头，里面没值，所以实际的链表头是p</span><br>        <span class="hljs-built_in">delete</span>(p);<span class="hljs-comment">//p是实际头节点</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(p)&#123;<span class="hljs-comment">//找到第t次插入的数</span><br>            <span class="hljs-keyword">if</span>(p-&gt;time==t)<span class="hljs-keyword">break</span>;<br>            p=p-&gt;next;<br>        &#125;<br>        q=p-&gt;next;<span class="hljs-comment">//让q在p的前面，辅助删除p后面的节点</span><br>        p-&gt;next=q-&gt;next;<br>        <span class="hljs-built_in">delete</span>(q);<span class="hljs-comment">//删除q</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    node* p=head-&gt;next; <span class="hljs-comment">//让p指针指向head的下一个，然后用p节点找欲插入的值</span><br>    <span class="hljs-comment">//下面三行是创建新节点然后给其赋值的操作</span><br>    node* q=<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>    q-&gt;num=n;<br>    q-&gt;time=i;<br>    <span class="hljs-comment">//从链表头开始找</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;time == t)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找第t次插入的数</span><br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//把q节点插到第t次插入的数后面</span><br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//开始时链表没有值</span><br>    <span class="hljs-type">int</span> m,i,x,k;<br>    <span class="hljs-type">char</span> op;<br>    i=<span class="hljs-number">1</span>;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">headin</span>(x,i);<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">de</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(k,x,i);<br>            i++;<span class="hljs-comment">//因为题目是记录第几次插入的数，所以要用i计数</span><br>        &#125;            <br>    &#125;<br>    node* p = head-&gt;next;<span class="hljs-comment">//让p指向实际头节点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        cout&lt;&lt; p-&gt;num &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        p=p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-简单计算器"><a href="#2-简单计算器" class="headerlink" title="2.简单计算器"></a>2.简单计算器</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。</p><p><a href="https://www.ixigua.com/7213692123635024436">https://www.ixigua.com/7213692123635024436</a></p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。</p><p>100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p><h4 id="输入样例-复制-1"><a href="#输入样例-复制-1" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4 + 2 * 5 - 7 / 11<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制-1"><a href="#输出样例-复制-1" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">13.36<br></code></pre></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">double</span>&gt;d_st;<br>stack&lt;<span class="hljs-type">char</span>&gt;op_st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">level</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;+&#x27;</span>||a==<span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;*&#x27;</span>||a==<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> c=op_st.<span class="hljs-built_in">top</span>();op_st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">double</span> a,b;<br>    a=d_st.<span class="hljs-built_in">top</span>();<br>    d_st.<span class="hljs-built_in">pop</span>();<br>    b=d_st.<span class="hljs-built_in">top</span>();<br>    d_st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;+&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b+a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b-a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;*&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b*a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;/&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b/a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-built_in">getline</span>(cin,str);<br>    <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(str[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-comment">//如果是数字</span><br>            x=str[i]-<span class="hljs-string">&#x27;0&#x27;</span>; <br>            <span class="hljs-keyword">while</span>(str[i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                x=x*<span class="hljs-number">10</span>+str[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            d_st.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//把字符串数字转化为整型并推入栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span> || str[i]==<span class="hljs-string">&#x27;-&#x27;</span> || str[i]==<span class="hljs-string">&#x27;*&#x27;</span> || str[i]==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(op_st.<span class="hljs-built_in">empty</span>()||<span class="hljs-built_in">level</span>(str[i])&gt;<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<span class="hljs-comment">//只有优先级高于栈顶的情况才能入栈</span><br>                op_st.<span class="hljs-built_in">push</span>(str[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!op_st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">level</span>(str[i])&lt;=<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<br>                <span class="hljs-keyword">while</span>(!op_st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">level</span>(str[i])&lt;=<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<span class="hljs-comment">//拿栈顶前两个计算</span><br>                    <span class="hljs-built_in">cal</span>();<br>                &#125;<br>                op_st.<span class="hljs-built_in">push</span>(str[i]);           <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!op_st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-built_in">cal</span>();<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>,d_st.<span class="hljs-built_in">top</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-约瑟夫环-队列解法"><a href="#3-约瑟夫环-队列解法" class="headerlink" title="3.约瑟夫环(队列解法)"></a>3.约瑟夫环(队列解法)</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>n和m。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4 17<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1 3 4 2<br></code></pre></td></tr></table></figure><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;qe;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        qe.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!qe.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br>            x=qe.<span class="hljs-built_in">front</span>();<br>            qe.<span class="hljs-built_in">pop</span>();qe.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//把队头放到对尾</span><br>        &#125;<br>        x=qe.<span class="hljs-built_in">front</span>();qe.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//数到的数彻底出队</span><br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-走出迷宫-bfs"><a href="#4-走出迷宫-bfs" class="headerlink" title="4.走出迷宫(bfs)"></a>4.走出迷宫(bfs)</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。</p><p>假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。</p><p>视频讲解：<a href="https://www.ixigua.com/7166253132702450212">https://www.ixigua.com/7166253132702450212</a></p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。</p><p>接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出从起点到出口最少需要走的步数。</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">3 3<br>S#T<br>.#.<br>...<br></code></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> a[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> r,c;<br>    <span class="hljs-type">int</span> step;<br>&#125;;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sr,<span class="hljs-type">int</span> sc,<span class="hljs-type">int</span> er,<span class="hljs-type">int</span> ec)</span></span>&#123;<br>    queue&lt;node&gt;qe;<span class="hljs-comment">//注意定义方式</span><br>    node q,t;<span class="hljs-comment">//t用来记录q的一圈4个方向</span><br>    q.r=sr,q.c=sc;<br>    q.step=<span class="hljs-number">0</span>;<br>    qe.<span class="hljs-built_in">push</span>(q);<br>    vis[q.r][q.c]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!qe.<span class="hljs-built_in">empty</span>())&#123;<br>        q=qe.<span class="hljs-built_in">front</span>();<br>        qe.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(q.r==er &amp;&amp; q.c==ec)&#123;<br>            cout&lt;&lt;q.step;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            t.r=q.r+dir[i][<span class="hljs-number">0</span>];<br>            t.c=q.c+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(a[t.r][t.c]==<span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; vis[t.r][t.c]==<span class="hljs-number">0</span> &amp;&amp; t.r&gt;=<span class="hljs-number">1</span>&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=<span class="hljs-number">1</span>&amp;&amp;t.c&lt;=n)&#123;<br>                t.step=q.step+<span class="hljs-number">1</span>;<br>                vis[t.r][t.c]=<span class="hljs-number">1</span>;<br>                qe.<span class="hljs-built_in">push</span>(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> sr,sc,er,ec;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>        cin&gt;&gt;a[i][j];<br>        <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)sr=i,sc=j;<br>        <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;T&#x27;</span>)er=i,ec=j,a[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>(sr,sc,er,ec);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-出入栈判断"><a href="#5-出入栈判断" class="headerlink" title="5.出入栈判断"></a>5.出入栈判断</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入第一行表示一个整数n, n&lt;&#x3D;100</p><p>接下来输入n行，每行表示一个a~z的排列。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。</p><h4 id="输入样例-复制-2"><a href="#输入样例-复制-2" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>abcdefghijklmnopqrstuvwxyz<br>zabcdefghijklmnopqrstuvwxy<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制-2"><a href="#输出样例-复制-2" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">yes<br>no<br></code></pre></td></tr></table></figure><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>5<br>abcdegfhijklnmopqrstuvwxyz<br>abcdegfhijklnmopqrstzyxwvu<br>dcbaegfhijklnmopqrstuvwxyz<br>abcdegfhijkwxyzlnmopqrstuv<br>abcdegfhijklnmouvwxyztsrqp</p><p>yes<br>yes<br>yes<br>no<br>yes</p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack &lt;<span class="hljs-type">char</span>&gt; st;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>(),j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> ch=i+<span class="hljs-string">&#x27;a&#x27;</span>;<br>            st.<span class="hljs-built_in">push</span>(ch);<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>()==s[j])&#123;<br>                st.<span class="hljs-built_in">pop</span>(),j++;<br>            &#125;<br> <br>        &#125;<br>        <span class="hljs-keyword">if</span>(j==len)cout&lt;&lt;<span class="hljs-string">&quot;yes\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;no\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基本语法</title>
    <link href="/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript基础语法介绍"><a href="#JavaScript基础语法介绍" class="headerlink" title="JavaScript基础语法介绍"></a>JavaScript基础语法介绍</h2><h3 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h3><h4 id="1-1-JavaScript是什么"><a href="#1-1-JavaScript是什么" class="headerlink" title="1.1 JavaScript是什么"></a>1.1 JavaScript是什么</h4><p>是一个运行在浏览器上的编程语言。</p><h4 id="1-2JavaScript书写位置"><a href="#1-2JavaScript书写位置" class="headerlink" title="1.2JavaScript书写位置"></a>1.2JavaScript书写位置</h4><p>内部式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)<span class="hljs-comment">//页面弹出警示框</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>外部式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./my.js&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>使用外部时，script标签里面不要写内容，否则会被忽略。</p><h4 id="1-3JavaScript输入输出语法"><a href="#1-3JavaScript输入输出语法" class="headerlink" title="1.3JavaScript输入输出语法"></a>1.3JavaScript输入输出语法</h4><p>输出语法1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>输出语法2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)<span class="hljs-comment">//页面弹出警示框</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出语法3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;haha&#x27;</span>)<span class="hljs-comment">//控制台输出语法，程序员调试使用</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>输入语法1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入&#x27;</span>)<span class="hljs-comment">//弹出一个对话框</span><br></code></pre></td></tr></table></figure><p>prompt输入类型为字符串。</p><h4 id="1-4-字面量"><a href="#1-4-字面量" class="headerlink" title="1.4 字面量"></a>1.4 字面量</h4><p>比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="2-1-变量是什么"><a href="#2-1-变量是什么" class="headerlink" title="2.1 变量是什么"></a>2.1 变量是什么</h4><p>白话：用来装数据的盒子。可以用来存放数据。</p><h4 id="2-2-变量的基本使用"><a href="#2-2-变量的基本使用" class="headerlink" title="2.2 变量的基本使用"></a>2.2 变量的基本使用</h4><p>(与c语言定义类似)</p><h5 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1.声明变量"></a>1.声明变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> variable <span class="hljs-comment">//var存在与老版的JavaScript中</span><br></code></pre></td></tr></table></figure><p>age为变量。</p><h5 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2.变量赋值"></a>2.变量赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">variable = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>variable为变量，18为字面量。</p><p>变量不允许多次定义。</p><p>小小的变量使用一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> n=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(n)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="2-3-变量命名规则与规范"><a href="#2-3-变量命名规则与规范" class="headerlink" title="2.3 变量命名规则与规范"></a>2.3 变量命名规则与规范</h4><h5 id="1-规则"><a href="#1-规则" class="headerlink" title="1. 规则"></a>1. 规则</h5><p>①不能用关键字。</p><p>②只能用下划线、字母、数字、＄组成，且不能用数字开头。</p><p>③字母严格区分大小写。</p><h5 id="2-规范"><a href="#2-规范" class="headerlink" title="2.规范"></a>2.规范</h5><p>①起名要有意义。</p><p>②遵守小驼峰命名法。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-1-声明数组"><a href="#1-1-声明数组" class="headerlink" title="1.1 声明数组"></a>1.1 声明数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h4 id="1-2-数组的基本使用"><a href="#1-2-数组的基本使用" class="headerlink" title="1.2 数组的基本使用"></a>1.2 数组的基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">//索引</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>) <span class="hljs-comment">//获取长度</span><br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> G = <span class="hljs-number">9.8</span><br></code></pre></td></tr></table></figure><p>常量不允许重新赋值，声明的时候必须赋值。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>js为弱数据类型语言，只有赋值了才知道是什么数据类型。</p><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>number 数字型</p><p>string 字符串型</p><p>boolean 布尔型</p><p>undefined 未定义型</p><p>null 空类型</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>object 对象</p><h4 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1.数字类型"></a>1.数字类型</h4><p>数字类型可以由+ - * &#x2F; %各个符号进行运算。</p><p>NaN (not a number)：表示计算错误。</p><p>NaN是粘性的，任何对NaN的操作都会返回NaN。</p><h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h4><p>通过单引号、双引号或反引号包裹的数据都叫字符串。</p><h5 id="字符串拼接："><a href="#字符串拼接：" class="headerlink" title="字符串拼接："></a>字符串拼接：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>+<span class="hljs-string">&#x27;34&#x27;</span>) <span class="hljs-comment">//字符串可以用加号拼接</span><br><span class="hljs-keyword">let</span> a=<span class="hljs-string">&#x27;k&#x27;</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-string">&#x27;q&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k+q)<br></code></pre></td></tr></table></figure><h5 id="模板字符串："><a href="#模板字符串：" class="headerlink" title="模板字符串："></a>模板字符串：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`大家好，我叫<span class="hljs-subst">$&#123;name&#125;</span>,今年<span class="hljs-subst">$&#123;age&#125;</span>岁`</span>) <span class="hljs-comment">//用反引号,变量用＄&#123;&#125;包裹</span><br></code></pre></td></tr></table></figure><h4 id="3-布尔型-bollean"><a href="#3-布尔型-bollean" class="headerlink" title="3.布尔型 (bollean)"></a>3.布尔型 (bollean)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n=<span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br></code></pre></td></tr></table></figure><h4 id="4-未定义类型-undefined"><a href="#4-未定义类型-undefined" class="headerlink" title="4.未定义类型 (undefined)"></a>4.未定义类型 (undefined)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">//输出undefined</span><br></code></pre></td></tr></table></figure><h4 id="5-空类型-null"><a href="#5-空类型-null" class="headerlink" title="5.空类型 (null)"></a>5.空类型 (null)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj=<span class="hljs-literal">null</span> <span class="hljs-comment">//表示赋值了一个空的内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj) <br></code></pre></td></tr></table></figure><p>如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null</p><h4 id="6-检测数据类型"><a href="#6-检测数据类型" class="headerlink" title="6.检测数据类型"></a>6.检测数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> num <span class="hljs-comment">//num为变量</span><br><span class="hljs-title function_">typeof</span>(num)<br></code></pre></td></tr></table></figure><h4 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7.类型转换"></a>7.类型转换</h4><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>+号两边只要有一个是字符串，都会把另外一个转成字符串。</p><p>除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数字&#x27;</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">//返回&#x27;数字1&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">//返回&#x27;11&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>) <span class="hljs-comment">//返回0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">//返回123</span><br></code></pre></td></tr></table></figure><h5 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h5><p>通过函数来进行数据转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>(str) <span class="hljs-comment">//转换为数字类型</span><br><span class="hljs-keyword">let</span> num = +<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入&#x27;</span>) <span class="hljs-comment">//输入的可以转换为数字类型</span><br></code></pre></td></tr></table></figure><p>parse系列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(num) <span class="hljs-comment">//只保留数字且只保留整数</span><br><span class="hljs-built_in">parseFloat</span>(num) <span class="hljs-comment">//保留数字并保留小数</span><br><span class="hljs-built_in">parseInt</span>(12px) <span class="hljs-comment">//12 </span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-number">12.</span>86px) <span class="hljs-comment">//12.86</span><br></code></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><h5 id="前置自增"><a href="#前置自增" class="headerlink" title="前置自增"></a>前置自增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++i + <span class="hljs-number">2</span>) <span class="hljs-comment">//2+2=4</span><br></code></pre></td></tr></table></figure><p>先自加再使用。</p><h5 id="后置自增"><a href="#后置自增" class="headerlink" title="后置自增"></a>后置自增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i++ + <span class="hljs-number">2</span>) <span class="hljs-comment">//1+2=3 此时i已经为2，但是没有参与运算</span><br></code></pre></td></tr></table></figure><p>先使用再自加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i++ + ++i + i) <span class="hljs-comment">//1+3+3=7 第二个i时i为2</span><br></code></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<br>&lt;<br>&gt;=<br>&lt;=<br>== <span class="hljs-comment">//左右两边值是否相等</span><br>===<span class="hljs-comment">//左右两边是否类型和值都相等</span><br>!== <span class="hljs-comment">//左右两边是否不全等</span><br></code></pre></td></tr></table></figure><p>NaN不等于任何人，包括它自己。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (条件) &#123;<br>满足条件执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>条件中只有数字0或者空字符会触发false，其余都是true。</p><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>可以代替if双分支。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">条件 ? 满足条件执行的代码 : 不满足条件执行的代码<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-number">3</span>&lt;<span class="hljs-number">5</span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;真的&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;假的&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span>&lt;<span class="hljs-number">5</span> ? <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;真的&#x27;</span>) : <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;假的&#x27;</span>)<br></code></pre></td></tr></table></figure><p>等价。</p><p>还可以作赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">5</span> <span class="hljs-comment">//sum=3</span><br></code></pre></td></tr></table></figure><h4 id="数字补0例子"><a href="#数字补0例子" class="headerlink" title="数字补0例子"></a>数字补0例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请您输入一个数字&#x27;</span>) <span class="hljs-comment">//类型为string</span><br>num = num &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> + num : num <span class="hljs-comment">//判断小于10才补0</span><br><span class="hljs-title function_">alert</span>(num)<br></code></pre></td></tr></table></figure><p>输入9，输出09</p><p>输入11，输出11</p><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">//[3,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>push() 添加数组末尾</p><p>unshift() 添加数组开头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">//[1,2,3,4]</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[1,2,3,4,5]</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">//[0,1,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>pop() 弹出最后一个元素</p><p>shift() 弹出第一个元素</p><p>splice() 切片删除  &#x2F;&#x2F;arr.plice(起始位置，删除几个)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">//[1,2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">pop</span>()) <span class="hljs-comment">//3</span><br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">//[2,3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">shift</span>) <span class="hljs-comment">//1</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">//[1,3]</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//[1] 删除索引1后面的所有</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//[1]</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">函数名</span>() &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">函数名<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> sayhi&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">sayhi</span>()<br></code></pre></td></tr></table></figure><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">throw</span> expression;<br></code></pre></td></tr></table></figure><p>使用这个语句后就会弹出error：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;not 4&quot;</span>; <span class="hljs-comment">//Uncaught not 4</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try…catch语句"><a href="#try…catch语句" class="headerlink" title="try…catch语句"></a>try…catch语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span>&#123;<br>...<br><br>&#125; <span class="hljs-keyword">catch</span> (error)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>&#125;<br></code></pre></td></tr></table></figure><p>catch块可以用来处理所有try块总产生的异常。</p><h4 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">openMyFile</span>();<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title function_">writeMyFile</span>(theData); <span class="hljs-comment">//This may throw a error</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-title function_">handleError</span>(e); <span class="hljs-comment">// If we got a error we handle it</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-title function_">closeMyFile</span>(); <span class="hljs-comment">// always close the resource</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>finally</code>块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。<code>finally</code>块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，<code>finally</code>块里的语句也会执行。</p><h3 id="循环与迭代"><a href="#循环与迭代" class="headerlink" title="循环与迭代"></a>循环与迭代</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for_%E8%AF%AD%E5%8F%A5">for 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#do...while_%E8%AF%AD%E5%8F%A5">do…while 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#while_%E8%AF%AD%E5%8F%A5">while 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#label_%E8%AF%AD%E5%8F%A5">label 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#break_%E8%AF%AD%E5%8F%A5">break 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_%E8%AF%AD%E5%8F%A5">continue 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_%E8%AF%AD%E5%8F%A5">for…in 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_%E8%AF%AD%E5%8F%A5">for…of 语句</a></li></ul><p>其循环方式与c语言相似，不再一一赘述。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为<em>方法</em>。</p><p>对象及其属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>myCar.<span class="hljs-property">make</span> = <span class="hljs-string">&quot;Ford&quot;</span>;<br>myCar.<span class="hljs-property">model</span> = <span class="hljs-string">&quot;Mustang&quot;</span>;<br>myCar.<span class="hljs-property">year</span> = <span class="hljs-number">1969</span>;<br></code></pre></td></tr></table></figure><p>可以按如下方法访问对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">myCar[<span class="hljs-string">&quot;make&quot;</span>] = <span class="hljs-string">&quot;Ford&quot;</span>;<br>myCar[<span class="hljs-string">&quot;model&quot;</span>] = <span class="hljs-string">&quot;Mustang&quot;</span>;<br>myCar[<span class="hljs-string">&quot;year&quot;</span>] = <span class="hljs-number">1969</span>;<br></code></pre></td></tr></table></figure><h4 id="创建新对象"><a href="#创建新对象" class="headerlink" title="创建新对象"></a>创建新对象</h4><h5 id="使用对象初始化器创建"><a href="#使用对象初始化器创建" class="headerlink" title="使用对象初始化器创建"></a>使用对象初始化器创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">property_1</span>: value_1, <span class="hljs-comment">// property_# 可以是一个标识符...</span><br>  <span class="hljs-number">2</span>: value_2, <span class="hljs-comment">// 或一个数字...</span><br>  [<span class="hljs-string">&quot;property&quot;</span> + <span class="hljs-number">3</span>]: value_3, <span class="hljs-comment">//  或一个可计算的 key 名...</span><br>  <span class="hljs-comment">// ...,</span><br>  <span class="hljs-string">&quot;property n&quot;</span>: value_n,<br>&#125;; <span class="hljs-comment">// 或一个字符串</span><br></code></pre></td></tr></table></figure><h5 id="使用构造函数创建"><a href="#使用构造函数创建" class="headerlink" title="使用构造函数创建"></a>使用构造函数创建</h5><p>用构造函数创建分两种：</p><ol><li>通过创建一个构造函数来定义对象的类型。(建议首字母大写)</li><li>通过 <code>new</code> 创建对象实例。</li></ol><p>这里首先定义一个<em>对象类型</em>，并且赋予其make,model,year属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里是通过this来给对象类型属性值赋值</p><p>然后你就可以创建一个新对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mycar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Eagle&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>);<br></code></pre></td></tr></table></figure><p>或者你也可以让类中加入一个owner：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year, owner</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = owner;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么你就可以这样创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Eagle&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>, rand);<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Nissan&quot;</span>, <span class="hljs-string">&quot;300ZX&quot;</span>, <span class="hljs-number">1992</span>, ken);<br></code></pre></td></tr></table></figure><p>就可以这样索引读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car2.<span class="hljs-property">owner</span>.<span class="hljs-property">name</span>;<br></code></pre></td></tr></table></figure><p>你也可以为之前定义的对象增加新的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car1.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;black&quot;</span>;<br></code></pre></td></tr></table></figure><p>注意这里只是这个car1增加了新属性，不影响其他car1,car3</p><h5 id="使用Object-create方法创建"><a href="#使用Object-create方法创建" class="headerlink" title="使用Object.create方法创建"></a>使用Object.create方法创建</h5><p>及使用Object.create()函数创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Invertebrates&quot;</span>, <span class="hljs-comment">// 属性默认值(无脊椎动物)</span><br>  <span class="hljs-attr">displayType</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类里面可以包含函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>); <span class="hljs-comment">//该函数用来显示type的值</span><br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// 创建一种新的动物——animal1</span><br><span class="hljs-keyword">var</span> animal1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>);<br>animal1.<span class="hljs-title function_">displayType</span>(); <span class="hljs-comment">// 输出:Invertebrates(因为没有没有给type赋值)</span><br><br><span class="hljs-comment">// 创建一种新的动物——Fishes</span><br><span class="hljs-keyword">var</span> fish = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>);<br>fish.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;Fishes&quot;</span>;<br>fish.<span class="hljs-title function_">displayType</span>(); <span class="hljs-comment">// 输出:Fishes</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的将秒换算成-时:分:秒？</title>
    <link href="/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/"/>
    <url>/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="如何优雅的将秒换算成-时-分-秒？"><a href="#如何优雅的将秒换算成-时-分-秒？" class="headerlink" title="如何优雅的将秒换算成-时:分:秒？"></a>如何优雅的将秒换算成-时:分:秒？</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先看一下题目，发现就是一道模拟题，但是又一些细节的。</p><p>首先是数据的规模：时间不超过 10^18,所以需要开 long long。</p><p>然后首先要忽略掉毫秒。</p><p>这里普及一个知识:1<em>s</em> &#x3D; 1000ms</p><p>所以需要忽略后面的三位。直接整除 1000 就可以了。</p><p>之后就是处理时分秒了：</p><h4 id="1-小时"><a href="#1-小时" class="headerlink" title="1.小时"></a>1.小时</h4><p>由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用<code>24*60*60</code>来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数<code>60*60</code>（也就是3600），就是小时值了。</p><h4 id="2-分钟"><a href="#2-分钟" class="headerlink" title="2.分钟"></a>2.分钟</h4><p>分钟要先对每小时的秒数<code>60*60</code>取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。</p><h4 id="3-秒"><a href="#3-秒" class="headerlink" title="3.秒"></a>3.秒</h4><p>直接对60取余，剩下的就是秒了。</p><p>时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。</p><p>当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。</p><p>要用到两个函数：</p><p>一个是<code>setw()</code>函数，这个函数可以限定域宽，宽度就是括号里的数字。</p><p>另外一个<code>setfill()</code>函数，这个函数可以设置当实际的宽度不足<code>setw()</code>函数的值时，用某个字符来补足。（<code>setfill()</code>函数最好放在<code>setw()</code>函数前面）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,h,m,s;<br>    cin&gt;&gt;n;<br>    n=n/<span class="hljs-number">1000</span>;<br>    h=n%(<span class="hljs-number">24</span>*<span class="hljs-number">3600</span>)/<span class="hljs-number">3600</span>;<br>    m=n%<span class="hljs-number">3600</span>/<span class="hljs-number">60</span>;<br>    s=n%<span class="hljs-number">60</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;h&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;m&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css背景</title>
    <link href="/2024/01/20/css-bgc/"/>
    <url>/2024/01/20/css-bgc/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color(bgc)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p>颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制…</p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>background-image(bgi)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;图片的路径&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>①背景图片中url可以省略引号。</p><p>②背景图片默认是在水平和垂直方向平铺的。</p><p>③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。</p><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p>background-repeat(bgr)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-repeat</span>:no-repeat;<br>&#125;<br></code></pre></td></tr></table></figure><p>repeat (默认值)水平和垂直方向都平铺</p><p>no-repeat 不平铺</p><p>repeat-x 沿着水平方向(x轴)平铺</p><p>repeat-y 沿着垂直方向(y轴)平铺</p><h3 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h3><p>background-position(bgp)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方位名词"><a href="#方位名词" class="headerlink" title="方位名词"></a>方位名词</h4><h5 id="水平方向"><a href="#水平方向" class="headerlink" title="水平方向"></a>水平方向</h5><p>left、center、right</p><h5 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h5><p>top、center、bottom</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>: right bottom; //水平位置 垂直位置<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字-px"><a href="#数字-px" class="headerlink" title="数字+px"></a>数字+px</h4><h5 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h5><p>①原点(0,0) 盒子左上角</p><p>②x轴 水平向右</p><p>③y轴 垂直向下</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>将图片左上角与坐标点重合即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">50px</span> <span class="hljs-number">100px</span>; //水平位置 垂直位置<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背景相关属性连写"><a href="#背景相关属性连写" class="headerlink" title="背景相关属性连写"></a>背景相关属性连写</h3><p>background: color image repeat position</p><p>可以不按顺序写。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background</span>: pink <span class="hljs-built_in">url</span>(<span class="hljs-string">./images/1.jpg</span>) no-repeat bottom center ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="与img的区别"><a href="#与img的区别" class="headerlink" title="与img的区别"></a>与img的区别</h4><p>①img标签是一个标签，不设置宽高默认会以原尺寸显示。</p><p>②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归——深度优先搜索(dfs)</title>
    <link href="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/"/>
    <url>/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/</url>
    
    <content type="html"><![CDATA[<h2 id="递归——深度优先搜索-dfs"><a href="#递归——深度优先搜索-dfs" class="headerlink" title="递归——深度优先搜索(dfs)"></a>递归——深度优先搜索(dfs)</h2><p>区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索：</p><p>递归方法类似于栈，将数据一直递取到底后自下往上出栈。</p><p>大致框架如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">viod <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(输出条件)&#123;<br>        cout&lt;&lt;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)&#123;<br>                a[k]=数字,vis[i]=<span class="hljs-number">1</span><span class="hljs-comment">//标记使用;</span><br>                <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//向下递取</span><br>                vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将其拿出，返回原先状态</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下列题目方式解决一些排列组合问题。</p><h4 id="组合输出-–5个数字组合输入3个盒子"><a href="#组合输出-–5个数字组合输入3个盒子" class="headerlink" title="组合输出 –5个数字组合输入3个盒子"></a>组合输出 –5个数字组合输入3个盒子</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231018142215689.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m,n,r;<br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>],vis[<span class="hljs-number">200</span>];<span class="hljs-comment">//a用来记录牌子，vis用来记录牌子的使用情况</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_rise</span><span class="hljs-params">(<span class="hljs-type">int</span> b[])</span></span>&#123;<span class="hljs-comment">//判断是否是递增数组</span><br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;r;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&gt;a[i+<span class="hljs-number">1</span>])&#123;<br>            flag=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//k为盒子的编号，或可以理解为步数</span><br>    <span class="hljs-keyword">if</span>(k==r+<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">is_rise</span>(a))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。</span><br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)&#123;<br>            a[k]=i,vis[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将牌子拿出来，此时就要把vis归回0</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;r;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。</p><h4 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a>素数环</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231017155808693.png"></p><p>eg：输入8 输出4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],vis[<span class="hljs-number">25</span>];<br><span class="hljs-type">int</span> n,cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isPrime</span>(a[<span class="hljs-number">1</span>]+a[n]))&#123;<span class="hljs-comment">//是否超出边界&amp;&amp;是否头尾相加是素数</span><br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isPrime</span>(i+a[k<span class="hljs-number">-1</span>]))&#123;<span class="hljs-comment">//vis用来看有没有用过这个数字</span><br>            a[k]=i,vis[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//a用来保存数字</span><br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前的这个数字清除，再向下dfs</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;cnt; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231012224152754.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>]; <span class="hljs-comment">//a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//depth first search</span><br><span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//i是指拿在你手上的牌的数字，没用0为了更好理解</span><br><span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//看看这个牌用过没有，b数组用来看这个牌用过没有用的</span><br>a[k]=i,b[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了</span><br><span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里</span><br>b[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推</span><br>&#125;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231024213457892.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,cnt;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],vis[<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//      cout&lt;&lt;sum&lt;&lt;&quot; &quot;;</span><br>        vis[sum]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,sum+a[k]);<br>    <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i])cnt++;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若把上面代码的注释删除则可以得到：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>由此可知上面深度搜索遍历的顺序是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span>+<span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">3</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">4</span><br><span class="hljs-attribute">0</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231107093250409.png"></p><p>以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。</p><p>相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬取pixiv日前十图片并下载至本地</title>
    <link href="/2023/09/11/pixiv-crawler/"/>
    <url>/2023/09/11/pixiv-crawler/</url>
    
    <content type="html"><![CDATA[<h1 id="爬取pixivic日前十图片"><a href="#爬取pixivic日前十图片" class="headerlink" title="爬取pixivic日前十图片"></a>爬取pixivic日前十图片</h1><p>实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910131905687.png" alt="image-20230910131905687.png"></p><h4 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h4><p>首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910132233727.png" alt="image-20230910132233727.png"></p><p>于是我们就可以向这个api发送请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;</span><br>reponse = requests.get(url)<br><span class="hljs-built_in">print</span>(reponse)  <span class="hljs-comment">#返回&lt;Response [200]&gt;</span><br></code></pre></td></tr></table></figure><p>因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。</p><h4 id="2-解析数据"><a href="#2-解析数据" class="headerlink" title="2.解析数据"></a>2.解析数据</h4><p>返回数据长这个样子：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910132826060.png" alt="image-20230910132826060.png"></p><h5 id="json使用"><a href="#json使用" class="headerlink" title="json使用"></a>json使用</h5><p>这就是标准的json形式文件，但还不是一个字典(其实很像)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。</p><p>我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">response.json()[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>]<br><span class="hljs-comment">#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png</span><br><span class="hljs-comment">#就是日排行第一的图</span><br></code></pre></td></tr></table></figure><p>但是当你将网站复制进浏览器时你会发现打不开。</p><h5 id="url拼接"><a href="#url拼接" class="headerlink" title="url拼接"></a>url拼接</h5><p>也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910133814148.png" alt="image-20230910133814148.png"></p><p><img src="/2023/09/11/pixiv-crawler/image-20230910133823700.png" alt="image-20230910133823700.png"></p><p>图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。</p><h4 id="3-下载图片至本地"><a href="#3-下载图片至本地" class="headerlink" title="3.下载图片至本地"></a>3.下载图片至本地</h4><p>目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img_url = <span class="hljs-string">&quot;https://acgpic.net/c/540x540_70/img-master&quot;</span>+response.json()[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>][<span class="hljs-number">32</span>:-<span class="hljs-number">4</span>]+<span class="hljs-string">&quot;_master1200.jpg&quot;</span><br><br>img = requests.get(img_url)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./top1.jpg&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#&quot;wb&quot;是以二进制写入</span><br>f.write(img.content)  <span class="hljs-comment">#content是指获取二进制内容</span><br></code></pre></td></tr></table></figure><p>此时你已经可以看到top1的图片下载当前文件夹了。</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910135314561.png" alt="image-20230910135314561.png"></p><p>同理，下载前十的图片只需要加入for循环就可以了，以下省略。</p><h4 id="4-下载至指定文件夹"><a href="#4-下载至指定文件夹" class="headerlink" title="4.下载至指定文件夹"></a>4.下载至指定文件夹</h4><p>这里就需要导入os包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>path = <span class="hljs-string">&#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27;</span>  <span class="hljs-comment">#这是我的绝对地址</span><br><span class="hljs-keyword">if</span>(os.path.exists(path)==<span class="hljs-literal">False</span>):  <span class="hljs-comment">#判断是否存在该文件夹</span><br>    os.mkdir(path)  <span class="hljs-comment">#创建该文件夹，文件夹名字为2023-9-7</span><br></code></pre></td></tr></table></figure><h5 id="path书写"><a href="#path书写" class="headerlink" title="path书写"></a>path书写</h5><p>这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910140553967.png" alt="image-20230910140553967.png"></p><p>第二条中的r是用来申明不是转义字符。</p><p>这样就可以创建一个文件夹了~</p><p>然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。</p><h4 id="5-关于api中日期的变化"><a href="#5-关于api中日期的变化" class="headerlink" title="5.关于api中日期的变化"></a>5.关于api中日期的变化</h4><p>因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>day = datetime.date.today()<br>api_day = day-datetime.timedelta(days=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>然后只需要再拼接如url中就可以啦~</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> datetime<br><br>day = datetime.date.today()<br>api_day = day-datetime.timedelta(days=<span class="hljs-number">3</span>)<br><br>url = <span class="hljs-string">&quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;</span>+<span class="hljs-built_in">str</span>(api_day)+<span class="hljs-string">&quot;&amp;mode=day&amp;pageSize=302&quot;</span><br>response = requests.get(url)<br>date = url[<span class="hljs-number">40</span>:<span class="hljs-number">50</span>]<br>path = <span class="hljs-string">&#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;</span>+date  <span class="hljs-comment">#linux写法</span><br><br><span class="hljs-keyword">if</span>(os.path.exists(path)==<span class="hljs-literal">False</span>):  <span class="hljs-comment">#判断是否存在该文件夹</span><br>    os.mkdir(path)  <span class="hljs-comment">#创建该文件夹</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img_url = <span class="hljs-string">&quot;https://acgpic.net/c/540x540_70/img-master&quot;</span>+response.json()[<span class="hljs-string">&quot;data&quot;</span>][i][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>][<span class="hljs-number">32</span>:-<span class="hljs-number">4</span>]+<span class="hljs-string">&quot;_master1200.jpg&quot;</span><br>    img = requests.get(img_url)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path+<span class="hljs-string">&quot;/top&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;.jpg&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(img.content)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存top&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;中...&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫 --- 以爬取笔趣阁小说为例</title>
    <link href="/2023/08/31/biquge/"/>
    <url>/2023/08/31/biquge/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫-—-以爬取笔趣阁小说为例"><a href="#爬虫-—-以爬取笔趣阁小说为例" class="headerlink" title="爬虫 — 以爬取笔趣阁小说为例"></a>爬虫 — 以爬取笔趣阁小说为例</h1><h4 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/5418/2610707.html&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>&#125;<br>response = requests.get(url,headers)<br></code></pre></td></tr></table></figure><p>这是requests请求，若返回response值为200，则表示请求成功</p><h4 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">response = requests.get(url,headers).text<br></code></pre></td></tr></table></figure><p>可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析</p><h4 id="3-解析数据"><a href="#3-解析数据" class="headerlink" title="3.解析数据"></a>3.解析数据</h4><p>有以下几种途径：css、xpath、re正则表达 等等</p><p>让我们来看看分别用这三种方法怎么去解析到一个章节的标题</p><h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br>selector = parsel.Selector(response)<br>novel_title = selector.css(<span class="hljs-string">&quot;.bookname h1::text&quot;</span>).get()<br></code></pre></td></tr></table></figure><p>这种方法通过css选择器进行选择</p><h5 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br>selector = parsel.Selector(response)<br>novel_title = selector.xpath(<span class="hljs-string">&quot;//*[@class=&quot;</span>bookname<span class="hljs-string">&quot;]/h1/text()&quot;</span>).get()<br></code></pre></td></tr></table></figure><p>注意text后面的()</p><h5 id="re"><a href="#re" class="headerlink" title="re"></a>re</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>novel_title = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串</p><p>*注意：以上方法各有利弊，选择合适的方式来解析数据</p><h4 id="4-保存数据"><a href="#4-保存数据" class="headerlink" title="4.保存数据"></a>4.保存数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file_name&quot;</span>+<span class="hljs-string">&quot;.txt&quot;</span>,mode=<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入</span><br>f.write(novel_context)  <span class="hljs-comment">#写入文件</span><br></code></pre></td></tr></table></figure><p>with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径</p><h4 id="以上思路已经理清楚了，下面开始实践："><a href="#以上思路已经理清楚了，下面开始实践：" class="headerlink" title="以上思路已经理清楚了，下面开始实践："></a>以上思路已经理清楚了，下面开始实践：</h4><h3 id="爬取一章"><a href="#爬取一章" class="headerlink" title="爬取一章"></a>爬取一章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/5418/2610707.html&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>&#125;<br>response = requests.get(url,headers).text<br><br>selector = parsel.Selector(response)<br>novel_title = selector.css(<span class="hljs-string">&quot;.bookname h1::text&quot;</span>).get() <span class="hljs-comment">#css方法解析数据</span><br><br>novel_context_list = selector.css(<span class="hljs-string">&quot;#htmlContent p::text&quot;</span>).getall() <br>novel_context = <span class="hljs-string">&quot;\n&quot;</span>.join(novel_context_list)<br></code></pre></td></tr></table></figure><p>注意：join函数的使用：</p><p><img src="/2023/08/31/biquge/p1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(a))  <span class="hljs-comment">#输出1 2 8 9</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>.join(a))  <span class="hljs-comment">#输出1(换行)2(换行)8(换行)9</span><br><br>b=&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(a))  <span class="hljs-comment">#输出a b</span><br></code></pre></td></tr></table></figure><p>（注意seq不能是int整形）</p><h3 id="爬取各章url"><a href="#爬取各章url" class="headerlink" title="爬取各章url"></a>爬取各章url</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/18753/&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>    &#125;<br>response = requests.get(url,headers).text<br>novel_name = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br>novel_info = re.findall(<span class="hljs-string">&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,response)<br><span class="hljs-keyword">for</span> novel_url_part,novel_title <span class="hljs-keyword">in</span> novel_info:<br>    novel_url = <span class="hljs-string">&quot;https://www.xzmncy.com&quot;</span>+novel_url_part[<span class="hljs-number">0</span>:<span class="hljs-number">24</span>]<br>    <span class="hljs-built_in">print</span>(novel_url)<br>    <span class="hljs-built_in">print</span>(novel_title)<br></code></pre></td></tr></table></figure><p>在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的：</p><p><img src="/2023/08/31/biquge/image-20230831120348951.png" alt="image-20230831120348951"></p><p>我们就可以用re来解析到各个章节的url和title</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> parsel<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/18753/&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>    &#125;<br>response = requests.get(url,headers).text<br>novel_name = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br>novel_info = re.findall(<span class="hljs-string">&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,response)<br><span class="hljs-keyword">for</span> novel_url_part,novel_title <span class="hljs-keyword">in</span> novel_info:<br>    novel_url = <span class="hljs-string">&quot;https://www.xzmncy.com&quot;</span>+novel_url_part[<span class="hljs-number">0</span>:<span class="hljs-number">24</span>]<br>    novel_response = requests.get(novel_url, headers).text<br>    selectors = parsel.Selector(novel_response)<br>    novel_context_list = selectors.css(<span class="hljs-string">&quot;#htmlContent p::text&quot;</span>).getall()<br>    novel_context = <span class="hljs-string">&quot;\n&quot;</span>.join(novel_context_list)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存&quot;</span>+novel_title)<br>    novel_title = <span class="hljs-string">&quot;*&quot;</span> + novel_title<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(novel_name+<span class="hljs-string">&quot;.txt&quot;</span>,mode=<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(novel_title)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>        f.write(novel_context)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器</title>
    <link href="/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><p>引入方式有以下三种：</p><p>1.内嵌式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!-- 内嵌式 --&gt;<br>&lt;!DOCTYPE <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span> lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-<span class="hljs-number">8</span>&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-scale=<span class="hljs-number">1.0</span>&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>        colour&#123;<br>colour:pink;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>2.外联式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 外联式 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./111.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 111为引入文件名 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.行内式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 行内式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;colour&quot;</span>&gt;</span><br>        abcd<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: aqua;font-size: large;&quot;</span>&gt;</span>abab<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>一共有4种：标签选择器、类选择器、id选择器、通符选择器</p><p>注：一下选择器均是在style标签下的</p><h4 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div)</p><h4 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2.类选择器"></a>2.类选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.color-choose</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其html调用方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;color-choose&quot;</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3.id选择器"></a>3.id选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#color</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其html调用方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：id只得调用一次</p><h4 id="4-通符选择器"><a href="#4-通符选择器" class="headerlink" title="4.通符选择器"></a>4.通符选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br>&lt;!-- 清除内外边距 --&gt;<br></code></pre></td></tr></table></figure><p>对全局内容生效</p><h2 id="选择器的选择"><a href="#选择器的选择" class="headerlink" title="选择器的选择"></a>选择器的选择</h2><h4 id="1-后代-（后面所有代）"><a href="#1-后代-（后面所有代）" class="headerlink" title="1.后代  （后面所有代）"></a>1.后代  （后面所有代）</h4><p>问题如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 哈哈哈 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>欲选择div中的p标签，而不是外部的p</p><p>以如下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>        <span class="hljs-attribute">color</span>:blue;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="2-子代-（后面一代）"><a href="#2-子代-（后面一代）" class="headerlink" title="2.子代  （后面一代）"></a>2.子代  （后面一代）</h4><p>问题是要选中div后面的一代</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> dd <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span> ddd <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以如下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-并集"><a href="#3-并集" class="headerlink" title="3.并集"></a>3.并集</h4><p>问题：想要让以下这些标签被选到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> p <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> div <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> span <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> haha <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下面方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">span</span>,<span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-交集"><a href="#4-交集" class="headerlink" title="4.交集"></a>4.交集</h4><p>问题：只想要选中下面p中带class&#x3D;”c”的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>abcd<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下面方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.c</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>p是标签，c是类名（前面带个.的）</p><h4 id="5-伪类"><a href="#5-伪类" class="headerlink" title="5.伪类"></a>5.伪类</h4><p>问题：想要让鼠标悬停在如下超链接上能够变色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;~~~&quot;</span>&gt;</span>传送<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br><span class="hljs-attribute">color</span>:red;<br><span class="hljs-attribute">background-color</span>:yellow;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破壳啦</title>
    <link href="/2023/08/21/page1/"/>
    <url>/2023/08/21/page1/</url>
    
    <content type="html"><![CDATA[<p>终于创建好一个博客啦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
