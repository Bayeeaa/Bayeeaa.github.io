<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通过Github Pages上线Vite app静态项目</title>
    <link href="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="通过Github-Pages上线Vite-app静态项目"><a href="#通过Github-Pages上线Vite-app静态项目" class="headerlink" title="通过Github Pages上线Vite app静态项目"></a>通过Github Pages上线Vite app静态项目</h2><p>我们都知道通过github pages是能够免费上线一个静态项目的。但你是否有疑惑，为什么我的vue项目在本地npm run dev的时候是能够查看的，为什么我部署到github上并通过github pages却是空白的？经过尝试我发现vite所构建的项目是相当于是操作文件，而不是对外发布(public)的文件，因此我们需要进行额外的操作。</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>在vite.config.ts文件中输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">base</span>:<span class="hljs-string">&#x27;/仓库名/&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/image-20240916144907709.png" alt="如上图所示配置"></p><p>然后在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>注意要build的话就需要将所有的飘红的bug都解决掉，否则报错。</p><p>然后要是build成功，就会发现多出一个dist隐藏文件，这个dist文件就是我们需要对外部署的文件。</p><p><img src="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/image-20240916145348136.png" alt="build成功如图所示"></p><h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><p>然后我们就需要将这个文件单独出一个分支，我们约定俗成给这个分支叫做”gh-pages”，并将dis导入进这个分支。</p><p>操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add dist -f<br>git commit -m <span class="hljs-string">&quot;adding dist&quot;</span>  <br>git subtree push --prefix dist origin gh-pages<br></code></pre></td></tr></table></figure><ul><li>git add dist -f ：注意-f是强制添加(force)的意思，因为这个是隐藏文件，git会默认将其忽略掉，因此需要强制添加到缓冲区。</li><li>git commit -m “adding dist”  ：确认上传，并写入原因。</li><li>git subtree push –prefix dist origin gh-pages ：我们一个一个分析:”git subtree”用于管理项目中的子目录作为独立的 Git 树结构进行操作；”push –prefix dist”推入子文件dist(dist在整个项目中是子文件)；”origin gh-pages “是目标地，origin是仓库，gh-pages是分支</li></ul><h3 id="上线pages"><a href="#上线pages" class="headerlink" title="上线pages"></a>上线pages</h3><p>当你完成了上述git操作之后就可以在github pages里面操作了：</p><p><img src="/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/image-20240916150945697.png" alt="根据步骤操作"></p><p>然后你就可以点击上面”Your site is live at https:&#x2F;&#x2F;**”，就可以访问了。</p><h3 id="静态项目更新"><a href="#静态项目更新" class="headerlink" title="静态项目更新"></a>静态项目更新</h3><p>当我们发现错误需要更新的时候，我们要知道在原vite项目和dist文件中都需要更改。首先需要在原来的vite项目中更改，然后上传至仓库。接着再重复上述的git命令上传至gh-pages里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br>git add dist -f<br>git commit -m <span class="hljs-string">&quot;adding dist&quot;</span>  <br>git subtree push --prefix dist origin gh-pages<br></code></pre></td></tr></table></figure><p>然后就可以完成网站更新了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/2024/09/03/Java-IO%E6%B5%81/"/>
    <url>/2024/09/03/Java-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-I-O流"><a href="#Java-I-O流" class="headerlink" title="Java I&#x2F;O流"></a>Java I&#x2F;O流</h2><p>I&#x2F;O流即input和output产生的流。Java程序是通过“流”的形式进行数据输入和输出。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流是一种抽象的概念，可以理解为输入&#x2F;输出的途径。I&#x2F;O部分内容是很庞大的，包括有标准的输入&#x2F;输出、文件操作、网络上的数据流、字符串流、对象流等。当程序需要读取数据时，就会开启一个通向数据源的流，这个数据源可以是文件、内存或网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。</p><h4 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h4><p>Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类表示：</p><ul><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ul><p><img src="/2024/09/03/Java-IO%E6%B5%81/08526eb1f3a09d7c36cbbed1be6c9f8.jpg" alt="Input和Output流继承关系"></p><p><img src="/2024/09/03/Java-IO%E6%B5%81/4794484f9461b73f5fa12aea1cf6443.jpg" alt="Reader和Writer流继承关系"></p><h4 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h4><p>流可分为两类：输入流和输出流。用户可以从输入流中读取信息，但不能写它。相反，对于输出流，只能往其中写，而不能读它。</p><h5 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h5><p>输入流的信息源可以位于文件、内存或网络套接字(Socket)等地方，信息源可以是对象、字符、图像、声音等。</p><h5 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h5><p>与输入流类似，程序页能通过打开一个输出流并顺序地写入数据来将信息送至目的端。</p><h4 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h4><h5 id="1-数据处理方式"><a href="#1-数据处理方式" class="headerlink" title="1. 数据处理方式"></a>1. 数据处理方式</h5><ul><li><strong>字节流</strong>：处理原始的字节数据。它适用于所有类型的数据，包括图像、音频、视频等，因为这些数据并不依赖于特定的字符编码。常见的字节流类包括 <code>InputStream</code> 和 <code>OutputStream</code> 及其子类，例如 <code>FileInputStream</code> 和 <code>FileOutputStream</code>。</li><li><strong>字符流</strong>：处理字符数据，并且能够自动处理字符编码和解码。字符流是基于字节流的封装，能将字节流转换成字符流，处理时考虑了字符编码（如 UTF-8、ISO-8859-1 等）。常见的字符流类包括 <code>Reader</code> 和 <code>Writer</code> 及其子类，例如 <code>FileReader</code> 和 <code>FileWriter</code>。</li></ul><h5 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h5><ul><li><strong>字节流</strong>：适合于二进制数据的读写，如图像、音频文件等，因为它们的数据通常不需要字符编码转换。例如，当你需要处理一个图片文件时，使用字节流是比较合适的选择。</li><li><strong>字符流</strong>：适合于文本数据的读写，尤其是当你需要处理不同字符编码时。字符流可以直接处理字符、字符串，并且会根据指定的字符集进行编码和解码。例如，当你读取或写入文本文件时，使用字符流更为方便。</li></ul><h5 id="3-处理单位"><a href="#3-处理单位" class="headerlink" title="3. 处理单位"></a>3. 处理单位</h5><ul><li><strong>字节流</strong>：以字节为单位进行读写，操作的是原始的二进制数据。</li><li><strong>字符流</strong>：以字符为单位进行读写，操作的是文本数据，并会进行字符编码的转换</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>在前面我们知道I&#x2F;O类中所有对字节流处理的类，都继承与InputStream类和OutputStream类。</p><h4 id="InputStream类"><a href="#InputStream类" class="headerlink" title="InputStream类"></a>InputStream类</h4><p><code>InputStream</code> 是 Java 中用于读取字节流的抽象类。它是所有字节输入流类的超类，提供了基本的输入流操作方法。<code>InputStream</code> 类的设计使得你可以从各种数据源（如文件、网络、内存等）读取字节数据。以下是关于 <code>InputStream</code> 类的一些关键点：</p><ol><li><p><strong><code>int read()</code></strong></p><ul><li><p>读取下一个字节的数据。</p></li><li><p>如果流末尾已到达，返回 <code>-1</code>。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> inputStream.read();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>int read(byte[] b)</code></strong></p><ul><li><p>从输入流中读取数据到字节数组中。</p></li><li><p>返回实际读取的字节数，如果流末尾已到达，返回 <code>-1</code>。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inputStream.read(buffer);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>int read(byte[] b, int off, int len)</code></strong></p><ul><li><p>从输入流中读取数据到字节数组中的指定位置。</p></li><li><p>参数 <code>off</code> 指定写入数据的起始位置，<code>len</code> 指定最大读取字节数。</p></li><li><p>返回实际读取的字节数，如果流末尾已到达，返回 <code>-1</code>。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inputStream.read(buffer, <span class="hljs-number">0</span>, buffer.length);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void close()</code></strong></p><ul><li><p>关闭输入流并释放与之关联的系统资源。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">inputStream.close();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>long skip(long n)</code></strong></p><ul><li><p>跳过并丢弃输入流中的 <code>n</code> 个字节。</p></li><li><p>返回实际跳过的字节数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">skipped</span> <span class="hljs-operator">=</span> inputStream.skip(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>available()</code></strong></p><ul><li><p>返回流中当前可读的字节数，但不一定能保证实际读取的字节数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">availableBytes</span> <span class="hljs-operator">=</span> inputStream.available();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>常见子类：</p><ul><li><code>FileInputStream</code>：从文件中读取字节流。</li><li><code>ByteArrayInputStream</code>：从内存中的字节数组中读取字节流。</li><li><code>BufferedInputStream</code>：提供缓冲功能的输入流，能提高读取效率。</li><li><code>DataInputStream</code>：提供读取 Java 原始数据类型的输入流。</li></ul><p>示例：</p><p>以下是一个简单的使用 <code>FileInputStream</code> 类读取文件内容的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">int</span> content;<br>            <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 打印读取的字节（转换为字符）</span><br>                System.out.print((<span class="hljs-type">char</span>) content);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>InputStream</code> 是一个抽象类，不能直接实例化。通常，你会使用其具体子类来进行实际的字节读取操作。</li><li>操作完成后，一定要关闭流，以释放系统资源。这通常通过 <code>try-with-resources</code> 语句来自动完成。</li></ul><h4 id="OutputStream类"><a href="#OutputStream类" class="headerlink" title="OutputStream类"></a>OutputStream类</h4><p><code>OutputStream</code> 是 Java 中用于写入字节流的抽象类。它是所有字节输出流类的超类，提供了基本的输出流操作方法。<code>OutputStream</code> 类的设计使得你可以将字节数据写入各种数据目标，如文件、网络连接、内存等。以下是 <code>OutputStream</code> 类的一些关键点：</p><ol><li><p><strong><code>void write(int b)</code></strong></p><ul><li><p>将指定的字节写入输出流。</p></li><li><p>参数 <code>b</code> 是要写入的字节（实际上是一个 <code>int</code> 值，但只使用低 8 位）。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outputStream.write(<span class="hljs-number">65</span>); <span class="hljs-comment">// 写入字节 &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(byte[] b)</code></strong></p><ul><li><p>将字节数组中的所有字节写入输出流。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes();<br>outputStream.write(data);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(byte[] b, int off, int len)</code></strong></p><ul><li><p>将字节数组中的一部分写入输出流。</p></li><li><p>参数 <code>off</code> 是字节数组中的起始偏移量，<code>len</code> 是要写入的字节数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = <span class="hljs-string">&quot;Hello World&quot;</span>.getBytes();<br>outputStream.write(data, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void flush()</code></strong></p><ul><li><p>刷新输出流，确保所有缓冲的字节都被写入到目标地。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outputStream.flush();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void close()</code></strong></p><ul><li><p>关闭输出流并释放与之关联的系统资源。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outputStream.close();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>常见子类：</p><ul><li><code>FileOutputStream</code>：将字节写入文件。</li><li><code>ByteArrayOutputStream</code>：将字节写入内存中的字节数组。</li><li><code>BufferedOutputStream</code>：提供缓冲功能的输出流，能提高写入效率。</li><li><code>DataOutputStream</code>：提供写入 Java 原始数据类型的输出流。</li></ul><p>示例：</p><p>以下是一个简单的使用 <code>FileOutputStream</code> 类写入文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriteExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>            fos.write(content.getBytes());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:</p><ol><li><strong>关闭流</strong>：使用完 <code>OutputStream</code> 后一定要关闭流，以释放系统资源。通常使用 <code>try-with-resources</code> 语句来自动关闭流。</li><li><strong>缓冲</strong>：如果你需要提高写入效率，可以使用 <code>BufferedOutputStream</code> 进行缓冲操作。</li><li><strong>写入数据</strong>：在写入数据时，可以选择将字节数组、单个字节或字节数组的部分写入流。确保正确处理偏移量和长度，以避免写入不必要的数据或产生异常。</li></ol><p><code>OutputStream</code> 提供了处理字节数据的基本操作，了解其使用方法可以帮助你在处理文件、网络和其他数据目标时有效地输出字节数据。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>InputStream和OutputStream在早期的Java版本中就已经存在了，它们是基于字节流的，而基于字符流的Reader和Writer是后来加入作为补充的。</p><h4 id="Rreader类"><a href="#Rreader类" class="headerlink" title="Rreader类"></a>Rreader类</h4><p><code>Reader</code> 类是 Java 中用于处理字符流的抽象类。它是所有字符输入流类的超类，提供了基本的字符读取操作方法。与 <code>InputStream</code> 类不同，<code>Reader</code> 处理的是字符而不是原始字节，因此它会根据指定的字符编码进行字符转换。</p><p>其主要操作方法有下述几种，因与IO类类似，故其不在赘述。</p><ol><li><code>int read()</code></li><li><code>int read(char[] cbuf)</code></li><li><code>int read(char[] cbuf, int off, int len)</code></li><li><code>long skip(long n)</code></li><li><code>boolean ready()</code></li><li><code>void close()</code></li></ol><p>常见子类:</p><ul><li><code>FileReader</code>：从文件中读取字符流。</li><li><code>BufferedReader</code>：提供缓冲功能的字符流，能提高读取效率，并且提供了 <code>readLine()</code> 方法以便逐行读取文本。</li><li><code>CharArrayReader</code>：从内存中的字符数组中读取字符流。</li><li><code>StringReader</code>：从内存中的字符串读取字符流。</li></ul><p>示例:</p><p>以下是一个简单的使用 <code>FileReader</code> 类读取文件内容的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">int</span> character;<br>            <span class="hljs-keyword">while</span> ((character = fr.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) character);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>BufferedReader</code> 逐行读取文本的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;example.txt&quot;</span>))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p><strong>字符编码</strong>：<code>Reader</code> 类会处理字符编码问题，因此在读取文件时，确保文件编码与你的 <code>Reader</code> 配置一致。</p><p><strong>关闭流</strong>：使用完 <code>Reader</code> 后，一定要关闭流以释放系统资源。通常使用 <code>try-with-resources</code> 语句来自动关闭流。</p><p><strong>缓冲</strong>：为了提高读取效率，可以使用 <code>BufferedReader</code> 类，它提供了缓冲功能，并且能更高效地读取数据。</p><h4 id="Writer类"><a href="#Writer类" class="headerlink" title="Writer类"></a>Writer类</h4><p><code>Writer</code> 类是 Java 中用于处理字符流的抽象类。它是所有字符输出流类的超类，提供了基本的字符输出操作方法。与 <code>OutputStream</code> 类不同，<code>Writer</code> 处理的是字符数据，而不是原始的字节数据，因此它会根据指定的字符编码进行字符转换。</p><ol><li><p><strong><code>void write(int c)</code></strong></p><ul><li><p>将指定的字符写入输出流。</p></li><li><p>参数 <code>c</code> 是要写入的字符（实际是一个 <code>int</code> 值，但只使用低 16 位）。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.write(<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">// 写入字符 &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(char[] cbuf)</code></strong></p><ul><li><p>将字符数组中的所有字符写入输出流。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] data = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray();<br>writer.write(data);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(char[] cbuf, int off, int len)</code></strong></p><ul><li><p>将字符数组中的一部分写入输出流。</p></li><li><p>参数 <code>off</code> 是字符数组中的起始偏移量，<code>len</code> 是要写入的字符数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] data = <span class="hljs-string">&quot;Hello World&quot;</span>.toCharArray();<br>writer.write(data, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(String str)</code></strong></p><ul><li><p>将字符串中的所有字符写入输出流。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void write(String str, int off, int len)</code></strong></p><ul><li><p>将字符串的指定部分写入输出流。</p></li><li><p>参数 <code>off</code> 是字符串中的起始位置，<code>len</code> 是要写入的字符数。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void flush()</code></strong></p><ul><li><p>刷新输出流，确保所有缓冲的字符都被写入到目标地。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.flush();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>void close()</code></strong></p><ul><li><p>关闭输出流并释放与之关联的系统资源。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">writer.close();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>常见子类:</p><ul><li><code>FileWriter</code>：将字符写入文件。</li><li><code>BufferedWriter</code>：提供缓冲功能的字符流，能提高写入效率。</li><li><code>CharArrayWriter</code>：将字符写入内存中的字符数组。</li><li><code>PrintWriter</code>：提供了更多格式化功能的字符输出流，支持打印各种数据类型。</li></ul><p>示例:</p><p>以下是一个简单的使用 <code>FileWriter</code> 类写入文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriteExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)) &#123;<br>            fw.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>BufferedWriter</code> 提高写入效率的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;example.txt&quot;</span>))) &#123;<br>            bw.write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>            bw.newLine(); <span class="hljs-comment">// 添加新行</span><br>            bw.write(<span class="hljs-string">&quot;This is a new line.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><strong>字符编码</strong>：<code>Writer</code> 类会处理字符编码问题，因此在写入文件时，确保文件编码与你的 <code>Writer</code> 配置一致。如果需要特定的编码格式，可以使用 <code>OutputStreamWriter</code> 类来指定编码。</li><li><strong>关闭流</strong>：使用完 <code>Writer</code> 后，一定要关闭流以释放系统资源。通常使用 <code>try-with-resources</code> 语句来自动关闭流。</li><li><strong>缓冲</strong>：为了提高写入效率，可以使用 <code>BufferedWriter</code> 类，它提供了缓冲功能，并能更高效地写入数据。</li></ol><h3 id="实现用户输入"><a href="#实现用户输入" class="headerlink" title="实现用户输入"></a>实现用户输入</h3><p>Java提供了java.util.Scanner类，可以直接接收控制台命令行的输入。</p><h4 id="使用System-in获取用户输入"><a href="#使用System-in获取用户输入" class="headerlink" title="使用System.in获取用户输入"></a>使用System.in获取用户输入</h4><p>Java提供了System.in、System.out及System.err类。</p><p>System.out是一个已经预先处理过的、被包装成PrintStream的对象。</p><p>System.err和System.out一样，也是一个PrintStream。</p><p>但System.in就不是了，它是一个未经处理的InputStream。</p><p>System.in输入示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System_test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">char</span> a;<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>);<br>        a=(<span class="hljs-type">char</span>)System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;输入的是&quot;</span> + a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用Scanner类获取用户输入"><a href="#使用Scanner类获取用户输入" class="headerlink" title="使用Scanner类获取用户输入"></a>使用Scanner类获取用户输入</h4><p>java.util.Scanner类是JDK新增的一个类，可使用该类创建一个命令行读取数据的对象，而不必再进行流的转换。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scannner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure><p>然后我们就可以对sc进行调用操作，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextLine();<br></code></pre></td></tr></table></figure><p>这里我们注意了，可以有多种调用方式：</p><ul><li>next()：字符串</li><li>nextInt()：整型</li><li>nextDouble()：浮点型</li><li>nextLine()：字符串，但可以读入空格</li></ul><h3 id="在绝对路径创建文件夹，并创建一个临时txt文件"><a href="#在绝对路径创建文件夹，并创建一个临时txt文件" class="headerlink" title="在绝对路径创建文件夹，并创建一个临时txt文件"></a>在绝对路径创建文件夹，并创建一个临时txt文件</h3><ul><li>FileCreateAndDir.java：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.IO_test;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCreateAndDir</span> &#123; <span class="hljs-comment">//文件创建和目录</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createDir</span><span class="hljs-params">(String destDirName)</span>&#123; <span class="hljs-comment">//创建目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(destDirName);<br>        <span class="hljs-keyword">if</span>(dir.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标目录存在！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!destDirName.endsWith(File.separator))&#123; <span class="hljs-comment">//结尾是否以&quot;/&quot;结束</span><br>            destDirName = destDirName + File.separator;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dir.mkdir())&#123; <span class="hljs-comment">//这里创建目录，并返回true</span><br>            System.out.println(<span class="hljs-string">&quot;目录成功创建！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;创建失败！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createFile</span><span class="hljs-params">(String filePath)</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(file.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标文件已存在！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(filePath.endsWith(File.separator))&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标文件不能是文件！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!file.getParentFile().exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目标文件文件夹不存在，正在创建它！&quot;</span>);<br>            <span class="hljs-keyword">if</span>(!file.getParentFile().mkdir())&#123;<br>                System.out.println(<span class="hljs-string">&quot;创建目标文件失败！&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(file.createNewFile())&#123;<br>                System.out.println(<span class="hljs-string">&quot;文件创建成功！&quot;</span> + filePath);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;文件创建失败！&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>test：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.IO_test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dirPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\yyn19\\Desktop\\demoTest&quot;</span>;<br>        FileCreateAndDir.createDir(dirPath); <span class="hljs-comment">// 创建目录</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> dirPath + File.separator + <span class="hljs-string">&quot;myfile.txt&quot;</span>; <span class="hljs-comment">// 文件路径,并给出文件名</span><br>        FileCreateAndDir.createFile(filePath); <span class="hljs-comment">// 创建文件</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2024/08/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/08/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>集合有时又称容方法，简单地说就是个对象，能将具有相同性质的多个元素汇聚成一个整体。</p><p>集合框架(Collections Framework)是用来表现和操纵集合的一个统一的体系结构。</p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>Collection接口时Java集合框架的最顶层接口，它位于<code>java.util</code>包中，是Set接口和List接口(后面会讲)的父接口。</p><h4 id="转换构造法"><a href="#转换构造法" class="headerlink" title="转换构造法"></a>转换构造法</h4><p>Collection接口实现都有一个带有集合参数的构造方法。也就是说，在这里可以通过”转换”集合的类型来实现存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>a可以是一个List、Set或另外一中Collection。通常，习惯地创建一个新的ArrayList，初始化为包含a中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(a);<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;(a);<br></code></pre></td></tr></table></figure><p>通过“转换构造法”，list或set对象就包含了集合a中的所有元素。</p><h4 id="Collection接口的定义"><a href="#Collection接口的定义" class="headerlink" title="Collection接口的定义"></a>Collection接口的定义</h4><p>基本操作：</p><ul><li><code>boolean add(E e)</code>: 将指定的元素添加到集合中（如果集合允许添加）。</li><li><code>boolean remove(Object o)</code>: 从集合中移除指定的元素。</li><li><code>boolean contains(Object o)</code>: 检查集合是否包含指定的元素。</li><li><code>int size()</code>: 返回集合中的元素数量。</li><li><code>boolean isEmpty()</code>: 检查集合是否为空。</li><li><code>Iterator&lt;E&gt; iterator()</code>: 返回一个迭代器，用于遍历集合中的元素。</li></ul><p>以及批量操作：</p><ul><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>: 批量添加</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: 从集合中批量移除元素。</li><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>: 检查当前集合是否包含所有传入集合的元素</li><li><code>bollean retainAll(Collection&lt;?&gt; c)</code>: 删除当前集合中所有不在指定集合 <code>c</code> 中的元素</li><li><code>void clear()</code>: 移除集合中的所有元素。</li></ul><p>数组操作：</p><ul><li><code>Object[] toArray()</code>: 将集合转换为数组，数组类型为object</li><li><code>&lt;T&gt; T[] toArry(T[] a)</code>: 将集合中的元素转换为指定类型的数组，并将其存储在提供的数组中。如果提供的数组足够大，则元素将被存储在这个数组中；否则，将创建一个新的数组。</li></ul><h4 id="Collection接口的基本操作"><a href="#Collection接口的基本操作" class="headerlink" title="Collection接口的基本操作"></a>Collection接口的基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">dog</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>(<span class="hljs-string">&quot;andy&quot;</span>,<span class="hljs-number">5</span>);<br><span class="hljs-type">dog</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">2</span>);<br>Collection&lt;dog&gt; collection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>collection.add(d1);<br>collection.add(d2);<br><br><span class="hljs-keyword">for</span>(dog o : collection)&#123; <span class="hljs-comment">//for-each遍历</span><br>    System.out.println(o.getName());<br>&#125;<br><br>Iterator&lt;String&gt; iterator = collection.iterator(); <span class="hljs-comment">//迭代遍历</span><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br><br>collection.remove(d1); <span class="hljs-comment">//删除d1对象</span><br><br>collection.clear(); <span class="hljs-comment">//清空</span><br></code></pre></td></tr></table></figure><p>这里我创建了一个dog对象，并给它name和age。</p><p>要注意的是，iterator迭代方法同样有遍历的功能，但是Iterator.remove是修改集合唯一安全的方法。如果要移除当前元素。for-each结构隐藏迭代方法，因此不能调用remove方法。同样在多重集合上进行并行迭代也要用迭代器迭代。</p><p>下面演示如何过滤Collection集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>&#123;<br><span class="hljs-keyword">for</span>(Iterator&lt;?&gt; it = c.iterator();it.hasNext();)&#123;<br>        <span class="hljs-keyword">if</span>(?cond(it.next())) it.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Collection接口的批量操作"><a href="#Collection接口的批量操作" class="headerlink" title="Collection接口的批量操作"></a>Collection接口的批量操作</h4><p>下面展示表现批量操作强大功能的一个示例，从一个名为c的Collection中移除一个指定元素e的所有实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">c.removeAll(Collections.singleton(e))；<br></code></pre></td></tr></table></figure><p>或者也可以移除所有null元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">c.removeAll(Collections.singleton(<span class="hljs-literal">null</span>))；<br></code></pre></td></tr></table></figure><p>Collections.singleton是一个静态工厂方法，返回一个只包含指定元素的不可变Set集合(没有重复元素)。</p><p>在例子中Collections.singleton(e)方法只包含元素e的Set集合，然后就可以用removeAll删除。</p><h4 id="Collection数组操作"><a href="#Collection数组操作" class="headerlink" title="Collection数组操作"></a>Collection数组操作</h4><p>toArray()方法主要作为集合和老的期望输入数组的API之间的桥梁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建并初始化一个 List</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br><span class="hljs-comment">// 使用 toArray() 方法将集合转换为 Object 数组</span><br>Object[] array = list.toArray();<br><br><span class="hljs-comment">// 使用 toArray(T[] a) 方法将集合转换为指定类型的数组</span><br>String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set是一个不能包含重复元素的接口，是Collection接口的子接口，并且只包含从Collection继承过来的方法，并增加了对add()方法的使用限制，不允许有重复的元素。Set()还修改了equals()和hashCode()方法的实现，允许对Set实例进行内容上的比较，即使它们实现类型不同。如果两个Set实例包含相同的元素，那么它们就是相等的。</p><h4 id="Set定义"><a href="#Set定义" class="headerlink" title="Set定义"></a>Set定义</h4><p><strong>主要方法</strong>:</p><ul><li>继承了<code>Collection</code>接口的所有方法。</li><li>没有专门定义新的方法，但子接口和实现类提供了对集合不重复性要求的具体实现。</li></ul><p><strong>主要实现类</strong>:</p><ul><li><strong><code>HashSet</code></strong>: 基于哈希表的实现，不保证元素的顺序，通常提供快速的插入、删除和查找操作。</li><li><strong><code>TreeSet</code></strong>: 基于红黑树的实现，按自然顺序或构造时提供的比较器进行排序。</li><li><strong><code>LinkedHashSet</code></strong>: 结合了哈希表和链表的特点，保持插入顺序的同时提供较快的操作速度。</li></ul><p>Java平台包含3个通用目的的Set实现就是HashSet、TreeSet、LinkedHashSet这三个。</p><h4 id="Set接口的基本操作"><a href="#Set接口的基本操作" class="headerlink" title="Set接口的基本操作"></a>Set接口的基本操作</h4><p>那么Set和Collection有什么区别呢？下面看这个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用 Collection 接口</span><br>        Collection&lt;String&gt; collection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        collection.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Collection: &quot;</span> + collection);<br><br>        <span class="hljs-comment">// 使用 Set 接口</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">//这里用了哈希存放</span><br>        set.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Apple&quot;</span>); <span class="hljs-comment">// 重复元素不会被添加</span><br>        System.out.println(<span class="hljs-string">&quot;Set: &quot;</span> + set);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，这其中最大的区别就是Set不能重复添加元素。</p><h4 id="Set接口的批量操作"><a href="#Set接口的批量操作" class="headerlink" title="Set接口的批量操作"></a>Set接口的批量操作</h4><p>批量操作特别适合于Set接口：</p><ul><li>s1.containsAll(s2)：如果s2是s1的一个子集合，返回true</li><li>s1.addAll(s2)：将s1变换为s1和s2的并集</li><li>s1.retain(s2)：将s1变换为s1和s2的交集</li><li>s1.removeAll(s2)：将s1不对称地变换为s1和s2的差集</li></ul><p>addAll示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set1.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>set1.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>Set&lt;String&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set2.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;Date&quot;</span>);<br><br><span class="hljs-comment">// 将 set2 的所有元素添加到 set1 中</span><br>set1.addAll(set2);<br><br>System.out.println(<span class="hljs-string">&quot;Set1 after addAll: &quot;</span> + set1);<br><span class="hljs-comment">//Set1 after addAll: [Apple, Banana, Cherry, Date]</span><br></code></pre></td></tr></table></figure><p>removeAll示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set1.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>set1.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>set1.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br>Set&lt;String&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set2.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br><span class="hljs-comment">// 从 set1 中移除 set2 中的所有元素</span><br>set1.removeAll(set2);<br><br>System.out.println(<span class="hljs-string">&quot;Set1 after removeAll: &quot;</span> + set1);<br></code></pre></td></tr></table></figure><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List是一个有序的集合(又是被称为序列)。List可以包含重复的元素。除了从Collection继承过来的操作之外，List接口还包括以下操作：</p><ul><li>按位置访问：根据元素在序列中的位置索引访问元素</li><li>查找：在序列中查找指定对象，并返回其位置索引</li><li>迭代：扩展了Iteractor接口，以利用序列的顺序特性</li><li>List子集合：在序列上执行任意范围的操作</li></ul><h4 id="List接口的定义"><a href="#List接口的定义" class="headerlink" title="List接口的定义"></a>List接口的定义</h4><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span>;<br>    E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span>;<br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span>;<br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    List&lt;E&gt; <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java平台常见的List实现包括： <code>ArrayList</code>（基于动态数组）、<code>LinkedList</code>（基于双向链表）和 <code>Vector</code>（线程安全的动态数组）。</p><h4 id="List接口的操作"><a href="#List接口的操作" class="headerlink" title="List接口的操作"></a>List接口的操作</h4><h5 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. <strong>添加元素</strong></h5><ul><li><p><strong><code>void add(int index, E element)</code></strong></p><ul><li>在指定位置插入元素。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Orange&quot;</span>);  <span class="hljs-comment">// 在位置 1 插入 &quot;Orange&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></strong></p><ul><li>从指定位置开始，将指定集合中的所有元素添加到当前列表中。</li></ul><p><strong>示例</strong>:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Items</span> = Arrays.asList(<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Grapes&quot;</span>);<br>list.addAll(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Items</span>);  <span class="hljs-comment">// 从位置 1 开始添加 newItems 中的元素</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2. 访问元素"></a>2. <strong>访问元素</strong></h5><ul><li><p><strong><code>E get(int index)</code></strong></p><ul><li>获取指定位置的元素。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 获取位置 0 的元素</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>E set(int index, E element)</code></strong></p><ul><li>替换指定位置的元素。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Orange&quot;</span>);  <span class="hljs-comment">// 将位置 1 的元素替换为 &quot;Orange&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. <strong>删除元素</strong></h5><ul><li><p><code>E remove(int index)</code></p><ul><li>移除指定位置的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br>list.remove(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 移除位置 1 的元素</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="4-查找元素"><a href="#4-查找元素" class="headerlink" title="4. 查找元素"></a>4. <strong>查找元素</strong></h5><ul><li><p><strong><code>int indexOf(Object o)</code></strong></p><ul><li>返回指定元素第一次出现的索引，如果不在列表中，则返回 -1。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> list.indexOf(<span class="hljs-string">&quot;Banana&quot;</span>);  <span class="hljs-comment">// 获取 &quot;Banana&quot; 的位置</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>int lastIndexOf(Object o)</code></strong></p><ul><li>返回指定元素最后一次出现的索引，如果不在列表中，则返回 -1。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> list.lastIndexOf(<span class="hljs-string">&quot;Banana&quot;</span>);  <span class="hljs-comment">// 获取 &quot;Banana&quot; 最后出现的位置</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="5-子列表"><a href="#5-子列表" class="headerlink" title="5. 子列表"></a>5. <strong>子列表</strong></h5><ul><li><p><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></p><ul><li>返回当前列表中从 <code>fromIndex</code>（包含）到 <code>toIndex</code>（不包含）的部分列表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Date&quot;</span>);<br><br>List&lt;String&gt; subList = list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 获取子列表 [Banana, Cherry]</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6. 迭代器"></a>6. <strong>迭代器</strong></h5><ul><li><p><code>ListIterator&lt;E&gt; listIterator()</code></p><ul><li>返回一个 <code>ListIterator</code>，从列表的开始处迭代。</li></ul></li><li><p><code>ListIterator&lt;E&gt; listIterator(int index)</code></p><ul><li>返回一个 <code>ListIterator</code>，从指定的位置开始迭代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Cherry&quot;</span>);<br><br>ListIterator&lt;String&gt; iterator = list.listIterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br><br>ListIterator&lt;String&gt; iteratorFromIndex = list.listIterator(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (iteratorFromIndex.hasNext()) &#123;<br>    System.out.println(iteratorFromIndex.next());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="Map接口的定义"><a href="#Map接口的定义" class="headerlink" title="Map接口的定义"></a>Map接口的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">//基本操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span>;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br>    V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span>;<br>    <span class="hljs-comment">//批量操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//集合视图</span><br>    Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br>    Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br>    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br><br>    <span class="hljs-comment">//嵌套接口</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt; &#123;<br>        K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br>        V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br>        V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java平台包括3中通用的Map实现：HashMap、TreeMap和LinkedHashMap。</p><h4 id="Map接口的基本操作"><a href="#Map接口的基本操作" class="headerlink" title="Map接口的基本操作"></a>Map接口的基本操作</h4><h5 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. <strong>基本操作</strong></h5><ul><li><p><strong><code>int size()</code></strong></p><ul><li>返回 <code>Map</code> 中键值对的数量。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();  <span class="hljs-comment">// 返回 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>boolean isEmpty()</code></strong></p><ul><li>检查 <code>Map</code> 是否为空（即是否没有键值对）。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> map.isEmpty();  <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-键和值的存在性检查"><a href="#2-键和值的存在性检查" class="headerlink" title="2. 键和值的存在性检查"></a>2. <strong>键和值的存在性检查</strong></h5><ul><li><p><strong><code>boolean containsKey(Object key)</code></strong></p><ul><li>检查 <code>Map</code> 是否包含指定的键。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">hasKey</span> <span class="hljs-operator">=</span> map.containsKey(<span class="hljs-string">&quot;One&quot;</span>);  <span class="hljs-comment">// 返回 true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>boolean containsValue(Object value)</code></strong></p><ul><li>检查 <code>Map</code> 是否包含指定的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">hasValue</span> <span class="hljs-operator">=</span> map.containsValue(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 返回 true</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="3-获取和设置键值对"><a href="#3-获取和设置键值对" class="headerlink" title="3. 获取和设置键值对"></a>3. <strong>获取和设置键值对</strong></h5><ul><li><p><strong><code>V get(Object key)</code></strong></p><ul><li>根据键获取对应的值。如果键不存在，则返回 <code>null</code>。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;One&quot;</span>);  <span class="hljs-comment">// 返回 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>V put(K key, V value)</code></strong></p><ul><li>将指定的键值对添加到 <code>Map</code> 中。如果键已经存在，则更新对应的值，并返回之前的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;Three&quot;</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 将 &quot;Three&quot; 键与 3 值添加到 map 中</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>V remove(Object key)</code></strong></p><ul><li>根据键移除对应的键值对，并返回被移除的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">removedValue</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">&quot;Two&quot;</span>);  <span class="hljs-comment">// 移除 &quot;Two&quot; 键对应的值 2</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="4-批量操作"><a href="#4-批量操作" class="headerlink" title="4. 批量操作"></a>4. <strong>批量操作</strong></h5><ul><li><p><strong><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></strong></p><ul><li>将指定 <code>Map</code> 中的所有键值对添加到当前 <code>Map</code> 中。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; anotherMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>anotherMap.put(<span class="hljs-string">&quot;Four&quot;</span>, <span class="hljs-number">4</span>);<br>anotherMap.put(<span class="hljs-string">&quot;Five&quot;</span>, <span class="hljs-number">5</span>);<br><br>map.putAll(anotherMap);  <span class="hljs-comment">// 将 anotherMap 的所有键值对添加到 map 中</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>void clear()</code></strong></p><ul><li>移除 <code>Map</code> 中的所有键值对，使 <code>Map</code> 变为空。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.clear();  <span class="hljs-comment">// 清空 map</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="5-视图操作"><a href="#5-视图操作" class="headerlink" title="5. 视图操作"></a>5. <strong>视图操作</strong></h5><ul><li><p><strong><code>Set&lt;K&gt; keySet()</code></strong></p><ul><li>返回 <code>Map</code> 中所有键的集合。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; keys = map.keySet();  <span class="hljs-comment">// 获取 map 的所有键</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Collection&lt;V&gt; values()</code></strong></p><ul><li>返回 <code>Map</code> 中所有值的集合。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;Integer&gt; values = map.values();  <span class="hljs-comment">// 获取 map 的所有值</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></strong></p><ul><li>返回 <code>Map</code> 中所有键值对的集合，每个键值对作为 <code>Map.Entry</code> 对象存在。</li></ul><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="6-嵌套接口-Entry"><a href="#6-嵌套接口-Entry" class="headerlink" title="6. 嵌套接口 Entry"></a>6. <strong>嵌套接口 <code>Entry</code></strong></h5><ul><li><code>K getKey()</code><ul><li>返回 <code>Map.Entry</code> 对象中的键。</li></ul></li><li><code>V getValue()</code><ul><li>返回 <code>Map.Entry</code> 对象中的值。</li></ul></li><li><code>V setValue(V value)</code><ul><li>设置 <code>Map.Entry</code> 对象中的值，并返回之前的值。</li></ul></li><li><code>boolean equals(Object o)</code><ul><li>判断两个 <code>Map.Entry</code> 对象是否相等。</li></ul></li><li><code>int hashCode()</code><ul><li>返回 <code>Map.Entry</code> 对象的哈希码。</li></ul></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>比如我们可以做一个数组中单词的显示次数小程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(String a : args)&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> m.get(a);<br>    m.put( a, (freq == <span class="hljs-literal">null</span>) ? <span class="hljs-number">1</span> : freq+<span class="hljs-number">1</span> ); <span class="hljs-comment">//（键，值）</span><br>&#125;<br>System.out.println(m.size() + <span class="hljs-string">&quot;个不同的单词&quot;</span>);<br>System.out.println(m);<br></code></pre></td></tr></table></figure><p>args:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">java <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">be</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">if</span> <br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">5个不同的单词<br>&#123;<span class="hljs-attribute">java</span>=1, <span class="hljs-attribute">be</span>=1, <span class="hljs-attribute">is</span>=2, <span class="hljs-attribute">to</span>=1, <span class="hljs-attribute">if</span>=2&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoCAD学习笔记</title>
    <link href="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="AutoCAD学习笔记"><a href="#AutoCAD学习笔记" class="headerlink" title="AutoCAD学习笔记"></a>AutoCAD学习笔记</h2><p>这段时间在金工行业实习了一段时间，了解到一般机械制图是用到cad来绘画草图，然后再将画出的.dwg文件导入到ug(或者solidworks)中将其拉伸成3d图形。下面我将记录下这段时间使用cad的较多的快捷键以及指令操作。</p><h3 id="界面设置"><a href="#界面设置" class="headerlink" title="界面设置"></a>界面设置</h3><p>介于方便我们操作，免得每次都要点开找，我们可以将一些常用的操作直接放在边框layout处。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240826105405781.png" alt="可以像这样设置CAD界面"></p><p>那么怎么设置呢？我们可以右键上方layout处(灰色处)，然后将光标放到AutoCAD上：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d95b2a44155895695886f076c91876b.jpg" alt="如图会出现很多选项，对着上图勾选即可"></p><p>然后将出现的小框拖到上述界面的位置即可，这样方便我们使用。</p><h3 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h3><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><table><thead><tr><th>快捷键</th><th>操作</th><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>l (L)</td><td>直线</td><td>s</td><td>拉伸</td></tr><tr><td>e</td><td>清除</td><td>tr</td><td>修剪</td></tr><tr><td>co</td><td>复制</td><td>ex</td><td>延伸</td></tr><tr><td>m</td><td>移动</td><td>cha</td><td>倒直角</td></tr><tr><td>o</td><td>偏移</td><td>f</td><td>倒圆角</td></tr><tr><td>c</td><td>圆</td><td>dli</td><td>直线标注</td></tr></tbody></table><p>上面这些快捷键只需要对着界面输入然后按下空格(或者回车)后就可以触发。</p><p>还有一点，就是我们要是按下空格就可以<code>重复上一个操作</code>，比如我c完一个圆后还想画一个圆，那就再按下空格，就可以直接再画一个圆。</p><h5 id="c圆"><a href="#c圆" class="headerlink" title="c圆"></a>c圆</h5><p>我们对着界面输入c然后空格后，光标处就会变成十字形，然后只需在图中点一下就可以圆出来：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827095700961.png" alt="圆形示例"></p><p>注意我们可以看到下面命令框告诉我们可以输入圆的半径，比如我们想让圆的半径为10mm，那我们就可以输入10然后空格，或者想要直径为10mm，那就要输入d+空格，然后再输入10。</p><p>我们可以用旁边的标记列操作看下是否是10mm：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827100931131.png" alt="标注检查"></p><p>注意这里只是用于检查，实际标注不能用和轮廓线一样颜色的线。</p><h5 id="l直线"><a href="#l直线" class="headerlink" title="l直线"></a>l直线</h5><p>这里注意我们画下直线的时候会出现两个标注：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827104750508.png" alt="直线示例"></p><p>长度和角度可以用tab键来切换输入(如果没有这两个框是没有点开正交模式左边那个加号按钮)。</p><p>如果我们希望更方便操作角度我们可以开启下面的两个模式：</p><ul><li>正交模式 (f8)：点开后直线就是只能为直角(正交)状态。</li><li>极角模式 (f10)：可以设置角度，点开到相应角会有直线吸附。</li></ul><h5 id="e清除"><a href="#e清除" class="headerlink" title="e清除"></a>e清除</h5><p>这个很好理解，我们只需要选中需要被删除的线段，按下e+空格即可。</p><h5 id="co复制"><a href="#co复制" class="headerlink" title="co复制"></a>co复制</h5><p>我们co完后指令框显示：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827102741699.png" alt="注意指令框"></p><p>也就是告诉我们需要选中对象。比如我像copy一个圆，那我选择这个圆后，再按下空格，然后出现：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827102858555.png" alt="copy一下"></p><p>告诉我们寻找基准线，我以点圆的中心为例。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827103508094.png" alt="找到中心线后移动"></p><p>可以看到一个新圆已经被复制出来。</p><h5 id="m移动"><a href="#m移动" class="headerlink" title="m移动"></a>m移动</h5><p>移动跟复制同理，需要选中对象，然后确定基准点来移动。</p><h5 id="o偏移"><a href="#o偏移" class="headerlink" title="o偏移"></a>o偏移</h5><p>o+空格后出现下图</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827110346139.png" alt="指令框要求输入偏移距离"></p><p>当我们输入距离(比如8mm)，然后再空格，选中对象就可以了</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827110523011.png" alt="选中对象后就可以上下取偏移对象"></p><h5 id="ro旋转"><a href="#ro旋转" class="headerlink" title="ro旋转"></a>ro旋转</h5><p>和上一个一样，都是选中对象，然后选中基准点，再输入旋转角度。</p><h5 id="tr修剪"><a href="#tr修剪" class="headerlink" title="tr修剪"></a>tr修剪</h5><p>这个特殊点，比如我们要删除这段：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827111416454.png" alt="修剪删除"></p><p>我们就可以tr+两个空格(注意是两个空格)。然后就可以对这段点一下就可以删除了。</p><h5 id="ex延伸"><a href="#ex延伸" class="headerlink" title="ex延伸"></a>ex延伸</h5><p>这个需要选中两个对象，要求这两个对象是要有交点的，然后就可以延长一个对象直至相交。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827112258116.png" alt="光标放到上面的那个对象上就会延长至相交"></p><h5 id="f倒圆角、cha倒直角"><a href="#f倒圆角、cha倒直角" class="headerlink" title="f倒圆角、cha倒直角"></a>f倒圆角、cha倒直角</h5><p>倒角只需要我们输入f + r(倒角半径)，然后再指定两个对象即可。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827214628990.png" alt="两条边选中"></p><h5 id="dli正交直线标注"><a href="#dli正交直线标注" class="headerlink" title="dli正交直线标注"></a>dli正交直线标注</h5><p>也就是直线注释，这里注意是正交线，如果是斜线的话要输入dal。</p><h3 id="螺纹孔标注"><a href="#螺纹孔标注" class="headerlink" title="螺纹孔标注"></a>螺纹孔标注</h3><p>这里附上一张实习用到的表：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9479b108140e2595cbfb66b28cb0356.jpg" alt="螺纹标注表"></p><p>我们可以看到不同螺纹孔大小都是有标准的螺纹距离和深度的。比如我们想话一个M6的螺纹孔，我们要这样画：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827224311227.png" alt="注意图中内容"></p><p>由于螺纹只有长度的，因此我们在画实际钻孔时要减去螺纹的长度。注意图中标注的细节，这些可以在图层里设置，方便我们选用：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827225254858.png" alt="图层设置"></p><h3 id="阴影标注"><a href="#阴影标注" class="headerlink" title="阴影标注"></a>阴影标注</h3><p>找到左边列的打圈处，选中。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827225418023.png" alt="通过上图步骤选取"></p><p>点击“添加：拾取点”就可以选择需要阴影的位置了，选择成功再空格选择比例、样例，点击确定即可。</p><h3 id="一圆与两圆相切"><a href="#一圆与两圆相切" class="headerlink" title="一圆与两圆相切"></a>一圆与两圆相切</h3><p>同样我们c+空格打开圆的快捷键，然后选择图中操作。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231016906.png" alt="输入t，空格"></p><p>然后选择圆中需要相切的两个位置，再输入圆的半径即可。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231150002.png" alt="相切后的样子"></p><h3 id="块创建"><a href="#块创建" class="headerlink" title="块创建"></a>块创建</h3><p>块说白了就是自己写一个模板然后方便下次直接用。</p><p>比如我随便画一个矩形想作为块：</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231640651.png" alt="点击创建"></p><p>我们可以点开绘画然后找到块创建</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231731280.png" alt="输入名称"></p><p>然后就可以输入名称保存了，需要时就i + 空格换出块就行了。</p><p><img src="/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240827231826164.png" alt="按i唤出"></p><p>实际运用中比如这个粗糙度的标注符号在cad里是没有的，那就可以自己画一个然后创建块，方便后续使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>制图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/08/21/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/08/21/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><code>KMP:一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。——某位哲学大师(雾)</code></p><p>上面这句话很直观的体现了kmp算法的一个重要的特点：前后缀比较。比如我们看下面这道例题：</p><h4 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a>找出字符串中第一个匹配项的下标</h4><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;abxabcabcaby&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;abcaby&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-string">&quot;abcaby&quot;</span> 在下标 <span class="hljs-number">6</span> 处匹配。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;leeto&quot;</span><br>输出：-<span class="hljs-number">1</span><br>解释：<span class="hljs-string">&quot;leeto&quot;</span> 没有在 <span class="hljs-string">&quot;leetcode&quot;</span> 中出现，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h4 id="普通暴力解法"><a href="#普通暴力解法" class="headerlink" title="普通暴力解法"></a>普通暴力解法</h4><p>最直观的解法就是双循环，把haystack里面的字符都遍历一遍，然后再看这个字符后面是不是和needle匹配的，要是有不匹配的，直接break。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果 needle 是空字符串，则返回 0</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack.length() &lt; needle.length()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果 haystack 比 needle 短，则不能包含 needle</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; needle.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果字符不匹配，退出内层循环</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == needle.length()) &#123;<br>                <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 如果完整匹配，返回起始位置</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果没有找到 needle，返回 -1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里套了双层循环，假设m&#x3D;haystack.length() - needle.length() ,n&#x3D;needle.length()那么时间复杂度是O(mn)。但是如果我们使用kmp算法，就可以让时间复杂度控制到O(m+n)。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们想想当在字符串比较的时候，什么操作是多余的操作？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">text:</span> abxabcabcaby<br><span class="hljs-symbol">pattern:</span> abcaby<br></code></pre></td></tr></table></figure><p>以上述例子比较的时候可以发现：在text的[3:7]部分是和pattern[0:4]部分是重合的，由于最后一个y和text中的下一个c没对上，所以没有配对成功，但是在pattern这部分前面的[0:4]中前缀”ab”和后缀的”ab”是一样的，说明我们只需要重新比较text中[6:7]这个”ab”后面的与pattern[0:1]这个”ab”后面的即可，不用再重新比较”ab”。这样就可以优化算法。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/image-20240818132338112.png" alt="text中划线后缀和pattern中划线后缀是一样的"></p><h4 id="next表"><a href="#next表" class="headerlink" title="next表"></a>next表</h4><p>为了方便我们这样索引，我们将要建立一个next表，里面记录的是由后缀到前缀的索引值，也就是说当我们匹对字符串的时候，如果发现不对，那只需要通过索引值跳到需要比较的部分。</p><h5 id="建立思路"><a href="#建立思路" class="headerlink" title="建立思路"></a>建立思路</h5><p>首先我们给pattern字符串前面加上一个哨兵空字符，为什么要加这个呢？这里是由于之后我们比较的时候如果指针指的字符不匹配，那么我们就要找到指针前面那个字符的所对应的索引值，如果我们加上一个哨兵，那就可以每次不用指针减一，直接j就可以(有点拗口，之后看图会清楚点)。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/5ea9a4c4974af0f3bfd2860137c9b31.jpg" alt="初始状态，j+1指的字符不等于i，next[i]给0"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/c1b9f0ef796f237139fda9b1dc4177e.jpg" alt="由于两边不相等，i往前一位，j不往前"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/867ec80f42b7d7ee0a22629571dea4d.jpg" alt="现在i指向的字符和j+1指向的字符一样了"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/ef8c3230441c40e1d04d46f0d4cf555.jpg" alt="将next表中i指向的位置改成此时j的索引"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/0114a52dce83bfe8c3cc426a488be4a.jpg" alt="此时也是同上图一样两边的字符相等，改变next的值为j的索引值"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/4815ae5faf90986adbefa40013cf8b0.jpg" alt="给next赋值"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b5a2da634d9a40d193aff64c44fba2d.jpg" alt="j和i都向下移一位"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b5a2da634d9a40d193aff64c44fba2d.jpg" alt="发现j+1和i指向的字符不相等了"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/f873a65d6d109c53abd7bd20c67fc85.jpg" alt="然后j再通过其索引向前找有没有字符和i所指的是一样的"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/d3a97e6f3b75d2237737ff12a6930c6.jpg" alt="没有找到，于是就给next赋值0"></p><p>以上就是next表创建的手画过程，用代码来写就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>, j=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//p就是pattern的缩写，通过toCharArray()来变成字符数组</span><br>    <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; p[j+<span class="hljs-number">1</span>] != p[i]) j = next[j]; <span class="hljs-comment">//如果对不上，就让j不断往前找，直到找到能对上的数</span><br>    <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>] == p[i]) j++; <span class="hljs-comment">//如果对上了，就让j向后移动一位</span><br>    next[i] = j; <span class="hljs-comment">//next赋值操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到i就是从2开始的，所以我在途中所以为1的地方就没有写值。</p><h4 id="与字符串开始匹配"><a href="#与字符串开始匹配" class="headerlink" title="与字符串开始匹配"></a>与字符串开始匹配</h4><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b0db22bdf54f12abba917367f855d3f.jpg" alt="第一个字符进行比较(true)"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/b1f333d3ecb0f0810828f7c7fa57b32.jpg" alt="与第二个字符比较(true)"></p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/8092a397846b7d90c5e5b677e0ed5b6.jpg" alt="&quot;c&quot;与&quot;x&quot;比较不上，j往后移动"></p><p>这里发现无法匹配后就直接通过b的前一个字符(a)的索引来向前找有没有为”x”的字符(然而没有)，于是j就停在哨兵字符上。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/af9bfccf12aadc677e04a209f112daf.jpg" alt="&quot;a&quot;与&quot;x&quot;不符"></p><p>发现不符，j不动(因为j已经是最上面了，找不上去了)，text中的字符再往后面找。然后重复上面的步骤不停往后比对。最后发现”y”和⑥的”c”不符，于是乎j就往下找(此时j下面的索引为2，因此j跳到”b”上，j+1为”c”)，此时我们就只需要比较”c”和text后面的值了(因为我们知到了”ab”肯定是一样的，不用再比较了)。</p><p><img src="/2024/08/21/KMP%E7%AE%97%E6%B3%95/2d208ae8221ec635341772e53d489e1.jpg" alt="&quot;c&quot;与后面的值作比较"></p><p>这一步就是kmp算法的核心，有了上面这个思路我们就可以解决上面的例题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String ss, String pp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pp.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ss.length(), m = pp.length(); <span class="hljs-comment">//注意长度的取值是在加入哨兵之前的</span><br>        ss = <span class="hljs-string">&quot; &quot;</span> + ss; <span class="hljs-comment">//加入哨兵</span><br>        pp = <span class="hljs-string">&quot; &quot;</span> + pp;<br>        <span class="hljs-type">char</span>[] s = ss.toCharArray(); <br>        <span class="hljs-type">char</span>[] p = pp.toCharArray();<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>]; <span class="hljs-comment">//创建next表</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>, j=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//填写next表</span><br>            <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; p[j+<span class="hljs-number">1</span>] != p[i]) j = next[j]; <span class="hljs-comment">//找不到的情况，让&quot;j&quot;往前找</span><br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>] == p[i]) j++; <span class="hljs-comment">//核对成功&quot;j&quot;往前走</span><br>            next[i] = j; <span class="hljs-comment">//将目前这个下标的值改成此时&quot;j&quot;的值</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//核对字符</span><br>            <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = next[j]; <span class="hljs-comment">//找不到的情况，让&quot;j&quot;往前找</span><br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>] == s[i]) j++; <span class="hljs-comment">//核对成功往前走</span><br>            <span class="hljs-keyword">if</span>(j == m)&#123; <span class="hljs-comment">//长度相等就return</span><br>                <span class="hljs-keyword">return</span> i - m; <span class="hljs-comment">//输出第一个元素下标</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static静态标签</title>
    <link href="/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/"/>
    <url>/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h3><p>我们都知道在测试文件中都需要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br></code></pre></td></tr></table></figure><p>这段文字，而文字中public void main这几个我都已经数值，但是这个static是什么意思呢？今天我们来一起探讨一下这个词语。</p><h4 id="属性静态调用"><a href="#属性静态调用" class="headerlink" title="属性静态调用"></a>属性静态调用</h4><p>当我们遇到不同的成员需要有相同的属性的时候，为了方便同时输入和调用属性，我们引入了static(静态)修饰符：</p><p>user:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">user</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String tea;  <span class="hljs-comment">//static修饰tea这个变量</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">user</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>test:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-number">123</span>);<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;ye&quot;</span>,<span class="hljs-number">11</span>);<br>        user.tea = <span class="hljs-string">&quot;black tea&quot;</span>;  <span class="hljs-comment">//直接对类进行调取</span><br>        System.out.println(u2.tea);  <span class="hljs-comment">//black tea</span><br>        System.out.println(u1.tea);  <span class="hljs-comment">//black tea</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到当我们给tea用static修饰了之后，在test文件中我们就可以直接用类来进行赋值而不需要用成员来赋值，并且赋值后每个成员所访问的值都是一样的。被static所修饰的成员变量叫做静态变量，它有这三个特点：</p><ul><li>被该类所有对象共享</li><li>不属于对象，属于类</li><li>随着类的加载而加载，优先于对象的存在</li></ul><p>当然被static修饰的成员方法，叫做静态方法，它有这些特点：</p><ul><li>多用在测试类和工具类中</li><li>Javabean类中很少会用到</li></ul><p>这里我们就可以讨论到工具类的创建。</p><h4 id="工具类创建"><a href="#工具类创建" class="headerlink" title="工具类创建"></a>工具类创建</h4><p>创建一个工具类，首先我们要将其私有化，这样外部就不会创建这个类的对象了(因为我们这个要让这个类作为工具，那我们就要写死在这里了，不能再让别人有所操作，不然工具变化会带来不便)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrUtil</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">arrUtil</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写一个工具类的例子：</p><p>ArrUtil: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;  <span class="hljs-comment">//集合list</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ArrUtil</span><span class="hljs-params">()</span>&#123;&#125;; <span class="hljs-comment">//工具类私有化</span><br>    <br><span class="hljs-comment">//设置为静态方便调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123; <span class="hljs-comment">//计算数组所有数据和</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            sum = sum + arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_num_sum</span><span class="hljs-params">(ArrayList&lt;user&gt; list)</span>&#123;  <span class="hljs-comment">//计算集合中所有对象的num属性和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            sum = sum + list.get(i).getNumber();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>test:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        System.out.println(ArrUtil.get_sum(a)); <span class="hljs-comment">//输出数组的数字和</span><br><br>        ArrayList&lt;user&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//这是个集合</span><br>        <span class="hljs-type">user</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;ye&quot;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;yee&quot;</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">user</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">user</span>(<span class="hljs-string">&quot;yeee&quot;</span>,<span class="hljs-number">12</span>);<br><br>        list.add(u1); <span class="hljs-comment">//对象压入集合</span><br>        list.add(u2);<br>        list.add(u3);<br><br>        System.out.println(ArrUtil.get_num_sum(list)); <span class="hljs-comment">//输出集合中num的和</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到可以直接通过 类名.方法名() 来调用工具。</p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>其实，static有这几个注意事项：</p><ul><li>静态方法中，只能访问静态</li><li>非静态方法可以访问所有</li><li>静态方法中没有this关键字</li></ul><p>而这几个关键都和this关键字有关。以下我来举一些例子。</p><p>test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">methods_class</span> <span class="hljs-variable">pj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">methods_class</span>();<br>        pj.repeat();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>methods_class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d9_static;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">methods_class</span> &#123;<br><br>    String s;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repeat</span><span class="hljs-params">(methods_class <span class="hljs-built_in">this</span>)</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//输出com.bayeeaa.demo1.d9_static.methods_class@b4c966a</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">again</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//飘红，静态方法中没有this</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我在methods_class文件中输出了两个方法，一个是非静态方法，一个是静态方法，当我们分别用test文件来打印的时候会发现第一个repeat方法打印出了对象的地址，而第二个again方法会报错。</p><p><img src="/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/image-20240814091753742.png" alt="Build Output"></p><p>在我们平时使用非静态方法应该是不会在非静态方法中手动调入methods_class this这个值的，但是我们却可以直接用方法调用，这是因为在非静态方法中是默认包括this的，而this的赋值又由jvm调取。所以说在非静态方法中如果我们要调用参数，比如num，实际上应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repeat</span><span class="hljs-params">(methods_class <span class="hljs-built_in">this</span>)</span>&#123;<br>    System.out.println(<span class="hljs-built_in">this</span>.s);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是通过上图的报错我们可以看到静态方法中是没有this的。因此在其中要是强行引入this会导致报错。</p><p>有了这样的解释就可以理解上面的三个结论了。</p><h4 id="内存解释"><a href="#内存解释" class="headerlink" title="内存解释"></a>内存解释</h4><p>在作内存解释之前我们要知道：</p><h5 id="栈内存（Stack-Memory）"><a href="#栈内存（Stack-Memory）" class="headerlink" title="栈内存（Stack Memory）"></a>栈内存（Stack Memory）</h5><ol><li><strong>结构和管理方式</strong>：<ul><li>栈内存按照先进后出的原则进行管理（LIFO，即 Last In, First Out）。</li><li>内存分配和回收由系统自动管理。每当一个函数被调用时，系统会在栈上为其分配内存，函数返回时，这部分内存会被自动释放。</li></ul></li><li><strong>用途</strong>：<ul><li>用于存储局部变量、函数调用参数和返回地址等。</li><li>栈内存的管理非常高效，因为内存分配和释放的操作非常简单，只需调整栈顶指针即可。</li></ul></li><li><strong>特点</strong>：<ul><li>内存分配速度快。</li><li>栈内存的大小通常较小，固定大小，超过限制会导致栈溢出（stack overflow）。</li><li>数据的生命周期由函数调用的生命周期决定，一旦函数返回，栈内存中的数据就会失效。</li></ul></li></ol><h4 id="堆内存（Heap-Memory）"><a href="#堆内存（Heap-Memory）" class="headerlink" title="堆内存（Heap Memory）"></a>堆内存（Heap Memory）</h4><ol><li><strong>结构和管理方式</strong>：<ul><li>堆内存没有固定的管理顺序，分配和释放内存是由程序员或垃圾回收机制管理的。</li><li>内存的分配和释放可以发生在程序的任何地方，不像栈内存那样有固定的顺序。</li></ul></li><li><strong>用途</strong>：<ul><li>用于动态分配内存，比如创建对象、数组等，需要程序员显式地请求内存空间。</li><li>适用于需要在多个函数调用间共享数据的情况。</li></ul></li><li><strong>特点</strong>：<ul><li>内存分配和释放相对较慢，因为涉及到更复杂的管理机制。</li><li>堆内存的大小通常较大，由操作系统和系统配置决定。</li><li>需要程序员显式管理内存，未正确释放的内存会导致内存泄漏（memory leak），一些语言如 Java 和 Python 使用垃圾回收机制来自动处理这一问题。</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>栈内存</strong>适用于存储生命周期短、大小固定的数据，管理简单且高效。</li><li><strong>堆内存</strong>适用于存储生命周期长或大小不确定的数据，管理复杂但灵活。</li></ul><p>我们可以简单的将内存划为三个区域：</p><p><img src="/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/image-20240814100802874.png" alt="内存解释"></p><p>字节文件加载：引入main文件，加载里面的方法、类文件中的属性、静态属性等等。</p><p>然后开始创建对象，在堆内存中开辟一块地，并返回其地址给对象pj。</p><p>然后pj就可以根据地址去寻找所要找的元素。</p><h4 id="main的解释"><a href="#main的解释" class="headerlink" title="main的解释"></a>main的解释</h4><p>现在我们再来看下我们每次的入口文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br></code></pre></td></tr></table></figure><ul><li>public： 被JVM调用，访问权限足够大</li><li>static：被JVM调用，不用创建对象，直接类名访问。因为main方法是静态的，所以测试类中其他方法也需要是静态的。(这里注意下,不是静态的叫实例变量,非static方法需要new一个实例出来才能使用,这里意思是main默认只能调用静态方法,实例要new)</li><li>void：被JVM调用，不需要给JVM返回值</li><li>main：一个通用的名称，虽然不是关键字，但是被JVM识别</li><li>String[] args：以前用于接收键盘录入数据的，现在没有，被保留是为了上下版本兼容</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象编程封装</title>
    <link href="/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/"/>
    <url>/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程封装"><a href="#面向对象编程封装" class="headerlink" title="面向对象编程封装"></a>面向对象编程封装</h2><p>我们先从最简单的一个对象设置开始，设置一个phone对象，并赋予里面brand和number，为了进行比对，我让number私有化，而让brand变成public。</p><p>主入口文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newphone</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">phone</span>(); <span class="hljs-comment">//通过：类名 对象名 = new 类名()来自定义对象</span><br>        p.brand = <span class="hljs-string">&quot;小米&quot;</span>; <span class="hljs-comment">//这里为了形成对比没有让brand私有化</span><br>        p.setNumber(<span class="hljs-number">20</span>);<br>        System.out.println(p.getNumber());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number; <span class="hljs-comment">//private使这个number私有化，让其更改操作只能在本类中实现</span><br>    String brand;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//这里方便输出内容</span><br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123; <span class="hljs-comment">//通过方法使对象值在本函数中实现改变，函数名最好用set+双驼峰写法</span><br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">18</span> &amp;&amp; n&lt;<span class="hljs-number">50</span>)&#123;<br>            number = n;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;输入不被允许&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机在打电话&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到当number被私有化后，其值的修改就只能在类文件中发送，这样可以提高文件的安全性，我们只要通过调用getNumber和setNumber函数就可以实现值的传递并修改。</p><h3 id="两种不同的构造方式"><a href="#两种不同的构造方式" class="headerlink" title="两种不同的构造方式"></a>两种不同的构造方式</h3><h4 id="空参构造："><a href="#空参构造：" class="headerlink" title="空参构造："></a>空参构造：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">phone</span><span class="hljs-params">()</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>不带任何的参数。</p><h4 id="有参构造："><a href="#有参构造：" class="headerlink" title="有参构造："></a>有参构造：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">phone</span><span class="hljs-params">(String brand,<span class="hljs-type">int</span> number)</span>&#123;<br><span class="hljs-built_in">this</span>.brand = brand;   <span class="hljs-comment">//this.brand指的是类中的brand，是成员变量。右边的brand是方法里的局部变量(this遵循就近原则)</span><br><span class="hljs-built_in">this</span>.number = number;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的方法不带void或int等，没有return，是由于它的执行是由jvm调动的，所以主函数调用时候就会执行，无需手动执行。</p><p>主函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">phone</span>(<span class="hljs-string">&quot;小米&quot;</span>,<span class="hljs-number">20</span>);  <span class="hljs-comment">//有参函数直接可以传入数据</span><br></code></pre></td></tr></table></figure><p>这样就可以直接传入参数。</p><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br><span class="hljs-comment">// alt + INSERT就可以帮我们快速生成constructer和set,get函数</span><br>    <span class="hljs-comment">// ptg插件也可以帮我们快速构造JAVABEAN</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="alt-INSERT"><a href="#alt-INSERT" class="headerlink" title="alt + INSERT"></a>alt + INSERT</h4><p><img src="/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/image-20240804144657153.png" alt="键盘快捷键"></p><h4 id="ptg"><a href="#ptg" class="headerlink" title="ptg"></a>ptg</h4><p>这个方法需要在setting中下载ptg插件。</p><p><img src="/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/image-20240804144733984.png" alt="ptg"></p><p>通过快捷键我们可以快速的进行javabean构造。</p><h3 id="文字游戏的简单应用"><a href="#文字游戏的简单应用" class="headerlink" title="文字游戏的简单应用"></a>文字游戏的简单应用</h3><p>我们可以设置一个文字游戏，通过血量，攻击力等为对象创建属性，然后循环攻击最后输出结果。</p><p>类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d3; <span class="hljs-comment">//这里是package，不是import,这是类文件和主入口文件的区别</span><br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> blood;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    String[] attack_desc = &#123;<br>        <span class="hljs-string">&quot;虚弱地&quot;</span>, <span class="hljs-comment">//1~5</span><br>        <span class="hljs-string">&quot;小心地&quot;</span>, <span class="hljs-comment">//6~10</span><br>        <span class="hljs-string">&quot;用力地&quot;</span>, <span class="hljs-comment">//10~20</span><br>    &#125;;<br><br>    String[] injureds_desc = &#123;<br>        <span class="hljs-string">&quot;他似乎自信满满&quot;</span>, <span class="hljs-comment">//HP 100~80</span><br>        <span class="hljs-string">&quot;他认为还有胜算&quot;</span>, <span class="hljs-comment">//HP 79~50</span><br>        <span class="hljs-string">&quot;他还不肯认输&quot;</span>, <span class="hljs-comment">//HP 49~20</span><br>        <span class="hljs-string">&quot;他疲惫不堪&quot;</span> <span class="hljs-comment">//HP 20~0</span><br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Role</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Role</span><span class="hljs-params">(<span class="hljs-type">int</span> blood, String name)</span> &#123; <span class="hljs-comment">//有参构造</span><br>        <span class="hljs-built_in">this</span>.blood = blood; <span class="hljs-comment">//this所表示的就是这个对象的值</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBlood</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//得到血量</span><br>        <span class="hljs-keyword">return</span> blood;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlood</span><span class="hljs-params">(<span class="hljs-type">int</span> blood)</span> &#123; <span class="hljs-comment">//设置血量</span><br>        <span class="hljs-built_in">this</span>.blood = blood;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_attack_desc</span><span class="hljs-params">(<span class="hljs-type">int</span> hurt)</span> &#123; <span class="hljs-comment">//要注意这里函数最后无论如何都是要return 0的</span><br>        <span class="hljs-keyword">if</span>(hurt&lt;=<span class="hljs-number">5</span> &amp;&amp; hurt&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hurt&lt;=<span class="hljs-number">10</span> &amp;&amp; hurt&gt;<span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hurt&lt;=<span class="hljs-number">20</span> &amp;&amp; hurt&gt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_injureds_desc</span><span class="hljs-params">(<span class="hljs-type">int</span> remain)</span> &#123;<br>        <span class="hljs-keyword">if</span>(remain&lt;=<span class="hljs-number">100</span> &amp;&amp; remain&gt;=<span class="hljs-number">80</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(remain&lt;<span class="hljs-number">80</span> &amp;&amp; remain&gt;=<span class="hljs-number">50</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(remain&lt;<span class="hljs-number">50</span> &amp;&amp; remain&gt;=<span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(remain&lt;<span class="hljs-number">20</span> &amp;&amp; remain&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(Role role)</span>&#123; <span class="hljs-comment">//Role赋予role这个变量意义，也就是变成了对象</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hurt</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">20</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainblood</span> <span class="hljs-operator">=</span> role.getBlood() - hurt;<br>        remainblood = remainblood &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : remainblood; <span class="hljs-comment">//三元判断，&quot;?&quot;左边为结果，true就是左边的，false为右边</span><br>        role.setBlood(remainblood);<br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + attack_desc[get_attack_desc(hurt)] + <span class="hljs-string">&quot;打了&quot;</span> + role.getName() + <span class="hljs-string">&quot;&quot;</span> + hurt + <span class="hljs-string">&quot;点血，&quot;</span> + role.getName() +<span class="hljs-string">&quot;还剩&quot;</span> + role.getBlood() + <span class="hljs-string">&quot;，&quot;</span> + injureds_desc[get_injureds_desc(remainblood)]);<br>        <span class="hljs-comment">//this为调用对象，这里的role就是调入参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bayeeaa.demo1.d3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Role</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;500c&quot;</span>);<br>        <span class="hljs-type">Role</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;joker&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            r1.attack(r2);<br>            <span class="hljs-keyword">if</span>(r2.getBlood() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(r1.getName() + <span class="hljs-string">&quot; Win&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            r2.attack(r1);<br>            <span class="hljs-keyword">if</span>(r1.getBlood() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(r2.getName() + <span class="hljs-string">&quot; Win&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中一次运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">500c</span>用力地打了joker11点血，joker还剩<span class="hljs-number">89</span>，他似乎自信满满<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c16点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">84</span>，他似乎自信满满<br><span class="hljs-attribute">500c</span>虚弱地打了joker4点血，joker还剩<span class="hljs-number">85</span>，他似乎自信满满<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c17点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">67</span>，他认为还有胜算<br><span class="hljs-attribute">500c</span>虚弱地打了joker4点血，joker还剩<span class="hljs-number">81</span>，他似乎自信满满<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c16点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">51</span>，他认为还有胜算<br><span class="hljs-attribute">500c</span>小心地打了joker7点血，joker还剩<span class="hljs-number">74</span>，他认为还有胜算<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c19点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">32</span>，他还不肯认输<br><span class="hljs-attribute">500c</span>用力地打了joker17点血，joker还剩<span class="hljs-number">57</span>，他认为还有胜算<br><span class="hljs-attribute">joker</span>虚弱地打了<span class="hljs-number">500</span>c4点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">28</span>，他还不肯认输<br><span class="hljs-attribute">500c</span>小心地打了joker10点血，joker还剩<span class="hljs-number">47</span>，他还不肯认输<br><span class="hljs-attribute">joker</span>虚弱地打了<span class="hljs-number">500</span>c1点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">27</span>，他还不肯认输<br><span class="hljs-attribute">500c</span>用力地打了joker19点血，joker还剩<span class="hljs-number">28</span>，他还不肯认输<br><span class="hljs-attribute">joker</span>用力地打了<span class="hljs-number">500</span>c16点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">11</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span>小心地打了joker7点血，joker还剩<span class="hljs-number">21</span>，他还不肯认输<br><span class="hljs-attribute">joker</span>虚弱地打了<span class="hljs-number">500</span>c2点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">9</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span>虚弱地打了joker5点血，joker还剩<span class="hljs-number">16</span>，他疲惫不堪<br><span class="hljs-attribute">joker</span>小心地打了<span class="hljs-number">500</span>c8点血，<span class="hljs-number">500</span>c还剩<span class="hljs-number">1</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span>用力地打了joker17点血，joker还剩<span class="hljs-number">0</span>，他疲惫不堪<br><span class="hljs-attribute">500c</span> Win<br><br><span class="hljs-attribute">Process</span> finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到我在类文件中先是设置了name和blood两个参数，而其攻击值是随机生成的。我也在类函数中加入了attack_desc和injureds_desc两个字符串数组来形容当前两人的状态。具体解释看代码中的注释。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的生命周期</title>
    <link href="/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p>通俗的讲就是：一个vue实例从创建到销毁的整个过程</p><p>①创建(响应式数据) ②挂载(渲染模板) ③更新(修改数据更新视图) ④销毁(关闭页面,销毁实例)</p><h3 id="Vue生命周期函数"><a href="#Vue生命周期函数" class="headerlink" title="Vue生命周期函数"></a>Vue生命周期函数</h3><ol><li><strong>创建阶段（Creation）</strong>：<ul><li>beforeCreate：实例刚被创建，数据观测和事件机制初始化之前被调用。</li><li>created：实例已经创建完成，完成数据观测、属性和方法的运算，初始化事件等。</li></ul></li><li><strong>挂载阶段（Mounting）</strong>：<ul><li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>mounted：实例已经挂载到 DOM 上后被调用。</li></ul></li><li><strong>更新阶段（Updating）</strong>：<ul><li>beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li><li>updated：数据更新后调用，发生在虚拟 DOM 重新渲染和打补丁之后。</li></ul></li><li><strong>销毁阶段（Destroying）</strong>：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：实例销毁后调用。在这一步，所有事件监听器被移除，所有子实例被销毁。</li></ul></li><li><strong>错误处理阶段（Error Handling）</strong>：<ul><li>errorCaptured：当子组件抛出错误时会触发该钩子。</li></ul></li></ol><p>为了深入的理解这段话，我们要知道什么是<code>实例</code></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在 Vue.js 中，”实例”（Instance）是指通过 Vue 构造函数创建的一个 Vue 实例对象。每个 Vue 应用都是通过创建一个 Vue 实例来实现的。当您使用 Vue 构造函数创建一个实例时，您可以传入一个选项对象，用于配置该实例的行为。</p><p>在 Vue 实例中，您可以定义数据、计算属性、方法、生命周期钩子函数等。这些属性和方法定义了该实例的行为和功能。Vue 实例还可以与 DOM 元素进行绑定，从而实现数据的双向绑定、事件处理等功能。</p><p>下面是一个简单的示例，演示了如何创建一个 Vue 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 Vue 实例</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-comment">// 选项对象</span><br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>, <span class="hljs-comment">// 指定要挂载的元素</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Vue 实例已创建&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个 Vue 实例 <code>vm</code>，并传入了一个选项对象，其中包含了 <code>el</code>、<code>data</code>、<code>methods</code> 和 <code>created</code> 等属性。这个实例可以通过 <code>vm</code> 来访问，并且可以调用定义的方法、访问数据等。</p><h3 id="Vue3-Composition-API"><a href="#Vue3-Composition-API" class="headerlink" title="Vue3 Composition API"></a>Vue3 Composition API</h3><p>进入到vue3后，组合式API大为推广，在这其中的生命钩子函数有了更灵活的运用，有了这样的变化：</p><ol><li><code>onBeforeMount</code>: 在组件挂载之前执行的函数，类似于 Vue 2.x 中的 <code>beforeMount</code> 钩子函数。</li><li><code>onMounted</code>: 在组件挂载到 DOM 后执行的函数，类似于 Vue 2.x 中的 <code>mounted</code> 钩子函数。</li><li><code>onBeforeUpdate</code>: 在组件更新之前执行的函数，类似于 Vue 2.x 中的 <code>beforeUpdate</code> 钩子函数。</li><li><code>onUpdated</code>: 在组件更新完成后执行的函数，类似于 Vue 2.x 中的 <code>updated</code> 钩子函数。</li><li><code>onBeforeUnmount</code>: 在组件卸载之前执行的函数，类似于 Vue 2.x 中的 <code>beforeUnmount</code> 钩子函数。</li><li><code>onUnmounted</code>: 在组件卸载后执行的函数，类似于 Vue 2.x 中的 <code>unmounted</code> 钩子函数。</li><li><code>onActivated</code>: 在组件被激活时执行的函数，用于配合 <code>&lt;keep-alive&gt;</code> 组件使用。</li><li><code>onDeactivated</code>: 在组件被停用时执行的函数，用于配合 <code>&lt;keep-alive&gt;</code> 组件使用。</li><li><code>onErrorCaptured</code>: 捕获子组件抛出的错误，类似于 Vue 2.x 中的 <code>errorCaptured</code> 钩子函数。</li></ol><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们分两组进行演示，分别是onBeforeMount和onMounted，onBeforeUpdate和onUpdated。其中用到比较多的就是Mounted这组。</p><p><img src="/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><h4 id="onMounted"><a href="#onMounted" class="headerlink" title="onMounted"></a>onMounted</h4><p>我们输入以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; onMounted, onBeforeMount &#125; from &#x27;vue&#x27;<br>const title = &#x27;hello&#x27;<br><br>onBeforeMount(() =&gt; &#123;<br>  console.log(&quot;onBeforeMount: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //undefined<br>&#125;)<br><br>onMounted(() =&gt; &#123;<br>  console.log(&quot;onMounted: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //hello<br>&#125;)<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>我们可以看到我们分别让两个生命周期函数打印出此时的值，可以看到注释里的结果，在onBeforeMount，也就是实例还挂载到DOM上，此时还没有开始渲染因此式undefined，在onMounted里，hello被打印了出来，说明此时已经完成了渲染，可以操作DOM了。因此我们平时都习惯将网页进入时就需要触发的函数放在onMounted里，防止函数无法准确获取到DOM元素。</p><h4 id="onUpdated"><a href="#onUpdated" class="headerlink" title="onUpdated"></a>onUpdated</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;&#123;&#123; count &#125;&#125;&lt;/h2&gt;&lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; onBeforeUpdate, onUpdated, ref &#125; from &#x27;vue&#x27;<br>let count = ref(1)<br><br>onBeforeUpdate(() =&gt; &#123;<br>  console.log(&quot;onBeforeUpdate&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML) //1<br>&#125;)<br><br>onUpdated(() =&gt; &#123;<br>  console.log(&quot;onUpdated&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML); //2<br>&#125;)<br><br>const add = () =&gt; &#123;<br>  count.value++  <br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>可以看到这里就是差异在内部数据更改和视图更新的区别，在onBeforeUpdate时数据并没有发生更新，而在onUpdated数据发生了更新并且可以显示出来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用时出现的问题小汇总</title>
    <link href="/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/"/>
    <url>/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="git提交"><a href="#git提交" class="headerlink" title="git提交"></a>git提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add * //将所有上传文件进入缓存区域<br>git commit -m <span class="hljs-string">&quot;submit&quot;</span> //提交申请注释，双引号里面就是注释内容<br>(*) git remote add origin https //关联远程仓库，关联后以后就可以不再重复关联<br>git push -u origin main //推入仓库main分支<br></code></pre></td></tr></table></figure><h4 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h4><p>在 <code>git commit</code> 命令中，<code>-m</code> 选项用于指定提交消息。Git 提交时需要一个消息来描述这次提交的目的或更改内容。使用 <code>-m</code> 选项可以让你在命令行中直接输入提交消息，而不是打开编辑器。使用 <code>-m</code> 选项可以快速地提供提交消息。</p><p>如果你不使用 <code>-m</code> 选项，Git 会打开你配置的默认文本编辑器（例如 Vim、Nano 等），让你在编辑器中输入提交消息。这适用于较长或复杂的提交消息，允许你在编辑器中进行详细描述和格式化。</p><h4 id="u"><a href="#u" class="headerlink" title="-u"></a>-u</h4><p>在git push -u origin main中我们可以看到有个-u，-u 是–set-upstream的缩写。它的作用是将本地分支与远程分支建立跟踪关系。它有一下这几点作用：</p><ul><li>将本地分支与远程分支关联起来，使得以后可以简化 <code>git push</code> 和 <code>git pull</code> 命令的使用。</li><li>设置当前分支的上游分支（即跟踪的远程分支），方便在以后的操作中，Git 可以自动推送和拉取数据。</li></ul><h3 id="error-failed-to-push-some-refs-to-‘http’"><a href="#error-failed-to-push-some-refs-to-‘http’" class="headerlink" title="error: failed to push some refs to ‘http’"></a>error: failed to push some refs to ‘http’</h3><p><img src="/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/image-20240702172843116.png" alt="rror: failed to push some refs to &#39;http&#39;"></p><p>这个报错是指本地的文件和仓库中有冲突的部分，所以要先拉取github上的，然后再推上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin<br>git push origin main   (或者master)<br></code></pre></td></tr></table></figure><h3 id="error-src-refspec-main-does-not-match-any"><a href="#error-src-refspec-main-does-not-match-any" class="headerlink" title="error: src refspec main does not match any"></a>error: src refspec main does not match any</h3><p>由于是新创建的仓库还没有main分支(或者是你还没切换到这个分支上面)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b main   <br></code></pre></td></tr></table></figure><p>切换到当前分支main。</p><h3 id="如何将msater的内容合并到main分支，并删除master？"><a href="#如何将msater的内容合并到main分支，并删除master？" class="headerlink" title="如何将msater的内容合并到main分支，并删除master？"></a>如何将msater的内容合并到main分支，并删除master？</h3><p>要将 <code>master</code> 分支的内容合并到 <code>main</code> 分支，并删除 <code>master</code> 分支，你可以按照以下步骤进行操作。这些步骤假设你已经在本地仓库中，并且你希望在本地和远程仓库中同步这些更改。</p><ol><li><p><strong>切换到 <code>main</code> 分支</strong>： 确保你在 <code>main</code> 分支上，使用以下命令切换到 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure></li><li><p><strong>更新 <code>main</code> 分支</strong>： 确保 <code>main</code> 分支是最新的。如果你正在使用远程仓库，先拉取远程更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure></li><li><p>**合并 <code>master</code> 分支到 <code>main</code>**： 使用以下命令将 <code>master</code> 分支的内容合并到 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge master<br></code></pre></td></tr></table></figure><p>如果有合并冲突，Git 会提示你解决冲突。解决所有冲突后，完成合并并提交更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;conflicted-files&gt;<br>git commit<br></code></pre></td></tr></table></figure></li><li><p><strong>推送合并后的 <code>main</code> 分支到远程仓库</strong>： 将合并后的 <code>main</code> 分支推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure></li><li><p><strong>删除 <code>master</code> 分支</strong>：</p><ul><li><p><strong>在本地删除 <code>master</code> 分支</strong>： 确保你已经切换到 <code>main</code> 分支后，可以删除本地的 <code>master</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d master<br></code></pre></td></tr></table></figure><p>如果 <code>master</code> 分支没有完全合并到 <code>main</code>，而你确定要删除，可以使用 <code>-D</code> 强制删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D master<br></code></pre></td></tr></table></figure></li><li><p><strong>在远程删除 <code>master</code> 分支</strong>： 使用以下命令将 <code>master</code> 分支从远程仓库删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --delete master<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal: refusing to merge unrelated histories"></a>fatal: refusing to merge unrelated histories</h3><h4 id="表示-Git-拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下："><a href="#表示-Git-拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下：" class="headerlink" title="表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下："></a>表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下：</h4><ol><li><strong>两个分支或仓库的历史完全不同</strong>：<ul><li>比如，你尝试合并两个完全不同的项目，或者一个是新创建的仓库，另一个是老的仓库。</li></ul></li><li><strong>从远程仓库克隆时历史不同</strong>：<ul><li>如果你从一个远程仓库克隆了一个新的仓库，而本地仓库中已经有一些历史记录，Git 会认为这些历史不相关。</li></ul></li></ol><p>可以使用 <code>--allow-unrelated-histories</code> 选项来允许合并不相关的历史。以下是详细的步骤：</p><ol><li><p><strong>切换到 <code>main</code> 分支</strong>： 确保你在目标分支（通常是 <code>main</code> 分支）上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure></li><li><p><strong>执行合并命令并允许不相关的历史</strong>： 使用 <code>--allow-unrelated-histories</code> 选项来合并 <code>master</code> 分支到 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge master --allow-unrelated-histories<br></code></pre></td></tr></table></figure><p>这会允许 Git 合并两个没有共同历史的分支。</p></li><li><p><strong>解决合并冲突</strong>： 如果在合并过程中遇到冲突，Git 会提示你解决这些冲突。解决冲突后，完成合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;conflicted-files&gt;<br>git commit<br></code></pre></td></tr></table></figure></li><li><p><strong>推送合并后的 <code>main</code> 分支到远程仓库</strong>： 将合并后的 <code>main</code> 分支推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3+ts项目的基本路由配置</title>
    <link href="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="导入router"><a href="#导入router" class="headerlink" title="导入router"></a>导入router</h3><p>首先在main.ts文件中导入router，并将其use入app中让其挂载。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>;<br>app.<span class="hljs-title function_">use</span>(router)<br></code></pre></td></tr></table></figure><p>这样就可以在app中导入router了。</p><h3 id="路由文件index-ts配置"><a href="#路由文件index-ts配置" class="headerlink" title="路由文件index.ts配置"></a>路由文件index.ts配置</h3><p>为了更标准，我们在src文件中创立一个router文件夹，然后在文件夹中创建index.ts文件。</p><p>在index文件中，我们就可以将组件的路径记录到其中，这样就可以按照需要访问组件了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>           <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;shouye&#x27;</span><br>           <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/Home&#x27;</span> ,<br>           <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>        &#125;<br>    ]<br>&#125;)<br><br><span class="hljs-comment">//将router暴露出去(default 默认)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>我们先导入createRouter和createWebHistory(或createWebHashHistory)，然后再const一个router对象，里面存入history和routes。像这里我导入的是Home.vue组件，然后就可以在routes中写入path和component(path可以和组件的名字不一样，而且浏览器地址栏是不区分大小写的)。在router中history是必不可少的，其中有两种模式可以选择，我们这里选择createWebHistory。</p><p>最后不要忘记将router方法暴露出去。</p><p>这样我们就已经可以访问”&#x2F;home”组件了，但是我们的组件应该要配合layout来显示，具体放在页面的那个地方才合适呢？</p><h3 id="控制组件存放位置"><a href="#控制组件存放位置" class="headerlink" title="控制组件存放位置"></a>控制组件存放位置</h3><p>使用中存放组件的位置用RouterView标签，触发标签用RouterLink标签。</p><p>首先我们还是一样要在script中导入RouterView，RouterLink：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RouterView</span>, <span class="hljs-title class_">RouterLink</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br></code></pre></td></tr></table></figure><p>然后就可以在template中使用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div :style=&quot;&#123; padding: &#x27;24px&#x27;, background: &#x27;#fff&#x27;, minHeight: &#x27;600px&#x27; &#125;&quot;&gt;<br>  &lt;RouterView&gt;&lt;/RouterView&gt;          <br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>其中组件都会在RouterView的位置显示。而我们触发事件就要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/home&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>这里需要配合button等来配合使用。</p><p>当然考虑到地址的变化，也可以这样写RouterLink：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink :to=&quot;&#123;path:/home&#125;&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink :to=&quot;&#123;name:shouye&#125;&quot;&gt;  首页 &lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><h3 id="子路由配置"><a href="#子路由配置" class="headerlink" title="子路由配置"></a>子路由配置</h3><p>我们上面配置都是一级路由，而二级子路由要怎么配置呢？</p><p>首先我们找到index.ts文件，再里面添加children在path中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>           <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;shouye&#x27;</span>,<br>           <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/Home&#x27;</span> ,<br>           <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br>           <span class="hljs-attr">children</span>:[<br>            &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail&#x27;</span>, <span class="hljs-comment">//不要加斜杠</span><br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br>        &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后我们只需在RouterLink里面修改to的路径就可以了，也就是我们可以localhost&#x2F;home&#x2F;detail来访问子组件了。</p><h3 id="路由传参方法"><a href="#路由传参方法" class="headerlink" title="路由传参方法"></a>路由传参方法</h3><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>使用query传参我们需要在RouterLink的to中加入需要传入的值，比如我们想传给子组件“qq”一词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/detail?a=qq&amp;b=kk&quot;&gt;&lt;/RouterLink&gt;  <br></code></pre></td></tr></table></figure><p>可以看到我给子组件通过“路径?变量&#x3D;值”将值传递，然后在子组件中我们需要再导入router接收传递的信息，就可以使用了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">let</span> route = <span class="hljs-title function_">useRoute</span>()<br></code></pre></td></tr></table></figure><p>html:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; route.query.a &#125;&#125;<br></code></pre></td></tr></table></figure><p>这样就可以在页面中呈现了。</p><p>顺便我们log route一下就可以看到页面传递的值：</p><p><img src="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/image-20240719200614527.png" alt="query参数"></p><p>而如果我们需要通过for来改变传递的值，可以按照示例中这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink :to=&quot;`/detail?a=$&#123;shops.id&#125;`&quot;&gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink <br>  :to=&quot;&#123;<br>path:&#x27;/detail&#x27;                   <br>    query:&#123;<br>         a:shops.id,<br>        &#125;<br>    &#125;&quot;<br>  &gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>与query传参不同的是，params传参在index.ts中的path需要提前占位，在to中就可以对path中占的位对号入座。</p><p>比如我在path中用x占位：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:x?&#x27;</span>, <span class="hljs-comment">//这里的冒号表示占位，问号表示这个地方可能有展位也可能没有（问号不加也可以）</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br></code></pre></td></tr></table></figure><p>然后在template中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink to=&quot;/detail/aa&quot;&gt;<br>&lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>&lt;/RouterLink&gt;  <br></code></pre></td></tr></table></figure><p>再在子组件中console.log(route)一下就可以发现：</p><p><img src="/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/image-20240719214457064.png" alt="params参数"></p><p>最后用params接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; route.params.a &#125;&#125;<br></code></pre></td></tr></table></figure><p>然后同样可以用变量传递的方式传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt;<br>  &lt;RouterLink <br>  :to=&quot;&#123;<br>name:&#x27;xiangqing&#x27;                  <br>    query:&#123;<br>         a:shops.id,<br>        &#125;<br>    &#125;&quot;<br>  &gt;<br>    &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;<br>  &lt;/RouterLink&gt;  <br>&lt;/a-col&gt;<br></code></pre></td></tr></table></figure><p>但注意这里不能用path，只能用name来判断路径。</p><h3 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h3><h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h4><p>在路由配置中加上props:true，再在组件中加入defineProps([… , … ,])就可以将路由收到的params参数作为props传给组件。</p><p>子路由：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:id/:title/:content&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><span class="hljs-attr">props</span>:<span class="hljs-literal">true</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;title&#x27;</span>,<span class="hljs-string">&#x27;content&#x27;</span>])<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; id &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h4><p>也可以传递query参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/detail/:id/:title/:content&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br><span class="hljs-keyword">return</span> route.<span class="hljs-property">query</span><br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>query不用占位，params需要占位。</p><p>本节使用RouterLink标签进行跳转，其中to属性解释来添加跳转的位置，可以用对象的方法书写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite构建的项目“@”地址无法解析问题</title>
    <link href="/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用vite构建项目后，发现无法识别”@”地址：</p><p><img src="/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/image-20240719223909893.png" alt="报错提示"></p><p>经过排查是由于config文件中没有配置”@”对应的路径：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>打开vite.config.ts文件，改成：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)) <span class="hljs-comment">//这里的配置就是可以让@可以读取成&#x27;./src&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>中间的reslove的alias所包含的就是”@”的配置项，这样我们就可以用@来代替.&#x2F;src。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP地址</title>
    <link href="/2024/07/10/IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/07/10/IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="内网ip和公网ip"><a href="#内网ip和公网ip" class="headerlink" title="内网ip和公网ip"></a>内网ip和公网ip</h4><p>内网IP（Internal Network IP）是指在局域网或者内部网络中使用的IP地址。在IPv4的网络中，内网IP地址通常属于私有IP地址范围，例如：</p><ul><li>10.0.0.0 到 10.255.255.255</li><li>172.16.0.0 到 172.31.255.255</li><li>192.168.0.0 到 192.168.255.255</li></ul><p>这些地址是专门为局域网内部使用而保留的，不会被分配到互联网上，因此可以重复使用。内网IP地址的作用是在局域网内部进行设备之间的通信和连接，比如连接本地打印机、路由器、局域网内的计算机等。</p><p>与内网IP相对的是公网IP（Public IP），公网IP是可以被全球互联网访问到的IP地址，用于在不同的网络之间进行通信。</p><p>我们可以通过</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ipconfig<br></code></pre></td></tr></table></figure><p>来访问我们电脑现在的内网ip(也就是ipv4地址)</p><p><img src="/2024/07/10/IP%E5%9C%B0%E5%9D%80/image-20240710152532331.png" alt="IP"></p><p>公网IP（Public IP）是指可以直接在全球互联网上访问到的IP地址。它是由互联网服务提供商（ISP，也就是移动，联通这些公司）分配给网络设备（如路由器、服务器等）的唯一标识符，用于在互联网上进行通信和数据交换。</p><p>公网IP地址是全球唯一的，不同的设备在互联网上需要具有不同的公网IP地址，这样才能保证它们之间能够正确地进行通信和数据传输。公网IP地址通常是静态或动态分配的，静态公网IP地址在一段时间内不会改变，而动态公网IP地址可能会在连接重新建立时发生变化。</p><p>通常情况下，个人用户使用的是动态公网IP地址，而企业或特定应用可能会使用静态公网IP地址，以便更稳定地提供服务和进行网络管理，一般情况下我们个人都是先使用内网然后再通过了路由将数据与公网进行交换，如果想要个人直接接入公网，需要向ISP特别申请。</p><p>通俗的说，内网ip与公网ip就好比寄快递，内网ip是几栋几号室，而公网ip是哪个省哪个市，有了这些ip地址后，我们才能把信息精确分配到每一个计算机个体。</p><h4 id="ipv4和ipv6"><a href="#ipv4和ipv6" class="headerlink" title="ipv4和ipv6"></a>ipv4和ipv6</h4><p>IPv4（Internet Protocol version 4）是互联网协议第四版，是当前广泛使用的互联网协议之一。IPv4定义了互联网上数据的传输方式，它使用32位（4个字节）的地址长度来标识网络上的每个设备或节点。</p><p>IPv4地址通常以点分十进制表示，例如：192.168.1.1。每个IPv4地址由四个八位组成，每个八位组可以表示0到255之间的数值，总共有约42亿个不同的IPv4地址。然而，由于互联网的迅速发展和设备的增多，IPv4地址已经逐渐不足以支持所有连接到互联网的设备。</p><p>为了解决IPv4地址耗尽的问题，IPv6（Internet Protocol version 6）被设计出来，它使用128位（16个字节）的地址长度，大大增加了可用的地址空间，预计能够长期解决IP地址耗尽的问题。IPv6的推广和采用逐渐增加，但目前仍然有大部分互联网流量使用IPv4协议。</p><p>总结起来，IPv4是互联网上广泛使用的网络协议之一，使用32位地址长度来标识网络上的设备或节点，其地址格式为点分十进制。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>由上面我们知道随着互联网的发展，ipv4逐渐枯竭。为了应对这样的情况，NAT（网络地址转换）技术孕育而生。</p><h5 id="NAT-的主要类型包括："><a href="#NAT-的主要类型包括：" class="headerlink" title="NAT 的主要类型包括："></a>NAT 的主要类型包括：</h5><ul><li>静态 NAT：静态NAT是将一个固定的私有IP地址映射到一个固定的公共IP地址的一种形式，通常用于需要特定设备具有公共IP地址的情况，如服务器。</li><li>动态 NAT：动态NAT是动态地将内部设备的私有IP地址映射到公共IP地址池中的一个可用地址，通常在需要大量设备同时访问互联网时使用。</li><li>PAT（端口地址转换）：也称为Overload NAT，它允许多个设备使用相同的公共IP地址访问互联网，但通过不同的端口号进行区分。</li></ul><p>一般情况我们我们就是通过路由器来将私有的ip地址映射到固定的公共ip地址，所以路由器在这里就充当了网关的作用。但是通过路由器传输的终端就不止一个，另一端接收方路由器对应的终端也不止一个，我们传输就无法一一对应，所以我们就要用到<strong>端口映射</strong>，通过端口号来确定我们要传输数据的终端彼此。</p><p><img src="/2024/07/10/IP%E5%9C%B0%E5%9D%80/image-20240710160048602.png" alt="大致是这样传递"></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>在知道子网掩码之前，我们要知道什么是<strong>子网</strong>。</p><p><strong>子网</strong>（Subnet）是指将一个大的IP地址块（IP地址空间）划分成若干个较小的子集，每个子集称为一个子网。在网络中，子网的作用是将一个大的网络划分成多个较小的、更易管理的部分，以便于组织和管理网络设备。</p><p>每个子网由一组连续的IP地址组成，这些IP地址共享一个公共的网络前缀（网络标识符）。这个网络前缀通常由IP地址和子网掩码（Subnet Mask）共同决定，子网掩码定义了IP地址中哪些部分是网络部分，哪些部分是主机部分。</p><p>子网的使用可以帮助网络管理员更有效地管理IP地址，减少广播风暴（Broadcast Storm）和冲突，提高网络的安全性和性能。常见的子网划分方式包括按照部门、功能或地理位置来划分子网，以便于根据需要对每个子网进行管理和配置。</p><p>那么如何确定这个ip是否在这个子网中呢？这就需要有子网掩码。子网掩码通过”&amp;”操作辨别子网：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&amp; X = X<br><span class="hljs-symbol">0 </span>&amp; X = X<br></code></pre></td></tr></table></figure><p>比如我们可以将：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.10</span> &amp; <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span> = <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br>IP &amp; 子网掩码 =&gt; 结果相同 =&gt; 同一子网<br></code></pre></td></tr></table></figure><p>如果我们通过ip和子网掩码的与操作都得到相同的结果，说明他们都在同一个子网当中。</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口（Port）是一种逻辑概念，用于区分不同应用程序或服务在同一台计算机上的通信终点。每个端口都有一个数字标识，称为端口号，用于标识特定的网络服务或应用程序。</p><h5 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h5><ol><li><strong>端口号</strong>：端口号是一个16位的整数，范围从0到65535。其中，0到1023的端口号被称为“系统端口”或“well-known端口”，它们通常分配给常见的网络服务，如HTTP（端口号80）、HTTPS（端口号443）、FTP（端口号21）等。</li><li><strong>通信终点</strong>：在一台计算机上，每个运行的应用程序或服务都可以通过一个或多个端口号来进行通信。例如，Web服务器使用HTTP协议通过端口号80接收Web请求，而电子邮件服务器使用SMTP协议通过端口号25接收邮件。</li><li><strong>传输层概念</strong>：端口属于传输层（第四层）协议的概念，在TCP&#x2F;IP模型中，这一层负责提供可靠的数据传输服务。TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们通过端口号来确定数据包应该被交付给哪个应用程序或服务。</li><li><strong>端口分类</strong>：<ul><li><strong>系统端口</strong>：0到1023，预留给众所周知的服务。</li><li><strong>注册端口</strong>：1024到49151，分配给用户进程或应用程序。</li><li><strong>动态&#x2F;私有端口</strong>：49152到65535，用于临时的短暂会话。</li></ul></li></ol><h5 id="端口的重要性："><a href="#端口的重要性：" class="headerlink" title="端口的重要性："></a>端口的重要性：</h5><ul><li><strong>多路复用</strong>：端口允许一台计算机上的多个应用程序同时进行网络通信，通过端口号区分不同的应用数据流。</li><li><strong>网络安全</strong>：端口号有助于防火墙和安全设备识别和控制不同类型的网络流量，提高网络安全性。</li><li><strong>网络管理</strong>：端口号使网络管理员可以轻松地监控和管理网络上的各种服务和应用程序。</li></ul><h4 id="以太网和因特网"><a href="#以太网和因特网" class="headerlink" title="以太网和因特网"></a>以太网和因特网</h4><p>以太网（Ethernet）和因特网（Internet）是两个不同的概念，它们在计算机网络中有着不同的角色和范围。</p><h5 id="以太网（Ethernet）："><a href="#以太网（Ethernet）：" class="headerlink" title="以太网（Ethernet）："></a>以太网（Ethernet）：</h5><ol><li><strong>定义</strong>：以太网是一种局域网（LAN）技术，用于在较小的范围内连接多台计算机和网络设备，如在办公室、校园或家庭内部。</li><li><strong>传输介质</strong>：以太网通常使用双绞线、光纤或者无线电波作为传输介质，传输速度可以从几百Mbps到几十Gbps不等。</li><li><strong>协议</strong>：以太网使用一组标准的数据链路层和物理层协议（如IEEE 802.3标准），定义了数据包在局域网内的传输方式。</li><li><strong>拓扑结构</strong>：以太网的拓扑结构可以是星型、总线型或者环型，其中最常见的是星型拓扑，每台设备连接到一个中央集线器或交换机。</li></ol><h5 id="因特网（Internet）："><a href="#因特网（Internet）：" class="headerlink" title="因特网（Internet）："></a>因特网（Internet）：</h5><ol><li><strong>定义</strong>：因特网是全球范围内的公共计算机网络，由许多不同的网络（包括以太网、光纤网络、卫星网络等）连接起来，通过TCP&#x2F;IP协议族进行数据传输和通信。</li><li><strong>范围</strong>：因特网是全球性的网络，连接了世界上几乎所有的计算机和网络设备，允许它们之间进行跨地域和跨国界的通信。</li><li><strong>协议</strong>：因特网使用TCP&#x2F;IP协议族，包括TCP（Transmission Control Protocol）和IP（Internet Protocol），定义了数据在全球范围内的传输和路由方式。</li><li><strong>服务和应用</strong>：因特网支持各种应用和服务，如电子邮件、网页浏览、文件传输、实时通信等，是人们日常生活中广泛使用的平台。</li></ol><p>简单的说以太网就是局域网，而因特网就是互联网。</p><h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）是一组通信协议，它定义了互联网和许多私有网络中数据如何传输和交换的标准。TCP&#x2F;IP协议族是现代互联网通信的基础，它包括多个协议，每个协议负责不同的功能。</p><ol><li><strong>IP（Internet Protocol）</strong>：<ul><li>IP协议负责在网络中传送数据包，并确保它们能够从源地址到目标地址安全地传输。</li><li>它定义了数据包的结构和格式，以及如何在网络中路由和转发数据包。</li></ul></li><li><strong>TCP（Transmission Control Protocol）</strong>：<ul><li>TCP协议是一种面向连接的协议，负责在通信的两端建立可靠的数据传输连接。</li><li>它确保数据包按顺序到达目的地，并处理丢失数据包的重传，以及流量控制和拥塞控制。</li></ul></li><li><strong>UDP（User Datagram Protocol）</strong>：<ul><li>UDP协议是一种无连接的协议，它提供了一种简单的数据传输服务，适用于实时应用程序和广播通信。</li><li>与TCP不同，UDP不保证数据的顺序和可靠性，但是它提供了较低的延迟和更高的传输速度。</li></ul></li><li><strong>其他协议</strong>：<ul><li><strong>ICMP（Internet Control Message Protocol）</strong>：用于在IP网络上发送控制消息，如错误报告和网络诊断。</li><li><strong>ARP（Address Resolution Protocol）</strong>：用于将IP地址映射为MAC地址（硬件地址）。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端如何将pdf等文件传入后端</title>
    <link href="/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/"/>
    <url>/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="前端如何将pdf等文件传入后端"><a href="#前端如何将pdf等文件传入后端" class="headerlink" title="前端如何将pdf等文件传入后端"></a>前端如何将pdf等文件传入后端</h2><p>我们知道在js中我们可以通过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> id=<span class="hljs-string">&quot;fileInput&quot;</span> accept=<span class="hljs-string">&quot;image/*&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>来输入文件。其中type指后端url，accept来限制传入类型。</p><h3 id="前端通过表单形式将其传入后端"><a href="#前端通过表单形式将其传入后端" class="headerlink" title="前端通过表单形式将其传入后端"></a>前端通过表单形式将其传入后端</h3><p>那么前端是怎么将这一整个文件打包传入后端的呢？</p><p>原来前端通过文件上传表单的方式将文件传输到后端。这通常涉及使用 HTML 的 <code>&lt;form&gt;</code> 元素和 <code>&lt;input type=&quot;file&quot;&gt;</code> 输入框，以及设置适当的表单属性来支持文件上传。</p><p><img src="/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/image-20240704204517908.png" alt="Payload截图"></p><p>可以看到我在使用ant design vue框架时其文件传输的内容包含状态，上传时间，文件名字等。</p><h4 id="文件上传的流程："><a href="#文件上传的流程：" class="headerlink" title="文件上传的流程："></a>文件上传的流程：</h4><ol><li>用户在文件输入框中选择一个文件。</li><li>用户点击提交按钮，浏览器将会把表单数据（包括选定的文件）打包成 <code>multipart/form-data</code> 格式的请求体。</li><li>请求被发送到指定的后端URL（在这个例子中是 <code>/upload</code>）。</li><li>后端接收到请求后，可以通过相应的框架或库来解析 <code>multipart/form-data</code>，获取到文件数据，并进行进一步处理，例如保存文件到服务器或者进行文件内容分析等操作。</li></ol><h4 id="文件上传表单示例："><a href="#文件上传表单示例：" class="headerlink" title="文件上传表单示例："></a>文件上传表单示例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;form id=<span class="hljs-string">&quot;uploadForm&quot;</span> action=<span class="hljs-string">&quot;/upload&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>&lt;form&gt;</code> 元素定义了一个表单，其中：<ul><li><code>action=&quot;/upload&quot;</code> 指定了表单提交的目标后端URL。</li><li><code>method=&quot;POST&quot;</code> 指定了使用POST方法提交表单。</li><li><code>enctype=&quot;multipart/form-data&quot;</code> 表示表单中包含文件上传，这是必需的，因为文件上传需要使用 <code>multipart/form-data</code> 类型来传输文件数据。</li></ul></li><li><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt;</code> 是文件上传的输入框，其中：<ul><li><code>type=&quot;file&quot;</code> 表示这是一个文件输入框，允许用户选择文件。</li><li><code>name=&quot;file&quot;</code> 指定了后端接收文件时的字段名称，这个名称在后端处理文件时很重要。</li><li><code>id=&quot;fileInput&quot;</code> 可以用来通过 JavaScript 获取文件输入框的引用，以便在用户选择文件后执行一些操作（例如显示文件名或大小）。</li></ul></li><li><code>&lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt;</code> 是一个提交按钮，点击它会触发表单提交操作。</li></ul><h4 id="后端处理文件上传的例子："><a href="#后端处理文件上传的例子：" class="headerlink" title="后端处理文件上传的例子："></a>后端处理文件上传的例子：</h4><ul><li><p><strong>Node.js（使用 Express 框架）：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">javascript复制代码<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>);<br><span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>(&#123; <span class="hljs-attr">dest</span>: <span class="hljs-string">&#x27;uploads/&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&#x27;file&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> file = req.<span class="hljs-property">file</span>;<br>    <span class="hljs-comment">// 处理文件，例如保存到服务器或者返回其他响应</span><br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;文件上传成功&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器运行在 http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，使用了 <code>multer</code> 中间件来处理单个文件上传，<code>upload.single(&#39;file&#39;)</code> 表示期望接收一个名为 <code>file</code> 的文件字段。</p></li><li><p><strong>PHP：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php">php复制代码<span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$target_dir</span> = <span class="hljs-string">&quot;uploads/&quot;</span>;<br><span class="hljs-variable">$target_file</span> = <span class="hljs-variable">$target_dir</span> . <span class="hljs-title function_ invoke__">basename</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);<br><span class="hljs-variable">$uploadOk</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>], <span class="hljs-variable">$target_file</span>)) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件上传成功&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件上传失败&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>PHP 示例使用了 <code>$_FILES</code> 超全局数组来接收上传的文件，并使用 <code>move_uploaded_file()</code> 函数将文件从临时位置移动到指定的目标位置。</p></li></ul><h3 id="用JS将文件传入后端"><a href="#用JS将文件传入后端" class="headerlink" title="用JS将文件传入后端"></a>用JS将文件传入后端</h3><p>上面以及展示了html文件上传表单的示例，下面再展示通过JavaScript监听文件选择事件来传递。</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;File&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="JS绑定事件"><a href="#JS绑定事件" class="headerlink" title="JS绑定事件"></a>JS绑定事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br><span class="hljs-keyword">let</span> fileList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#File&#x27;</span>).<span class="hljs-property">files</span><br>&#125;)<br><span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>,fileList[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>如果接口文档要求传递请求体(包括Content-Disposition, Content-Type等)我们使用window提供的FormData构造函数来实例化一个表单类型。</p><h4 id="axios传递"><a href="#axios传递" class="headerlink" title="axios传递"></a>axios传递</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br><span class="hljs-attr">data</span>: fd<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过ajax就可以将文件传入后端。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向JS的TypeScript</title>
    <link href="/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/"/>
    <url>/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/</url>
    
    <content type="html"><![CDATA[<h3 id="面向JS的TypeScript"><a href="#面向JS的TypeScript" class="headerlink" title="面向JS的TypeScript"></a>面向JS的TypeScript</h3><p>说到TypeScript，就不得不从Javascript说起。我们知道JavaScript（也称为 ECMAScript）最初是一种用于浏览器的简单脚本语言。在它被发明时，它被期望用于嵌入网页中的简短代码片段 - 编写几十行以上的代码有点不寻常。因此，早期的网络浏览器执行此类代码的速度非常慢。不过，随着时间的推移，JS 变得越来越流行，Web 开发者开始使用它来创建交互式体验。</p><p>JavaScript是一种为快速使用而设计的语言，与众不同的是，每种语言都有自己的“怪癖“，而 JavaScript 的卑微起步使其拥有许多这样的”怪癖“。</p><ul><li><p>JavaScript 的相等运算符 (<code>==</code>) 强制转换其操作对象，导致意外行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// It is! But why??</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt; x &lt; <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-comment">// True for any value of x!</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>JavaScript 还允许访问不存在的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-comment">// Why is this NaN? Spelling is hard!</span><br><span class="hljs-keyword">const</span> area = obj.<span class="hljs-property">width</span> * obj.<span class="hljs-property">heigth</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="TypeScript：静态类型检查器"><a href="#TypeScript：静态类型检查器" class="headerlink" title="TypeScript：静态类型检查器"></a>TypeScript：静态类型检查器</h4><p>静态检查：在不运行代码的情况下检测代码中的错误。</p><p>TypeScript 能在执行前检查程序是否有错误，并根据值的种类进行检查，使其成为静态类型检查器。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">const</span> area = obj.<span class="hljs-property">width</span> * obj.<span class="hljs-property">heigth</span>;<br><br>* <span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;heigth&#x27;</span> does not exist on type <span class="hljs-string">&#x27;&#123; width: number; height: number; &#125;&#x27;</span>. <span class="hljs-title class_">Did</span> you mean <span class="hljs-string">&#x27;height&#x27;</span>?<span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;heigth&#x27;</span> does not exist on type <span class="hljs-string">&#x27;&#123; width: number; height: number; &#125;&#x27;</span>. <span class="hljs-title class_">Did</span> you mean <span class="hljs-string">&#x27;height&#x27;</span>?<br></code></pre></td></tr></table></figure><h5 id="TypeScript是JavaScript的超集"><a href="#TypeScript是JavaScript的超集" class="headerlink" title="TypeScript是JavaScript的超集"></a>TypeScript是JavaScript的超集</h5><p>因此JS的许多语法在TS中是合法的。由于其语法，TypeScript 不会将任何 JavaScript 代码视为错误。这意味着你可以将任何有效的 JavaScript 代码放入 TypeScript 文件中，而不必担心它的具体编写方式。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = (<span class="hljs-number">4</span><br>         *<span class="hljs-string">&#x27;)&#x27;</span>expected.<br></code></pre></td></tr></table></figure><p>在TS中不会将任何JS代码看成错误。因此你可以将任何有效的JS都放入TS文件中，而不必担心其具体用法。</p><h5 id="类型化的JS超集"><a href="#类型化的JS超集" class="headerlink" title="类型化的JS超集"></a>类型化的JS超集</h5><p>TS是一个类型超集，这意味着它添加了关于如何使用不同类型的值的规则。比如在一些JS中的错误不是语法错误而是“以不正确的方式使用某种值（类型）的错误”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span> / []);<br></code></pre></td></tr></table></figure><p>这个语法上合法的程序记录了 <code>Infinity</code>。但是，TypeScript 将数字除以数组视为无意义的操作，并且会触发错误：“The right-hand side of an arithmetic operation must be of type ‘any’, ‘number’, ‘bigint’ or an enum type.”(分母必须是‘any’,’number’,’bigint’,’enum type’)。</p><h5 id="运行时的行为"><a href="#运行时的行为" class="headerlink" title="运行时的行为"></a>运行时的行为</h5><p>TypeScript 也是一种保留了 JavaScript 运行时行为的编程语言。例如，在 JavaScript 中除以零会产生 <code>Infinity</code> 而不是抛出运行时异常。原则上，TypeScript 不会改变 JavaScript 代码的运行时行为。</p><h5 id="擦除类型"><a href="#擦除类型" class="headerlink" title="擦除类型"></a>擦除类型</h5><p>一旦TS的编译器检查完代码，它就会擦除类型以生成结果的“编译”代码。这意味着一旦代码被TS编译后。生成的普通JS就没有类型信息了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的建立、遍历规则、以及节点计算</title>
    <link href="/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的建立、遍历规则、以及节点计算"><a href="#二叉树的建立、遍历规则、以及节点计算" class="headerlink" title="二叉树的建立、遍历规则、以及节点计算"></a>二叉树的建立、遍历规则、以及节点计算</h3><p>二叉树故名思意就是只有两个度的树，这里讨论其最基本的用法及逻辑。</p><p><img src="/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><h4 id="树的创立"><a href="#树的创立" class="headerlink" title="树的创立"></a>树的创立</h4><p>定义一颗二叉树首先要有一个度里的数据data，以及左右孩子，我们可以用结构体定义以方便其理解。</p><h5 id="结构体定义："><a href="#结构体定义：" class="headerlink" title="结构体定义："></a>结构体定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElementType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span><br><span class="hljs-keyword">typedef</span> Position BinTree;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span><br>    ElementType Data;<br>    BinTree Left;<br>    BinTree Right;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们给左右孩子分别定位Left和Right，这样我们就可以使用T-&gt;Left和T-&gt;Right等方式进行调用，利于理解。</p><h5 id="树的构建："><a href="#树的构建：" class="headerlink" title="树的构建："></a>树的构建：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">binTree <span class="hljs-title function_">creatBintree</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a;<br>binTree b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == a)<span class="hljs-comment">//如果输入0，则停止创建</span><br>b = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>b = (binTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binNode));<br>b-&gt;element = a;<br>b-&gt;leftChild = creatBintree();<br>b-&gt;rightChild = creatBintree();<br><br>&#125;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>当我们构建起了一个树后我们怎么对树进行遍历读取呢？可以用前、中、后序遍历，打比方我们用前序遍历就是通过（根、左、右）对树进行读取，也就是首先将最上面的节点作为root，然后将所有左边和右边的节点看作孩子，然后再将此时左孩子最上面的节点作为root进一步（根、左、右）读取，以此类推进行遍历。我们可以用<em>递归</em>的方式来实现代码。</p><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data); <span class="hljs-comment">//输出结果</span><br>    &#125;<br>    PreorderPrintLeaves(BT-&gt;Left);<br>    PreorderPrintLeaves(BT-&gt;Right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    PreorderPrintLeaves(BT-&gt;Left);<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data);<br>    &#125;    <br>    PreorderPrintLeaves(BT-&gt;Right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BT==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    PreorderPrintLeaves(BT-&gt;Left);  <br>    PreorderPrintLeaves(BT-&gt;Right);<br>    <span class="hljs-keyword">if</span>(BT-&gt;Left==<span class="hljs-literal">NULL</span> &amp;&amp; BT-&gt;Right==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c&quot;</span>,BT-&gt;Data);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="节点的计算"><a href="#节点的计算" class="headerlink" title="节点的计算"></a>节点的计算</h4><p>节点的计算需要通过左右子树的孩子判断来对其进行加法运算，我们可以用T-&gt;lchild!&#x3D;NULL来表示没有左孩子，同理可以右孩子也是T-&gt;rchild!&#x3D;NULL，这样就可以区分度为1、2或叶子节点。</p><h5 id="计算节点数"><a href="#计算节点数" class="headerlink" title="计算节点数"></a>计算节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>; <span class="hljs-comment">//全部一次性+1</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算度为1的节点数"><a href="#计算度为1的节点数" class="headerlink" title="计算度为1的节点数"></a>计算度为1的节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(( T-&gt;lchild!=<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="hljs-literal">NULL</span>) || ( T-&gt;lchild==<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild!=<span class="hljs-literal">NULL</span>))<br>        <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>; <span class="hljs-comment">//这里次数+1</span><br>    <span class="hljs-keyword">return</span> NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); <span class="hljs-comment">//直接return，次数不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算度为2的节点数"><a href="#计算度为2的节点数" class="headerlink" title="计算度为2的节点数"></a>计算度为2的节点数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>( T-&gt;lchild!=<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);<br>    <span class="hljs-keyword">return</span> NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="计算叶子节点个数"><a href="#计算叶子节点个数" class="headerlink" title="计算叶子节点个数"></a>计算叶子节点个数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LeafCount</span> <span class="hljs-params">( BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild==<span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树高计算"><a href="#树高计算" class="headerlink" title="树高计算"></a>树高计算</h4><p>我们可以定义两个整型m，n分别来表示左右两边的树高度，用递归的方式实现向下计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetHeight</span><span class="hljs-params">( BinTree BT )</span>&#123;<br>     <span class="hljs-type">int</span> m, n;<br>     <span class="hljs-keyword">if</span> (BT == <span class="hljs-literal">NULL</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">else</span>&#123;<br>         m = GetHeight(BT-&gt;Left);<br>         n = GetHeight(BT-&gt;Right);<br>         <span class="hljs-keyword">if</span> (m &gt; n)<br>             <span class="hljs-keyword">return</span> (m + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>             <span class="hljs-keyword">return</span> (n + <span class="hljs-number">1</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法-用Dijkstra和Prim求最小路径</title>
    <link href="/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="图算法-用Dijkstra和Prim求最小路径"><a href="#图算法-用Dijkstra和Prim求最小路径" class="headerlink" title="图算法-用Dijkstra和Prim求最小路径"></a>图算法-用Dijkstra和Prim求最小路径</h3><h4 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h4><p>在一个树中有多个节点和多条有向或无向的边，若我们给各个边附上权值，那么利用这两个算法可以计算从一个节点到所有节点的最小距离。实际中可以解决比如快递在区域配送最短的路径等问题。</p><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>例如以第1个节点为树根并循环整个树的节点，找到与1连接的所有点然后比较到这个点的距离是否小于原点(节点1)到这个点的距离(此时还没有)，若此时的距离比另一条路到这个点的距离小，则存入数据，以此类推。</p><h5 id="具体如下："><a href="#具体如下：" class="headerlink" title="具体如下："></a>具体如下：</h5><p>我们用dist数组来存入原点到所有点的最小距离，最开始的时候设置所有的点到原点的距离为无穷大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//原点到原点的距离为0</span><br></code></pre></td></tr></table></figure><p>用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。</p><p>首先用for遍历每个点，寻找到每一个点的到原点的距离。</p><p>再在用一个for来确定这个点是到原点的最短距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t</span><br>        <span class="hljs-keyword">if</span>(!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))t = j;<br>    &#125;<br>    state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i]置为1。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])&#123;<span class="hljs-comment">//遍历t所有可以到达的节点i</span><br>        <span class="hljs-type">int</span> i = e[j];<br>        dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新dist[j]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<span class="hljs-comment">//dist数组的各个元素为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//源点到源点的距离为置为 0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t</span><br>            <span class="hljs-keyword">if</span>(!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))t = j;<br>        &#125;<br>        state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i]置为1。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])&#123;<span class="hljs-comment">//遍历t所有可以到达的节点i</span><br>            <span class="hljs-type">int</span> i = e[j];<br>            dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新dist[j]</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。prim算法相比于dijkstra是贪心的，它要寻找的是每一个点之间的最短距离。</p><h5 id="具体如下"><a href="#具体如下" class="headerlink" title="具体如下"></a>具体如下</h5><p>与Dijkstra一样用dist存入距离，并最开始用无穷大赋值。</p><p>用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。</p><p>用pre数组来保存节点是和谁连通的。</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dist[n],state[n],pre[n];<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i : <span class="hljs-number">1</span> ~ n)<br>&#123;<br>    t &lt;- 没有连通起来，但是距离连通部分最近的点;<br>    state[t] = <span class="hljs-number">1</span>;<br>    更新 dist 和 pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在prim里面相当于是将树的每个点一个一个加入到一个集合中，这个集合就是生成的树。每次选择树都要看看是否在树中并且到树的距离最短，如果是则加入到集合中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dt,<span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dt));<span class="hljs-comment">//初始化距离数组为一个很大的数（10亿左右）</span><br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    dt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//从 1 号节点开始生成 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//每次循环选出一个点加入到生成树</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//每个节点一次判断</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dt[j] &lt; dt[t]))<span class="hljs-comment">//如果没有在树中，且到树的距离最短，则选择该点</span><br>                t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dt[t] == <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 选择该点</span><br>        res += dt[t];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">//更新生成树外的点到生成树的距离</span><br>            <span class="hljs-keyword">if</span>(dt[i] &gt; g[t][i] &amp;&amp; !st[i])&#123;<span class="hljs-comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span><br>                dt[i] = g[t][i];<span class="hljs-comment">//更新距离</span><br>                pre[i] = t;<span class="hljs-comment">//从 t 到 i 的距离更短，i 的前驱变为 t.</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地已经后端部署，前端response返回“Method Post not allowed”问题</title>
    <link href="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这次是在做前端的时候，前后端联调发生的问题。接口名前后都对的上然而显示“Post方法不被允许”：</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/82c4ccc79f7bcddc7c82641131305f5.png" alt="response返回的值"></p><p>第一反应是去看自定义端口最后的url是不是少一个“&#x2F;”：</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234225465.png" alt="自定义接口处"></p><p>发现并没有少。</p><p>最后经过排查发现前后端地址没有对上。前端地址没有连接本地的地址。</p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234403334.png" alt="后端地址设置处"></p><p><img src="/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/image-20240504234428092.png" alt="前端地址设置处"></p><p>修改target的请求地址为”<a href="http://127.0.0.1:3381“，成功解决。">http://127.0.0.1:3381“，成功解决。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise链式调用与async函数解决回调地狱问题</title>
    <link href="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在平时我们使用vue的时候经常会看到在请求接口的时候总是会有async与await：</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502211951935.png" alt="JS请求接口示例"></p><p>这是为什么呢？不能直接请求接口吗？</p><p>这里其实是为了避免出现<em>回调地狱</em>的问题。要理解清楚这个问题不妨从promise的链式调用开始讲起。</p><h4 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h4><p>概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调地狱。</p><p>我们知道一个axios函数中包含一些url等请求参数和一个.then的回调函数，由于其异步性，一个接口的请求需要等到回调函数成功调回才算结束。于是要是我们在.then里面在嵌入一个axios函数的话就需要等到上一层请求后再进入这层，再由这层回调到上层。代码量一多，不仅可读性差而且异常无法捕获，耦合性严重，牵一发动全身。比如看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city!&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>    &#125;)        <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我在第二个url中最后加了一个“!”让其错误，并让<a href="https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5">catch</a>寻找错误的地方。然而我们发现：</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502220418999.png" alt="catch无法捕获"></p><p>其错误直接来源于axios的源码处，而且显示Uncaught (in promise)，这就是回调地狱最直接的一个弊端处。</p><p>好了这里又涉及到一个词叫promise。</p><h4 id="何为Promise？"><a href="#何为Promise？" class="headerlink" title="何为Promise？"></a>何为Promise？</h4><p>mdn的解释是：“Promise是一个对象，它代表了一个异步操作的最终完成或者失败。”所以说Promise就是一个函数返回的对象，不然每次做回调操作都要自己手动传一个回调函数进去。</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/71edb8bc-87b4-4098-9e67-950ad55bb773.jpg" alt="promise工作原理"></p><p>解释：依靠then()方法回返回一个新生成的Promise对象特性，继续串联下一环任务，直到结束。而then()回调函数中的返回值会影响新生成的Promise对象最终状态和结果。这样通过链式调用，可以有效解决回调函数嵌套问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//设置时间模拟ajax请求</span><br>        <span class="hljs-title function_">reslove</span>(<span class="hljs-string">&#x27;北京市&#x27;</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//北京</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 === p); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>可以看到我们创建了一个新的promise对象并赋值给p，然后再用p触发回调函数，并生成了一个全新的promise对象并赋值给p2。</p><p>在最后一行的log中，使用了三等判断进行比较，我们知道三等判断，判断的是两个变量保存的内存地址，最后其返回了false更可以说明生成的是一个全新的promise对象。</p><p>所以知道了promise的工作原理，我们就可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city!&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>    &#125;)        <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>没错，就是在第二个axios前面多了一个return，就可以捕获到第二层的错误了。</p><p><img src="/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/image-20240502225923733.png" alt="成功捕获error"></p><h4 id="async函数和await"><a href="#async函数和await" class="headerlink" title="async函数和await"></a>async函数和await</h4><p>我们现在知道了promise可以解决回调地狱，但是这还是在回调函数里面不断嵌套，可读性极差，这时async函数(意思为“异步”)的引入就极大的改善了这个问题。</p><p><em>定义：async函数是使用async关机字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键词。async和await关键词让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。</em></p><p>因此我们只需要这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> pObj = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;)<br>    <span class="hljs-keyword">const</span> pname = pObj.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    <span class="hljs-keyword">const</span> cObj = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;)<br>    <span class="hljs-keyword">const</span> cname = cObj.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>&#125;<br><span class="hljs-title function_">getData</span>() <span class="hljs-comment">//别忘了调用函数</span><br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pname = []<br><span class="hljs-keyword">let</span> cname = []<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        pname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">5</span>]<br>    &#125;)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="hljs-attr">params</span>: &#123; pname &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        cname = res.<span class="hljs-property">data</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]<br>    &#125;)        <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pname);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cname);<br>&#125;<br><span class="hljs-title function_">getData</span>()<br></code></pre></td></tr></table></figure><p>注意上面第二个代码中pname和cname没有用const定义，是因为当我在外面用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pname = []<br><span class="hljs-keyword">const</span> cname = []<br></code></pre></td></tr></table></figure><p>定义时发现报出错误：Assignment to constant variable（把常量赋值给了变量）</p><p>这是因为我们使用 const 定义了变量且存在初始值。 后面又给这个变量赋值，所以报错了。ES6 标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域：使用 const 定义的常量，不能修改它的值，且定义的常量必须赋初值；let 定义的是变量，可以进行变量赋值操作，且不需要赋初值。这个错误就是因为我们修改了常量而引起的错误，虽然某些浏览器不报错，但是无效果！所以解决方法就是前面加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pname = []<br><span class="hljs-keyword">let</span> cname = []<br></code></pre></td></tr></table></figure><p>成功解决问题。</p><p>– 这里debug的时候发现const和let这块还有点含糊，const似乎最好是赋值一个对象或数组，再对对象进行赋值。等我哪天彻底搞明白了后单独出一期讲讲_(:3 ⌒ﾞ)__</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-ES6箭头函数使用细则</title>
    <link href="/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>我们知道在ES6之前使用函数要使用function：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">形参</span>) &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>然而在function中this指向的对象不够清晰明确，以及其表达不够简洁，于是引入的箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(形参) =&gt; &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>由于其重要性，以及在vue中的大量使用，我将着重讨论下<em>箭头函数的使用方法</em>，<em>函数参数</em>和<em>this指向问题</em>。</p><h3 id="使用方法以及简写条件"><a href="#使用方法以及简写条件" class="headerlink" title="使用方法以及简写条件"></a>使用方法以及简写条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//function写法</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//箭头写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当传入只有一个形参时，小括号可以省略:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+x)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>当函数体只有一行时可以省略大括号:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+x)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//4</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x,y</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x+y)<br><span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//3</span><br><br><span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>)<br>form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.<span class="hljs-title function_">preventDefault</span>()) <span class="hljs-comment">//形参小括号和函数体大括号都省略</span><br><span class="hljs-comment">//阻止表单默认提交时事件</span><br></code></pre></td></tr></table></figure><p>箭头函数可以直接返回一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">uname</span>) =&gt; (&#123; <span class="hljs-attr">uname</span>: uname &#125;) <span class="hljs-comment">// 属性: 值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">uname</span>) =&gt; (&#123; uname &#125;) <span class="hljs-comment">//属性和值的名字一样的时候也可以简写</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;ye&#x27;</span>) <span class="hljs-comment">//&#123;uname: &#x27;ye&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>这里不用大括号包着是因为对象的大括号和其冲突了，所以用小括号代替了。</p><h3 id="箭头函数没有arguments动态参数"><a href="#箭头函数没有arguments动态参数" class="headerlink" title="箭头函数没有arguments动态参数"></a>箭头函数没有arguments动态参数</h3><p>箭头函数里面只有<em>剩余参数…arr</em>,所以只能用剩余参数来传入数组进行计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSum</span> = (<span class="hljs-params">...arr</span>) =&gt; &#123;<br><span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>sum +=arr[i]<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>那么何为动态参数，何为剩余参数呢？</p><h4 id="arguments动态参数"><a href="#arguments动态参数" class="headerlink" title="arguments动态参数"></a>arguments动态参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>) <span class="hljs-comment">//[2,3,4]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++)&#123;<br>sum +=<span class="hljs-variable language_">arguments</span>[i]<br>&#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>arguments动态参数只存在于function函数里面，其是个伪数组，在函数里充当傀儡。</p><h4 id="函数剩余参数"><a href="#函数剩余参数" class="headerlink" title="函数剩余参数"></a>函数剩余参数</h4><p>剩余参数没有的固定名字，这里以arr为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">a,b,...arr</span>) &#123; <span class="hljs-comment">//这里arr是名字，可以自定义</span><br>    <span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">//[4,5]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        sum += arr[i]<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>可以看到剩余参数顾名思义就是取剩下没有对号入座的参数。a&#x3D;2,b&#x3D;3,那么剩下的就由arr接收。注意前面的三个点是<em>展开运算符</em>，它可以让这几个数字组合成一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn = <span class="hljs-function">(<span class="hljs-params">...arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//[1,2,3]</span><br></code></pre></td></tr></table></figure><p>没有展开运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">fn = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数this问题"><a href="#箭头函数this问题" class="headerlink" title="箭头函数this问题"></a>箭头函数this问题</h3><p>我们知道this是指向的是环境对象，比如我们输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//&#123;number: &#x27;1&#x27;, hello: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们定义了一个obj对象然后里面放了一个number和一个hello函数，当我们用obj调用hello函数时，this就指向了obj。那么我们就可以初次判断出谁调用的这个函数，this就指向谁。是不是这样呢？我们可以就单纯输入下面这行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>我们发现返回的是window，而我们知道window是作用域链的链头。因为我们清楚其实我们每次调用函数都应该要在前面加上window作为调用的对象，但是这样极其的重复与单调故将其省去了。这样也就说明了this确实是指向其调用的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>() <span class="hljs-comment">//window</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>() <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><p>回到这个论题，我们可以发现每一个新函数都要根据它是被如何调用的来定义这个函数的this值，非常让人讨厌。因此在箭头函数中，箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。</p><p>当我们再输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//Window</span><br></code></pre></td></tr></table></figure><p>hello的上一级时obj，而调用obj的对象是window，所以输出window。</p><p>再比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">count</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;<br>        <span class="hljs-title function_">count</span>()<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">//&#123;number: &#x27;1&#x27;, hello: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>count函数的上一层是hello，而调用hello的是obj对象，所以输出obj。</p><p>然而在实际开发中，事件回调函数使用箭头函数时，this为全局的window。因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListner</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">//this指向btn</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX-axios库使用与http协议</title>
    <link href="/2024/04/26/axios/"/>
    <url>/2024/04/26/axios/</url>
    
    <content type="html"><![CDATA[<h3 id="AJAX-axios库使用与http协议"><a href="#AJAX-axios库使用与http协议" class="headerlink" title="AJAX-axios库使用与http协议"></a>AJAX-axios库使用与http协议</h3><p>当我们需要将前后端数据进行传递时，我们可以运用AJAX技术。AJAX也就是异步的JavaScript和XML(Asynchronous JavaScript And XML)。简单的说，就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON,XML,HTML和text文本等格式发送和接收数据。</p><h4 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h4><p><img src="/2024/04/26/axios/ajax.gif" alt="ajax工作原理"></p><ol><li>网页中发生一个事件（页面加载、按钮点击）</li><li>由 JavaScript 创建 XMLHttpRequest 对象</li><li>XMLHttpRequest 对象向 web 服务器发送请求</li><li>服务器处理该请求</li><li>服务器将响应发送回网页</li><li>由 JavaScript 读取响应</li><li>由 JavaScript 执行正确的动作（比如更新页面）</li></ol><h4 id="axios使用"><a href="#axios使用" class="headerlink" title="axios使用"></a>axios使用</h4><p>axios是基于Promise的HTTP客户端作用于浏览器和node.js，属于网络请求库。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>引入axios.js的两种方法：</p><p>使用 jsDelivr CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 unpkg CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>函数基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;目标地址&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//后端返回数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="axios-查询参数"><a href="#axios-查询参数" class="headerlink" title="axios-查询参数"></a>axios-查询参数</h5><p>使用axios提供的params选项(param是“参数”的意思)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">params</span>:&#123;<br>参数名:值<br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//返回值</span><br>    <span class="hljs-comment">//console.log(result)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://hmajax.itheima.net/api/city&#x27;</span>,<br>    <span class="hljs-attr">params</span>:&#123;<br>        <span class="hljs-attr">pname</span>: <span class="hljs-string">&#x27;河北省&#x27;</span><br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/axios/image-20240426231418816.png" alt="返回的json格式文件"></p><p>查询完的数据就可以在Response里找到result值，一般情况是返回一个message和一个res，其返回的数据是个json文件。</p><h5 id="axios-请求配置"><a href="#axios-请求配置" class="headerlink" title="axios-请求配置"></a>axios-请求配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;请求方法&#x27;</span>,<br><span class="hljs-attr">data</span>:&#123;<br>参数名:值<br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br><span class="hljs-comment">//返回值</span><br>    <span class="hljs-comment">//console.log(result)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>axios将data对象的数据通过上述方式传入后端，后端就会根据其传入的关键词获得对应的res并在then后面得到。</p><h5 id="axios-错误处理"><a href="#axios-错误处理" class="headerlink" title="axios-错误处理"></a>axios-错误处理</h5><p>在then方法的后面，通过点语法调用catch方法，传入回调函数并定义形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-comment">//请求选项</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br><span class="hljs-comment">//处理数据</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-comment">//处理错误</span><br>    <span class="hljs-comment">//console.log(error)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>该方法可以捕捉到错误数据，并将数据传入error形参中，于是就可以将错误数据解析并返回客户端中显示。（其实error可以用console.log在控制台查看，但是catch可以将数据传入并可解析）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>) <span class="hljs-comment">//一般情况下可以通过这样解析json文件并弹出问题</span><br></code></pre></td></tr></table></figure><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h5><p>http协议规定了浏览器发送及服务器返回内容的格式，也就是如果你传入data对象，报文会将其转化为一个json文件打包传给后端，然后后端再传入对应的json文件。</p><p>如下图就是一个请求报文(也就是请求头)：</p><p><img src="/2024/04/26/axios/image-20240426232117702.png" alt="Request Headers"></p><p>Accept中可以看到返回的是个json文件，Host是域名，User-Agent是用来模仿用户登录。</p><h5 id="Resonpse-Headers"><a href="#Resonpse-Headers" class="headerlink" title="Resonpse Headers"></a>Resonpse Headers</h5><p>当我们后端受到前端的request headers后就会相应的传入response headers，这个headers包括：响应行，响应头，空行，响应体。响应体就包含了我们需要的json文件，浏览器会将该文件通过js渲染，显示于页面中。在文件传输的时候可能会有前后传递出错的时候，这时候就需要状态码来告知错误信息。</p><p>状态码有如下几种：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集其实解决的内容就是类似于集合合并的问题，然而如果用普通的数组去储存一个集合若数据量大，不仅调用时占用内存空间大，而且不便于插入或查询操作，因此引入并查集可以很好的解决这点。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>1.将两个集合合并</p><p>2.询问两个元素是否再一个集合当中</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>理解这个问题就需要把集合给看成一个树，然后这个树的树根就代表这个集合。当想询问其中一个节点时，我们只要访问这个节点father，然后再找这个father的grandfather直到到树根，就能确定这个点的树根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p[x]表示x的父节点</span><br><span class="hljs-keyword">if</span>(p[x]==x) <span class="hljs-comment">//判断树根</span><br><span class="hljs-keyword">while</span>(p[x]!=x) x=p[x] <span class="hljs-comment">//求x的集合编号</span><br></code></pre></td></tr></table></figure><h4 id="合并两个集合"><a href="#合并两个集合" class="headerlink" title="合并两个集合"></a>合并两个集合</h4><p>合并集合只需要将其中一个集合的树根的编号改成另一个集合的根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[x]=y<span class="hljs-comment">//px是x的集合编号，py是y的集合编号</span><br></code></pre></td></tr></table></figure><p>(俗称：给x的祖宗又认了一个爹)</p><p><img src="/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/find%E5%87%BD%E6%95%B0.png" alt="find函数"></p><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>当你找到这个节点的根节点时，就把这些节点的父亲全部变成根节点的编号，也就是让这些节点全部指向根节点。当实现了这个操作后，其查询操作直接将时间复杂度变成O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//寻找根+路径压缩</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1-合并集合"><a href="#1-合并集合" class="headerlink" title="1.合并集合"></a>1.合并集合</h4><p>一共有 n𝑛 个数，编号是 1∼n1∼𝑛，最开始每个数各自在一个集合中。</p><p>现在要进行 m𝑚 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a𝑎 和 b𝑏 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a𝑎 和 b𝑏 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n𝑛 和 m𝑚。</p><p>接下来 m𝑚 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a𝑎 和 b𝑏 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1051≤𝑛,𝑚≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">M</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br><span class="hljs-keyword">Yes</span><br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//核心函数，find(x)最终返回值就是x的根节点编号</span><br>    <span class="hljs-keyword">if</span>(x!=p[x]) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-type">int</span> n,m,a,b;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>        p[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;M&quot;</span>)&#123;<br>            p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//让a根节点的父亲变成b节点的根节点</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;Q&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))&#123; <span class="hljs-comment">//判断两个数是不是属于同一个集合，其实就是两个根编号是不是一样</span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-合并根"><a href="#2-合并根" class="headerlink" title="2.合并根"></a>2.合并根</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>w 星球的一个种植园，被分成 m<em>×</em>n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。</p><p>这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。</p><p>如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行，两个整数 <em>m</em>，<em>n</em>，用空格分开，表示格子的行数、列数（1&lt;<em>m</em>,<em>n</em>&lt;1000）。</p><p>接下来一行，一个整数 k，表示下面还有 <em>k</em> 行数据(0&lt;<em>k</em>&lt;1e5)。</p><p>接下来 <em>k</em> 行，每行两个整数 a<em>，</em>b<em>，表示编号为 a</em> 的小格子和编号为 b 的小格子合根了。</p><p>格子的编号一行一行，从上到下，从左到右编号。</p><p>比如：5×4 的小格子，编号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1  2  3  4<br>5  6  7  8<br>9  10 11 12<br>13 14 15 16<br>17 18 19 20<br></code></pre></td></tr></table></figure><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>一行一个整数，表示答案</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">5 4<br>16<br>2 3<br>1 5<br>5 9<br>4 8<br>7 8<br>9 10<br>10 11<br>11 12<br>10 14<br>12 16<br>14 18<br>17 18<br>15 19<br>19 20<br>9 13<br>13 17<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">1000005</span>],vis[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//寻找根</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,k,a,b,sum=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++) p[i]=i;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//合并集合</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++)&#123;<br>        <span class="hljs-comment">// cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-keyword">if</span>(i==p[i])sum++;<br>    &#125;<br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题使用并查集解题，核心主要两个步骤：寻找该元素的根、合并两个集合</p><p>然后最后判断是用if(i&#x3D;&#x3D;p[i])来判断这里的根有几个，因为我们知道只有p[x]&#x3D;&#x3D;x时，才是这个树的根(因为在数组上理解就是所有的数字比如：[-1，1，2，3，4] —&gt; [ -1，4，2，1，3]，我们可以发现数组的顺序表示数字，而对应上面的数字就是其根的索引，在并查集的操作下只有根节点是i&#x3D;&#x3D;p[i]，因此我们也可以将其作为判断几个集合的依据)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础数据结构之栈、队列、链表</title>
    <link href="/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="c-基础数据结构之栈、队列、链表"><a href="#c-基础数据结构之栈、队列、链表" class="headerlink" title="c++基础数据结构之栈、队列、链表"></a>c++基础数据结构之栈、队列、链表</h2><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q <span class="hljs-comment">//queue&lt;定义类型&gt;定义名称</span><br>q.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//出队</span><br>q.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//入队</span><br>q.<span class="hljs-built_in">front</span>()<span class="hljs-comment">//队首</span><br>q.<span class="hljs-built_in">rear</span>()<span class="hljs-comment">//队尾</span><br>q.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//队长(队长可以为0)</span><br>q.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//是否为空队(若是则返回1)</span><br></code></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt;st<br>st.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//出栈</span><br>st.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//入栈</span><br>st.<span class="hljs-built_in">top</span>()<span class="hljs-comment">//栈顶</span><br>st.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//栈长</span><br>st.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//判断是否为空栈</span><br></code></pre></td></tr></table></figure><h3 id="1-单链表-注意结构体写法"><a href="#1-单链表-注意结构体写法" class="headerlink" title="1.单链表(注意结构体写法)"></a>1.单链表(注意结构体写法)</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现一个单链表，链表初始为空，支持三种操作： </p><p>(1) 向链表头插入一个数；</p><p>(2) 删除第k个插入的数后面的数；</p><p>(3) 在第k个插入的数后插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 </p><p><a href="https://www.ixigua.com/7241418740699824643">https://www.ixigua.com/7241418740699824643</a></p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数M，表示操作次数。 </p><p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种： </p><p>(1) “H x”，表示向链表头插入一个数x。 </p><p>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 </p><p>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 </p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。 </p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。 </p><h4 id="输入样例-复制"><a href="#输入样例-复制" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制"><a href="#输出样例-复制" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6 4 6 5<br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-comment">//建立了一个对象</span><br>    <span class="hljs-type">int</span> num; <span class="hljs-comment">//节点值</span><br>    <span class="hljs-type">int</span> time; <span class="hljs-comment">//第几次插入</span><br>    node* next; <span class="hljs-comment">//定义下一个节点的指针位置</span><br>&#125;;<br>node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<span class="hljs-comment">//创建一个新对象叫head</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">headin</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    node* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<span class="hljs-comment">//创建一个新节点</span><br>    p-&gt;num=n;<span class="hljs-comment">//把值输入节点中，箭头写法表示对象的属性</span><br>    p-&gt;time=i;<span class="hljs-comment">//这是次数</span><br><br>    <span class="hljs-comment">//下面就是插入模板操作</span><br>    p-&gt;next=head-&gt;next;<br>    head-&gt;next=p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">de</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;<br>    node* p, * q;<span class="hljs-comment">//定义两个节点</span><br>    p=head-&gt;next;<span class="hljs-comment">//p为指向head的下一个节点</span><br>    <span class="hljs-keyword">if</span>(!t)&#123;<br>        head-&gt;next=p-&gt;next;<span class="hljs-comment">//head指的是头，里面没值，所以实际的链表头是p</span><br>        <span class="hljs-built_in">delete</span>(p);<span class="hljs-comment">//p是实际头节点</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(p)&#123;<span class="hljs-comment">//找到第t次插入的数</span><br>            <span class="hljs-keyword">if</span>(p-&gt;time==t)<span class="hljs-keyword">break</span>;<br>            p=p-&gt;next;<br>        &#125;<br>        q=p-&gt;next;<span class="hljs-comment">//让q在p的前面，辅助删除p后面的节点</span><br>        p-&gt;next=q-&gt;next;<br>        <span class="hljs-built_in">delete</span>(q);<span class="hljs-comment">//删除q</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    node* p=head-&gt;next; <span class="hljs-comment">//让p指针指向head的下一个，然后用p节点找欲插入的值</span><br>    <span class="hljs-comment">//下面三行是创建新节点然后给其赋值的操作</span><br>    node* q=<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>    q-&gt;num=n;<br>    q-&gt;time=i;<br>    <span class="hljs-comment">//从链表头开始找</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;time == t)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找第t次插入的数</span><br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//把q节点插到第t次插入的数后面</span><br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//开始时链表没有值</span><br>    <span class="hljs-type">int</span> m,i,x,k;<br>    <span class="hljs-type">char</span> op;<br>    i=<span class="hljs-number">1</span>;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">headin</span>(x,i);<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">de</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(k,x,i);<br>            i++;<span class="hljs-comment">//因为题目是记录第几次插入的数，所以要用i计数</span><br>        &#125;            <br>    &#125;<br>    node* p = head-&gt;next;<span class="hljs-comment">//让p指向实际头节点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        cout&lt;&lt; p-&gt;num &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        p=p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-简单计算器"><a href="#2-简单计算器" class="headerlink" title="2.简单计算器"></a>2.简单计算器</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。</p><p><a href="https://www.ixigua.com/7213692123635024436">https://www.ixigua.com/7213692123635024436</a></p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。</p><p>100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p><h4 id="输入样例-复制-1"><a href="#输入样例-复制-1" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4 + 2 * 5 - 7 / 11<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制-1"><a href="#输出样例-复制-1" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">13.36<br></code></pre></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">double</span>&gt;d_st;<br>stack&lt;<span class="hljs-type">char</span>&gt;op_st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">level</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;+&#x27;</span>||a==<span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;*&#x27;</span>||a==<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> c=op_st.<span class="hljs-built_in">top</span>();op_st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">double</span> a,b;<br>    a=d_st.<span class="hljs-built_in">top</span>();<br>    d_st.<span class="hljs-built_in">pop</span>();<br>    b=d_st.<span class="hljs-built_in">top</span>();<br>    d_st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;+&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b+a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b-a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;*&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b*a);<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;/&#x27;</span>)d_st.<span class="hljs-built_in">push</span>(b/a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-built_in">getline</span>(cin,str);<br>    <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(str[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-comment">//如果是数字</span><br>            x=str[i]-<span class="hljs-string">&#x27;0&#x27;</span>; <br>            <span class="hljs-keyword">while</span>(str[i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                x=x*<span class="hljs-number">10</span>+str[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            d_st.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//把字符串数字转化为整型并推入栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span> || str[i]==<span class="hljs-string">&#x27;-&#x27;</span> || str[i]==<span class="hljs-string">&#x27;*&#x27;</span> || str[i]==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(op_st.<span class="hljs-built_in">empty</span>()||<span class="hljs-built_in">level</span>(str[i])&gt;<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<span class="hljs-comment">//只有优先级高于栈顶的情况才能入栈</span><br>                op_st.<span class="hljs-built_in">push</span>(str[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!op_st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">level</span>(str[i])&lt;=<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<br>                <span class="hljs-keyword">while</span>(!op_st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">level</span>(str[i])&lt;=<span class="hljs-built_in">level</span>(op_st.<span class="hljs-built_in">top</span>()))&#123;<span class="hljs-comment">//拿栈顶前两个计算</span><br>                    <span class="hljs-built_in">cal</span>();<br>                &#125;<br>                op_st.<span class="hljs-built_in">push</span>(str[i]);           <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!op_st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-built_in">cal</span>();<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>,d_st.<span class="hljs-built_in">top</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-约瑟夫环-队列解法"><a href="#3-约瑟夫环-队列解法" class="headerlink" title="3.约瑟夫环(队列解法)"></a>3.约瑟夫环(队列解法)</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>n和m。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4 17<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1 3 4 2<br></code></pre></td></tr></table></figure><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;qe;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        qe.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!qe.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br>            x=qe.<span class="hljs-built_in">front</span>();<br>            qe.<span class="hljs-built_in">pop</span>();qe.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//把队头放到对尾</span><br>        &#125;<br>        x=qe.<span class="hljs-built_in">front</span>();qe.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//数到的数彻底出队</span><br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-走出迷宫-bfs"><a href="#4-走出迷宫-bfs" class="headerlink" title="4.走出迷宫(bfs)"></a>4.走出迷宫(bfs)</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。</p><p>假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。</p><p>视频讲解：<a href="https://www.ixigua.com/7166253132702450212">https://www.ixigua.com/7166253132702450212</a></p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。</p><p>接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出从起点到出口最少需要走的步数。</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">3 3<br>S#T<br>.#.<br>...<br></code></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> a[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> r,c;<br>    <span class="hljs-type">int</span> step;<br>&#125;;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sr,<span class="hljs-type">int</span> sc,<span class="hljs-type">int</span> er,<span class="hljs-type">int</span> ec)</span></span>&#123;<br>    queue&lt;node&gt;qe;<span class="hljs-comment">//注意定义方式</span><br>    node q,t;<span class="hljs-comment">//t用来记录q的一圈4个方向</span><br>    q.r=sr,q.c=sc;<br>    q.step=<span class="hljs-number">0</span>;<br>    qe.<span class="hljs-built_in">push</span>(q);<br>    vis[q.r][q.c]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!qe.<span class="hljs-built_in">empty</span>())&#123;<br>        q=qe.<span class="hljs-built_in">front</span>();<br>        qe.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(q.r==er &amp;&amp; q.c==ec)&#123;<br>            cout&lt;&lt;q.step;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            t.r=q.r+dir[i][<span class="hljs-number">0</span>];<br>            t.c=q.c+dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(a[t.r][t.c]==<span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; vis[t.r][t.c]==<span class="hljs-number">0</span> &amp;&amp; t.r&gt;=<span class="hljs-number">1</span>&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=<span class="hljs-number">1</span>&amp;&amp;t.c&lt;=n)&#123;<br>                t.step=q.step+<span class="hljs-number">1</span>;<br>                vis[t.r][t.c]=<span class="hljs-number">1</span>;<br>                qe.<span class="hljs-built_in">push</span>(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> sr,sc,er,ec;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>        cin&gt;&gt;a[i][j];<br>        <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)sr=i,sc=j;<br>        <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;T&#x27;</span>)er=i,ec=j,a[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>(sr,sc,er,ec);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-出入栈判断"><a href="#5-出入栈判断" class="headerlink" title="5.出入栈判断"></a>5.出入栈判断</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入第一行表示一个整数n, n&lt;&#x3D;100</p><p>接下来输入n行，每行表示一个a~z的排列。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。</p><h4 id="输入样例-复制-2"><a href="#输入样例-复制-2" class="headerlink" title="输入样例 复制"></a>输入样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>abcdefghijklmnopqrstuvwxyz<br>zabcdefghijklmnopqrstuvwxy<br></code></pre></td></tr></table></figure><h4 id="输出样例-复制-2"><a href="#输出样例-复制-2" class="headerlink" title="输出样例 复制"></a>输出样例 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">yes<br>no<br></code></pre></td></tr></table></figure><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>5<br>abcdegfhijklnmopqrstuvwxyz<br>abcdegfhijklnmopqrstzyxwvu<br>dcbaegfhijklnmopqrstuvwxyz<br>abcdegfhijkwxyzlnmopqrstuv<br>abcdegfhijklnmouvwxyztsrqp</p><p>yes<br>yes<br>yes<br>no<br>yes</p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack &lt;<span class="hljs-type">char</span>&gt; st;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>(),j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> ch=i+<span class="hljs-string">&#x27;a&#x27;</span>;<br>            st.<span class="hljs-built_in">push</span>(ch);<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>()==s[j])&#123;<br>                st.<span class="hljs-built_in">pop</span>(),j++;<br>            &#125;<br> <br>        &#125;<br>        <span class="hljs-keyword">if</span>(j==len)cout&lt;&lt;<span class="hljs-string">&quot;yes\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;no\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基本语法</title>
    <link href="/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript基础语法介绍"><a href="#JavaScript基础语法介绍" class="headerlink" title="JavaScript基础语法介绍"></a>JavaScript基础语法介绍</h2><h3 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h3><h4 id="1-1-JavaScript是什么"><a href="#1-1-JavaScript是什么" class="headerlink" title="1.1 JavaScript是什么"></a>1.1 JavaScript是什么</h4><p>是一个运行在浏览器上的编程语言。</p><h4 id="1-2JavaScript书写位置"><a href="#1-2JavaScript书写位置" class="headerlink" title="1.2JavaScript书写位置"></a>1.2JavaScript书写位置</h4><p>内部式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)<span class="hljs-comment">//页面弹出警示框</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>外部式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./my.js&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>使用外部时，script标签里面不要写内容，否则会被忽略。</p><h4 id="1-3JavaScript输入输出语法"><a href="#1-3JavaScript输入输出语法" class="headerlink" title="1.3JavaScript输入输出语法"></a>1.3JavaScript输入输出语法</h4><p>输出语法1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>输出语法2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hey&#x27;</span>)<span class="hljs-comment">//页面弹出警示框</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出语法3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;haha&#x27;</span>)<span class="hljs-comment">//控制台输出语法，程序员调试使用</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>输入语法1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入&#x27;</span>)<span class="hljs-comment">//弹出一个对话框</span><br></code></pre></td></tr></table></figure><p>prompt输入类型为字符串。</p><h4 id="1-4-字面量"><a href="#1-4-字面量" class="headerlink" title="1.4 字面量"></a>1.4 字面量</h4><p>比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="2-1-变量是什么"><a href="#2-1-变量是什么" class="headerlink" title="2.1 变量是什么"></a>2.1 变量是什么</h4><p>白话：用来装数据的盒子。可以用来存放数据。</p><h4 id="2-2-变量的基本使用"><a href="#2-2-变量的基本使用" class="headerlink" title="2.2 变量的基本使用"></a>2.2 变量的基本使用</h4><p>(与c语言定义类似)</p><h5 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1.声明变量"></a>1.声明变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> variable <span class="hljs-comment">//var存在与老版的JavaScript中</span><br></code></pre></td></tr></table></figure><p>age为变量。</p><h5 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2.变量赋值"></a>2.变量赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">variable = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>variable为变量，18为字面量。</p><p>变量不允许多次定义。</p><p>小小的变量使用一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> n=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(n)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="2-3-变量命名规则与规范"><a href="#2-3-变量命名规则与规范" class="headerlink" title="2.3 变量命名规则与规范"></a>2.3 变量命名规则与规范</h4><h5 id="1-规则"><a href="#1-规则" class="headerlink" title="1. 规则"></a>1. 规则</h5><p>①不能用关键字。</p><p>②只能用下划线、字母、数字、＄组成，且不能用数字开头。</p><p>③字母严格区分大小写。</p><h5 id="2-规范"><a href="#2-规范" class="headerlink" title="2.规范"></a>2.规范</h5><p>①起名要有意义。</p><p>②遵守小驼峰命名法。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-1-声明数组"><a href="#1-1-声明数组" class="headerlink" title="1.1 声明数组"></a>1.1 声明数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h4 id="1-2-数组的基本使用"><a href="#1-2-数组的基本使用" class="headerlink" title="1.2 数组的基本使用"></a>1.2 数组的基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">//索引</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>) <span class="hljs-comment">//获取长度</span><br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> G = <span class="hljs-number">9.8</span><br></code></pre></td></tr></table></figure><p>常量不允许重新赋值，声明的时候必须赋值。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>js为弱数据类型语言，只有赋值了才知道是什么数据类型。</p><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>number 数字型</p><p>string 字符串型</p><p>boolean 布尔型</p><p>undefined 未定义型</p><p>null 空类型</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>object 对象</p><h4 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1.数字类型"></a>1.数字类型</h4><p>数字类型可以由+ - * &#x2F; %各个符号进行运算。</p><p>NaN (not a number)：表示计算错误。</p><p>NaN是粘性的，任何对NaN的操作都会返回NaN。</p><h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h4><p>通过单引号、双引号或反引号包裹的数据都叫字符串。</p><h5 id="字符串拼接："><a href="#字符串拼接：" class="headerlink" title="字符串拼接："></a>字符串拼接：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>+<span class="hljs-string">&#x27;34&#x27;</span>) <span class="hljs-comment">//字符串可以用加号拼接</span><br><span class="hljs-keyword">let</span> a=<span class="hljs-string">&#x27;k&#x27;</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-string">&#x27;q&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k+q)<br></code></pre></td></tr></table></figure><h5 id="模板字符串："><a href="#模板字符串：" class="headerlink" title="模板字符串："></a>模板字符串：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`大家好，我叫<span class="hljs-subst">$&#123;name&#125;</span>,今年<span class="hljs-subst">$&#123;age&#125;</span>岁`</span>) <span class="hljs-comment">//用反引号,变量用＄&#123;&#125;包裹</span><br></code></pre></td></tr></table></figure><h4 id="3-布尔型-bollean"><a href="#3-布尔型-bollean" class="headerlink" title="3.布尔型 (bollean)"></a>3.布尔型 (bollean)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n=<span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br></code></pre></td></tr></table></figure><h4 id="4-未定义类型-undefined"><a href="#4-未定义类型-undefined" class="headerlink" title="4.未定义类型 (undefined)"></a>4.未定义类型 (undefined)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">//输出undefined</span><br></code></pre></td></tr></table></figure><h4 id="5-空类型-null"><a href="#5-空类型-null" class="headerlink" title="5.空类型 (null)"></a>5.空类型 (null)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj=<span class="hljs-literal">null</span> <span class="hljs-comment">//表示赋值了一个空的内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj) <br></code></pre></td></tr></table></figure><p>如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null</p><h4 id="6-检测数据类型"><a href="#6-检测数据类型" class="headerlink" title="6.检测数据类型"></a>6.检测数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> num <span class="hljs-comment">//num为变量</span><br><span class="hljs-title function_">typeof</span>(num)<br></code></pre></td></tr></table></figure><h4 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7.类型转换"></a>7.类型转换</h4><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>+号两边只要有一个是字符串，都会把另外一个转成字符串。</p><p>除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数字&#x27;</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">//返回&#x27;数字1&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">//返回&#x27;11&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>) <span class="hljs-comment">//返回0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">//返回123</span><br></code></pre></td></tr></table></figure><h5 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h5><p>通过函数来进行数据转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>(str) <span class="hljs-comment">//转换为数字类型</span><br><span class="hljs-keyword">let</span> num = +<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入&#x27;</span>) <span class="hljs-comment">//输入的可以转换为数字类型</span><br></code></pre></td></tr></table></figure><p>parse系列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(num) <span class="hljs-comment">//只保留数字且只保留整数</span><br><span class="hljs-built_in">parseFloat</span>(num) <span class="hljs-comment">//保留数字并保留小数</span><br><span class="hljs-built_in">parseInt</span>(12px) <span class="hljs-comment">//12 </span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-number">12.</span>86px) <span class="hljs-comment">//12.86</span><br></code></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><h5 id="前置自增"><a href="#前置自增" class="headerlink" title="前置自增"></a>前置自增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++i + <span class="hljs-number">2</span>) <span class="hljs-comment">//2+2=4</span><br></code></pre></td></tr></table></figure><p>先自加再使用。</p><h5 id="后置自增"><a href="#后置自增" class="headerlink" title="后置自增"></a>后置自增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i++ + <span class="hljs-number">2</span>) <span class="hljs-comment">//1+2=3 此时i已经为2，但是没有参与运算</span><br></code></pre></td></tr></table></figure><p>先使用再自加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i++ + ++i + i) <span class="hljs-comment">//1+3+3=7 第二个i时i为2</span><br></code></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<br>&lt;<br>&gt;=<br>&lt;=<br>== <span class="hljs-comment">//左右两边值是否相等</span><br>===<span class="hljs-comment">//左右两边是否类型和值都相等</span><br>!== <span class="hljs-comment">//左右两边是否不全等</span><br></code></pre></td></tr></table></figure><p>NaN不等于任何人，包括它自己。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (条件) &#123;<br>满足条件执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>条件中只有数字0或者空字符会触发false，其余都是true。</p><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>可以代替if双分支。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">条件 ? 满足条件执行的代码 : 不满足条件执行的代码<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-number">3</span>&lt;<span class="hljs-number">5</span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;真的&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;假的&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span>&lt;<span class="hljs-number">5</span> ? <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;真的&#x27;</span>) : <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;假的&#x27;</span>)<br></code></pre></td></tr></table></figure><p>等价。</p><p>还可以作赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">5</span> <span class="hljs-comment">//sum=3</span><br></code></pre></td></tr></table></figure><h4 id="数字补0例子"><a href="#数字补0例子" class="headerlink" title="数字补0例子"></a>数字补0例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请您输入一个数字&#x27;</span>) <span class="hljs-comment">//类型为string</span><br>num = num &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> + num : num <span class="hljs-comment">//判断小于10才补0</span><br><span class="hljs-title function_">alert</span>(num)<br></code></pre></td></tr></table></figure><p>输入9，输出09</p><p>输入11，输出11</p><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">//[3,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>push() 添加数组末尾</p><p>unshift() 添加数组开头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">//[1,2,3,4]</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[1,2,3,4,5]</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">//[0,1,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>pop() 弹出最后一个元素</p><p>shift() 弹出第一个元素</p><p>splice() 切片删除  &#x2F;&#x2F;arr.plice(起始位置，删除几个)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">//[1,2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">pop</span>()) <span class="hljs-comment">//3</span><br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">//[2,3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">shift</span>) <span class="hljs-comment">//1</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">//[1,3]</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//[1] 删除索引1后面的所有</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//[1]</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">函数名</span>() &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">函数名<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> sayhi&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">sayhi</span>()<br></code></pre></td></tr></table></figure><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">throw</span> expression;<br></code></pre></td></tr></table></figure><p>使用这个语句后就会弹出error：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;not 4&quot;</span>; <span class="hljs-comment">//Uncaught not 4</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try…catch语句"><a href="#try…catch语句" class="headerlink" title="try…catch语句"></a>try…catch语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span>&#123;<br>...<br><br>&#125; <span class="hljs-keyword">catch</span> (error)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>&#125;<br></code></pre></td></tr></table></figure><p>catch块可以用来处理所有try块总产生的异常。</p><h4 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">openMyFile</span>();<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title function_">writeMyFile</span>(theData); <span class="hljs-comment">//This may throw a error</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-title function_">handleError</span>(e); <span class="hljs-comment">// If we got a error we handle it</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-title function_">closeMyFile</span>(); <span class="hljs-comment">// always close the resource</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>finally</code>块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。<code>finally</code>块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，<code>finally</code>块里的语句也会执行。</p><h3 id="循环与迭代"><a href="#循环与迭代" class="headerlink" title="循环与迭代"></a>循环与迭代</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for_%E8%AF%AD%E5%8F%A5">for 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#do...while_%E8%AF%AD%E5%8F%A5">do…while 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#while_%E8%AF%AD%E5%8F%A5">while 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#label_%E8%AF%AD%E5%8F%A5">label 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#break_%E8%AF%AD%E5%8F%A5">break 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_%E8%AF%AD%E5%8F%A5">continue 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_%E8%AF%AD%E5%8F%A5">for…in 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_%E8%AF%AD%E5%8F%A5">for…of 语句</a></li></ul><p>其循环方式与c语言相似，不再一一赘述。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为<em>方法</em>。</p><p>对象及其属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>myCar.<span class="hljs-property">make</span> = <span class="hljs-string">&quot;Ford&quot;</span>;<br>myCar.<span class="hljs-property">model</span> = <span class="hljs-string">&quot;Mustang&quot;</span>;<br>myCar.<span class="hljs-property">year</span> = <span class="hljs-number">1969</span>;<br></code></pre></td></tr></table></figure><p>可以按如下方法访问对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">myCar[<span class="hljs-string">&quot;make&quot;</span>] = <span class="hljs-string">&quot;Ford&quot;</span>;<br>myCar[<span class="hljs-string">&quot;model&quot;</span>] = <span class="hljs-string">&quot;Mustang&quot;</span>;<br>myCar[<span class="hljs-string">&quot;year&quot;</span>] = <span class="hljs-number">1969</span>;<br></code></pre></td></tr></table></figure><h4 id="创建新对象"><a href="#创建新对象" class="headerlink" title="创建新对象"></a>创建新对象</h4><h5 id="使用对象初始化器创建"><a href="#使用对象初始化器创建" class="headerlink" title="使用对象初始化器创建"></a>使用对象初始化器创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">property_1</span>: value_1, <span class="hljs-comment">// property_# 可以是一个标识符...</span><br>  <span class="hljs-number">2</span>: value_2, <span class="hljs-comment">// 或一个数字...</span><br>  [<span class="hljs-string">&quot;property&quot;</span> + <span class="hljs-number">3</span>]: value_3, <span class="hljs-comment">//  或一个可计算的 key 名...</span><br>  <span class="hljs-comment">// ...,</span><br>  <span class="hljs-string">&quot;property n&quot;</span>: value_n,<br>&#125;; <span class="hljs-comment">// 或一个字符串</span><br></code></pre></td></tr></table></figure><h5 id="使用构造函数创建"><a href="#使用构造函数创建" class="headerlink" title="使用构造函数创建"></a>使用构造函数创建</h5><p>用构造函数创建分两种：</p><ol><li>通过创建一个构造函数来定义对象的类型。(建议首字母大写)</li><li>通过 <code>new</code> 创建对象实例。</li></ol><p>这里首先定义一个<em>对象类型</em>，并且赋予其make,model,year属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里是通过this来给对象类型属性值赋值</p><p>然后你就可以创建一个新对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mycar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Eagle&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>);<br></code></pre></td></tr></table></figure><p>或者你也可以让类中加入一个owner：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year, owner</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = owner;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么你就可以这样创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Eagle&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>, rand);<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Nissan&quot;</span>, <span class="hljs-string">&quot;300ZX&quot;</span>, <span class="hljs-number">1992</span>, ken);<br></code></pre></td></tr></table></figure><p>就可以这样索引读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car2.<span class="hljs-property">owner</span>.<span class="hljs-property">name</span>;<br></code></pre></td></tr></table></figure><p>你也可以为之前定义的对象增加新的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car1.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;black&quot;</span>;<br></code></pre></td></tr></table></figure><p>注意这里只是这个car1增加了新属性，不影响其他car1,car3</p><h5 id="使用Object-create方法创建"><a href="#使用Object-create方法创建" class="headerlink" title="使用Object.create方法创建"></a>使用Object.create方法创建</h5><p>及使用Object.create()函数创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Invertebrates&quot;</span>, <span class="hljs-comment">// 属性默认值(无脊椎动物)</span><br>  <span class="hljs-attr">displayType</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类里面可以包含函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>); <span class="hljs-comment">//该函数用来显示type的值</span><br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// 创建一种新的动物——animal1</span><br><span class="hljs-keyword">var</span> animal1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>);<br>animal1.<span class="hljs-title function_">displayType</span>(); <span class="hljs-comment">// 输出:Invertebrates(因为没有没有给type赋值)</span><br><br><span class="hljs-comment">// 创建一种新的动物——Fishes</span><br><span class="hljs-keyword">var</span> fish = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>);<br>fish.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;Fishes&quot;</span>;<br>fish.<span class="hljs-title function_">displayType</span>(); <span class="hljs-comment">// 输出:Fishes</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的将秒换算成-时:分:秒？</title>
    <link href="/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/"/>
    <url>/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="如何优雅的将秒换算成-时-分-秒？"><a href="#如何优雅的将秒换算成-时-分-秒？" class="headerlink" title="如何优雅的将秒换算成-时:分:秒？"></a>如何优雅的将秒换算成-时:分:秒？</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先看一下题目，发现就是一道模拟题，但是又一些细节的。</p><p>首先是数据的规模：时间不超过 10^18,所以需要开 long long。</p><p>然后首先要忽略掉毫秒。</p><p>这里普及一个知识:1<em>s</em> &#x3D; 1000ms</p><p>所以需要忽略后面的三位。直接整除 1000 就可以了。</p><p>之后就是处理时分秒了：</p><h4 id="1-小时"><a href="#1-小时" class="headerlink" title="1.小时"></a>1.小时</h4><p>由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用<code>24*60*60</code>来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数<code>60*60</code>（也就是3600），就是小时值了。</p><h4 id="2-分钟"><a href="#2-分钟" class="headerlink" title="2.分钟"></a>2.分钟</h4><p>分钟要先对每小时的秒数<code>60*60</code>取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。</p><h4 id="3-秒"><a href="#3-秒" class="headerlink" title="3.秒"></a>3.秒</h4><p>直接对60取余，剩下的就是秒了。</p><p>时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。</p><p>当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。</p><p>要用到两个函数：</p><p>一个是<code>setw()</code>函数，这个函数可以限定域宽，宽度就是括号里的数字。</p><p>另外一个<code>setfill()</code>函数，这个函数可以设置当实际的宽度不足<code>setw()</code>函数的值时，用某个字符来补足。（<code>setfill()</code>函数最好放在<code>setw()</code>函数前面）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,h,m,s;<br>    cin&gt;&gt;n;<br>    n=n/<span class="hljs-number">1000</span>;<br>    h=n%(<span class="hljs-number">24</span>*<span class="hljs-number">3600</span>)/<span class="hljs-number">3600</span>;<br>    m=n%<span class="hljs-number">3600</span>/<span class="hljs-number">60</span>;<br>    s=n%<span class="hljs-number">60</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;h&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;m&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css背景</title>
    <link href="/2024/01/20/css-bgc/"/>
    <url>/2024/01/20/css-bgc/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color(bgc)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p>颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制…</p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>background-image(bgi)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;图片的路径&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>①背景图片中url可以省略引号。</p><p>②背景图片默认是在水平和垂直方向平铺的。</p><p>③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。</p><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p>background-repeat(bgr)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-repeat</span>:no-repeat;<br>&#125;<br></code></pre></td></tr></table></figure><p>repeat (默认值)水平和垂直方向都平铺</p><p>no-repeat 不平铺</p><p>repeat-x 沿着水平方向(x轴)平铺</p><p>repeat-y 沿着垂直方向(y轴)平铺</p><h3 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h3><p>background-position(bgp)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方位名词"><a href="#方位名词" class="headerlink" title="方位名词"></a>方位名词</h4><h5 id="水平方向"><a href="#水平方向" class="headerlink" title="水平方向"></a>水平方向</h5><p>left、center、right</p><h5 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h5><p>top、center、bottom</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>: right bottom; //水平位置 垂直位置<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字-px"><a href="#数字-px" class="headerlink" title="数字+px"></a>数字+px</h4><h5 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h5><p>①原点(0,0) 盒子左上角</p><p>②x轴 水平向右</p><p>③y轴 垂直向下</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>将图片左上角与坐标点重合即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">50px</span> <span class="hljs-number">100px</span>; //水平位置 垂直位置<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背景相关属性连写"><a href="#背景相关属性连写" class="headerlink" title="背景相关属性连写"></a>背景相关属性连写</h3><p>background: color image repeat position</p><p>可以不按顺序写。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">background</span>: pink <span class="hljs-built_in">url</span>(<span class="hljs-string">./images/1.jpg</span>) no-repeat bottom center ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="与img的区别"><a href="#与img的区别" class="headerlink" title="与img的区别"></a>与img的区别</h4><p>①img标签是一个标签，不设置宽高默认会以原尺寸显示。</p><p>②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归——深度优先搜索(dfs)</title>
    <link href="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/"/>
    <url>/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/</url>
    
    <content type="html"><![CDATA[<h2 id="递归——深度优先搜索-dfs"><a href="#递归——深度优先搜索-dfs" class="headerlink" title="递归——深度优先搜索(dfs)"></a>递归——深度优先搜索(dfs)</h2><p>区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索：</p><p>递归方法类似于栈，将数据一直递取到底后自下往上出栈。</p><p>大致框架如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">viod <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(输出条件)&#123;<br>        cout&lt;&lt;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)&#123;<br>                a[k]=数字,vis[i]=<span class="hljs-number">1</span><span class="hljs-comment">//标记使用;</span><br>                <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//向下递取</span><br>                vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将其拿出，返回原先状态</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下列题目方式解决一些排列组合问题。</p><h4 id="组合输出-–5个数字组合输入3个盒子"><a href="#组合输出-–5个数字组合输入3个盒子" class="headerlink" title="组合输出 –5个数字组合输入3个盒子"></a>组合输出 –5个数字组合输入3个盒子</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231018142215689.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m,n,r;<br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>],vis[<span class="hljs-number">200</span>];<span class="hljs-comment">//a用来记录牌子，vis用来记录牌子的使用情况</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_rise</span><span class="hljs-params">(<span class="hljs-type">int</span> b[])</span></span>&#123;<span class="hljs-comment">//判断是否是递增数组</span><br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;r;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&gt;a[i+<span class="hljs-number">1</span>])&#123;<br>            flag=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//k为盒子的编号，或可以理解为步数</span><br>    <span class="hljs-keyword">if</span>(k==r+<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">is_rise</span>(a))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。</span><br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)&#123;<br>            a[k]=i,vis[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将牌子拿出来，此时就要把vis归回0</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;r;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。</p><h4 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a>素数环</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231017155808693.png"></p><p>eg：输入8 输出4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],vis[<span class="hljs-number">25</span>];<br><span class="hljs-type">int</span> n,cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isPrime</span>(a[<span class="hljs-number">1</span>]+a[n]))&#123;<span class="hljs-comment">//是否超出边界&amp;&amp;是否头尾相加是素数</span><br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isPrime</span>(i+a[k<span class="hljs-number">-1</span>]))&#123;<span class="hljs-comment">//vis用来看有没有用过这个数字</span><br>            a[k]=i,vis[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//a用来保存数字</span><br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            vis[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前的这个数字清除，再向下dfs</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;cnt; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231012224152754.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>]; <span class="hljs-comment">//a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//depth first search</span><br><span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//i是指拿在你手上的牌的数字，没用0为了更好理解</span><br><span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//看看这个牌用过没有，b数组用来看这个牌用过没有用的</span><br>a[k]=i,b[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了</span><br><span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<span class="hljs-comment">//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里</span><br>b[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推</span><br>&#125;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h4><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231024213457892.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,cnt;<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>],vis[<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//      cout&lt;&lt;sum&lt;&lt;&quot; &quot;;</span><br>        vis[sum]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,sum+a[k]);<br>    <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i])cnt++;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若把上面代码的注释删除则可以得到：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>由此可知上面深度搜索遍历的顺序是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span>+<span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">3</span>+<span class="hljs-number">4</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">4</span><br><span class="hljs-attribute">0</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/image-20231107093250409.png"></p><p>以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。</p><p>相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬取pixiv日前十图片并下载至本地</title>
    <link href="/2023/09/11/pixiv-crawler/"/>
    <url>/2023/09/11/pixiv-crawler/</url>
    
    <content type="html"><![CDATA[<h1 id="爬取pixivic日前十图片"><a href="#爬取pixivic日前十图片" class="headerlink" title="爬取pixivic日前十图片"></a>爬取pixivic日前十图片</h1><p>实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910131905687.png" alt="image-20230910131905687.png"></p><h4 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h4><p>首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910132233727.png" alt="image-20230910132233727.png"></p><p>于是我们就可以向这个api发送请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;</span><br>reponse = requests.get(url)<br><span class="hljs-built_in">print</span>(reponse)  <span class="hljs-comment">#返回&lt;Response [200]&gt;</span><br></code></pre></td></tr></table></figure><p>因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。</p><h4 id="2-解析数据"><a href="#2-解析数据" class="headerlink" title="2.解析数据"></a>2.解析数据</h4><p>返回数据长这个样子：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910132826060.png" alt="image-20230910132826060.png"></p><h5 id="json使用"><a href="#json使用" class="headerlink" title="json使用"></a>json使用</h5><p>这就是标准的json形式文件，但还不是一个字典(其实很像)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。</p><p>我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">response.json()[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>]<br><span class="hljs-comment">#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png</span><br><span class="hljs-comment">#就是日排行第一的图</span><br></code></pre></td></tr></table></figure><p>但是当你将网站复制进浏览器时你会发现打不开。</p><h5 id="url拼接"><a href="#url拼接" class="headerlink" title="url拼接"></a>url拼接</h5><p>也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910133814148.png" alt="image-20230910133814148.png"></p><p><img src="/2023/09/11/pixiv-crawler/image-20230910133823700.png" alt="image-20230910133823700.png"></p><p>图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。</p><h4 id="3-下载图片至本地"><a href="#3-下载图片至本地" class="headerlink" title="3.下载图片至本地"></a>3.下载图片至本地</h4><p>目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img_url = <span class="hljs-string">&quot;https://acgpic.net/c/540x540_70/img-master&quot;</span>+response.json()[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>][<span class="hljs-number">32</span>:-<span class="hljs-number">4</span>]+<span class="hljs-string">&quot;_master1200.jpg&quot;</span><br><br>img = requests.get(img_url)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./top1.jpg&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#&quot;wb&quot;是以二进制写入</span><br>f.write(img.content)  <span class="hljs-comment">#content是指获取二进制内容</span><br></code></pre></td></tr></table></figure><p>此时你已经可以看到top1的图片下载当前文件夹了。</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910135314561.png" alt="image-20230910135314561.png"></p><p>同理，下载前十的图片只需要加入for循环就可以了，以下省略。</p><h4 id="4-下载至指定文件夹"><a href="#4-下载至指定文件夹" class="headerlink" title="4.下载至指定文件夹"></a>4.下载至指定文件夹</h4><p>这里就需要导入os包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>path = <span class="hljs-string">&#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27;</span>  <span class="hljs-comment">#这是我的绝对地址</span><br><span class="hljs-keyword">if</span>(os.path.exists(path)==<span class="hljs-literal">False</span>):  <span class="hljs-comment">#判断是否存在该文件夹</span><br>    os.mkdir(path)  <span class="hljs-comment">#创建该文件夹，文件夹名字为2023-9-7</span><br></code></pre></td></tr></table></figure><h5 id="path书写"><a href="#path书写" class="headerlink" title="path书写"></a>path书写</h5><p>这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法：</p><p><img src="/2023/09/11/pixiv-crawler/image-20230910140553967.png" alt="image-20230910140553967.png"></p><p>第二条中的r是用来申明不是转义字符。</p><p>这样就可以创建一个文件夹了~</p><p>然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。</p><h4 id="5-关于api中日期的变化"><a href="#5-关于api中日期的变化" class="headerlink" title="5.关于api中日期的变化"></a>5.关于api中日期的变化</h4><p>因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>day = datetime.date.today()<br>api_day = day-datetime.timedelta(days=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>然后只需要再拼接如url中就可以啦~</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> datetime<br><br>day = datetime.date.today()<br>api_day = day-datetime.timedelta(days=<span class="hljs-number">3</span>)<br><br>url = <span class="hljs-string">&quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;</span>+<span class="hljs-built_in">str</span>(api_day)+<span class="hljs-string">&quot;&amp;mode=day&amp;pageSize=302&quot;</span><br>response = requests.get(url)<br>date = url[<span class="hljs-number">40</span>:<span class="hljs-number">50</span>]<br>path = <span class="hljs-string">&#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;</span>+date  <span class="hljs-comment">#linux写法</span><br><br><span class="hljs-keyword">if</span>(os.path.exists(path)==<span class="hljs-literal">False</span>):  <span class="hljs-comment">#判断是否存在该文件夹</span><br>    os.mkdir(path)  <span class="hljs-comment">#创建该文件夹</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img_url = <span class="hljs-string">&quot;https://acgpic.net/c/540x540_70/img-master&quot;</span>+response.json()[<span class="hljs-string">&quot;data&quot;</span>][i][<span class="hljs-string">&#x27;imageUrls&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;original&#x27;</span>][<span class="hljs-number">32</span>:-<span class="hljs-number">4</span>]+<span class="hljs-string">&quot;_master1200.jpg&quot;</span><br>    img = requests.get(img_url)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path+<span class="hljs-string">&quot;/top&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;.jpg&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(img.content)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存top&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;中...&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫 --- 以爬取笔趣阁小说为例</title>
    <link href="/2023/08/31/biquge/"/>
    <url>/2023/08/31/biquge/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫-—-以爬取笔趣阁小说为例"><a href="#爬虫-—-以爬取笔趣阁小说为例" class="headerlink" title="爬虫 — 以爬取笔趣阁小说为例"></a>爬虫 — 以爬取笔趣阁小说为例</h1><h4 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/5418/2610707.html&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>&#125;<br>response = requests.get(url,headers)<br></code></pre></td></tr></table></figure><p>这是requests请求，若返回response值为200，则表示请求成功</p><h4 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">response = requests.get(url,headers).text<br></code></pre></td></tr></table></figure><p>可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析</p><h4 id="3-解析数据"><a href="#3-解析数据" class="headerlink" title="3.解析数据"></a>3.解析数据</h4><p>有以下几种途径：css、xpath、re正则表达 等等</p><p>让我们来看看分别用这三种方法怎么去解析到一个章节的标题</p><h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br>selector = parsel.Selector(response)<br>novel_title = selector.css(<span class="hljs-string">&quot;.bookname h1::text&quot;</span>).get()<br></code></pre></td></tr></table></figure><p>这种方法通过css选择器进行选择</p><h5 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br>selector = parsel.Selector(response)<br>novel_title = selector.xpath(<span class="hljs-string">&quot;//*[@class=&quot;</span>bookname<span class="hljs-string">&quot;]/h1/text()&quot;</span>).get()<br></code></pre></td></tr></table></figure><p>注意text后面的()</p><h5 id="re"><a href="#re" class="headerlink" title="re"></a>re</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>novel_title = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串</p><p>*注意：以上方法各有利弊，选择合适的方式来解析数据</p><h4 id="4-保存数据"><a href="#4-保存数据" class="headerlink" title="4.保存数据"></a>4.保存数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file_name&quot;</span>+<span class="hljs-string">&quot;.txt&quot;</span>,mode=<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入</span><br>f.write(novel_context)  <span class="hljs-comment">#写入文件</span><br></code></pre></td></tr></table></figure><p>with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径</p><h4 id="以上思路已经理清楚了，下面开始实践："><a href="#以上思路已经理清楚了，下面开始实践：" class="headerlink" title="以上思路已经理清楚了，下面开始实践："></a>以上思路已经理清楚了，下面开始实践：</h4><h3 id="爬取一章"><a href="#爬取一章" class="headerlink" title="爬取一章"></a>爬取一章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> parsel<br><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/5418/2610707.html&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>&#125;<br>response = requests.get(url,headers).text<br><br>selector = parsel.Selector(response)<br>novel_title = selector.css(<span class="hljs-string">&quot;.bookname h1::text&quot;</span>).get() <span class="hljs-comment">#css方法解析数据</span><br><br>novel_context_list = selector.css(<span class="hljs-string">&quot;#htmlContent p::text&quot;</span>).getall() <br>novel_context = <span class="hljs-string">&quot;\n&quot;</span>.join(novel_context_list)<br></code></pre></td></tr></table></figure><p>注意：join函数的使用：</p><p><img src="/2023/08/31/biquge/p1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(a))  <span class="hljs-comment">#输出1 2 8 9</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>.join(a))  <span class="hljs-comment">#输出1(换行)2(换行)8(换行)9</span><br><br>b=&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(a))  <span class="hljs-comment">#输出a b</span><br></code></pre></td></tr></table></figure><p>（注意seq不能是int整形）</p><h3 id="爬取各章url"><a href="#爬取各章url" class="headerlink" title="爬取各章url"></a>爬取各章url</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/18753/&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>    &#125;<br>response = requests.get(url,headers).text<br>novel_name = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br>novel_info = re.findall(<span class="hljs-string">&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,response)<br><span class="hljs-keyword">for</span> novel_url_part,novel_title <span class="hljs-keyword">in</span> novel_info:<br>    novel_url = <span class="hljs-string">&quot;https://www.xzmncy.com&quot;</span>+novel_url_part[<span class="hljs-number">0</span>:<span class="hljs-number">24</span>]<br>    <span class="hljs-built_in">print</span>(novel_url)<br>    <span class="hljs-built_in">print</span>(novel_title)<br></code></pre></td></tr></table></figure><p>在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的：</p><p><img src="/2023/08/31/biquge/image-20230831120348951.png" alt="image-20230831120348951"></p><p>我们就可以用re来解析到各个章节的url和title</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> parsel<br>url = <span class="hljs-string">&quot;https://www.xzmncy.com/list/18753/&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span> : <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;</span><br>    &#125;<br>response = requests.get(url,headers).text<br>novel_name = re.findall(<span class="hljs-string">&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;</span>,response)[<span class="hljs-number">0</span>]<br>novel_info = re.findall(<span class="hljs-string">&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,response)<br><span class="hljs-keyword">for</span> novel_url_part,novel_title <span class="hljs-keyword">in</span> novel_info:<br>    novel_url = <span class="hljs-string">&quot;https://www.xzmncy.com&quot;</span>+novel_url_part[<span class="hljs-number">0</span>:<span class="hljs-number">24</span>]<br>    novel_response = requests.get(novel_url, headers).text<br>    selectors = parsel.Selector(novel_response)<br>    novel_context_list = selectors.css(<span class="hljs-string">&quot;#htmlContent p::text&quot;</span>).getall()<br>    novel_context = <span class="hljs-string">&quot;\n&quot;</span>.join(novel_context_list)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存&quot;</span>+novel_title)<br>    novel_title = <span class="hljs-string">&quot;*&quot;</span> + novel_title<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(novel_name+<span class="hljs-string">&quot;.txt&quot;</span>,mode=<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(novel_title)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>        f.write(novel_context)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器</title>
    <link href="/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><p>引入方式有以下三种：</p><p>1.内嵌式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!-- 内嵌式 --&gt;<br>&lt;!DOCTYPE <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span> lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-<span class="hljs-number">8</span>&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-scale=<span class="hljs-number">1.0</span>&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>        colour&#123;<br>colour:pink;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>2.外联式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 外联式 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./111.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 111为引入文件名 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.行内式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 行内式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;colour&quot;</span>&gt;</span><br>        abcd<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: aqua;font-size: large;&quot;</span>&gt;</span>abab<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>一共有4种：标签选择器、类选择器、id选择器、通符选择器</p><p>注：一下选择器均是在style标签下的</p><h4 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div)</p><h4 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2.类选择器"></a>2.类选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.color-choose</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其html调用方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;color-choose&quot;</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3.id选择器"></a>3.id选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#color</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其html调用方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：id只得调用一次</p><h4 id="4-通符选择器"><a href="#4-通符选择器" class="headerlink" title="4.通符选择器"></a>4.通符选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br>&lt;!-- 清除内外边距 --&gt;<br></code></pre></td></tr></table></figure><p>对全局内容生效</p><h2 id="选择器的选择"><a href="#选择器的选择" class="headerlink" title="选择器的选择"></a>选择器的选择</h2><h4 id="1-后代-（后面所有代）"><a href="#1-后代-（后面所有代）" class="headerlink" title="1.后代  （后面所有代）"></a>1.后代  （后面所有代）</h4><p>问题如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> abab <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 哈哈哈 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>欲选择div中的p标签，而不是外部的p</p><p>以如下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>        <span class="hljs-attribute">color</span>:blue;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="2-子代-（后面一代）"><a href="#2-子代-（后面一代）" class="headerlink" title="2.子代  （后面一代）"></a>2.子代  （后面一代）</h4><p>问题是要选中div后面的一代</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> dd <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span> ddd <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以如下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-并集"><a href="#3-并集" class="headerlink" title="3.并集"></a>3.并集</h4><p>问题：想要让以下这些标签被选到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> p <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> div <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> span <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> haha <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下面方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">span</span>,<span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-交集"><a href="#4-交集" class="headerlink" title="4.交集"></a>4.交集</h4><p>问题：只想要选中下面p中带class&#x3D;”c”的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>abcd<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下面方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.c</span>&#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>p是标签，c是类名（前面带个.的）</p><h4 id="5-伪类"><a href="#5-伪类" class="headerlink" title="5.伪类"></a>5.伪类</h4><p>问题：想要让鼠标悬停在如下超链接上能够变色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;~~~&quot;</span>&gt;</span>传送<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一下方法实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br><span class="hljs-attribute">color</span>:red;<br><span class="hljs-attribute">background-color</span>:yellow;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破壳啦</title>
    <link href="/2023/08/21/page1/"/>
    <url>/2023/08/21/page1/</url>
    
    <content type="html"><![CDATA[<p>终于创建好一个博客啦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
