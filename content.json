{"meta":{"title":"ye's blog","subtitle":"","description":"","author":"Ye","url":"https://Bayeeaa.github.io","root":"/"},"pages":[{"title":"about","date":"2023-08-22T07:06:19.000Z","updated":"2023-08-22T07:07:20.142Z","comments":false,"path":"about/index.html","permalink":"https://bayeeaa.github.io/about/index.html","excerpt":"","text":"hello!"}],"posts":[{"title":"通过Github Pages上线Vite app静态项目","slug":"通过Github-Pages上线Vite-app静态项目","date":"2024-09-16T07:14:48.000Z","updated":"2024-09-16T07:16:41.550Z","comments":true,"path":"2024/09/16/通过Github-Pages上线Vite-app静态项目/","link":"","permalink":"https://bayeeaa.github.io/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"通过Github Pages上线Vite app静态项目我们都知道通过github pages是能够免费上线一个静态项目的。但你是否有疑惑，为什么我的vue项目在本地npm run dev的时候是能够查看的，为什么我部署到github上并通过github pages却是空白的？经过尝试我发现vite所构建的项目是相当于是操作文件，而不是对外发布(public)的文件，因此我们需要进行额外的操作。 项目配置在vite.config.ts文件中输入： 1base:&#x27;/仓库名/&#x27; 然后在终端输入： 1npm run build 注意要build的话就需要将所有的飘红的bug都解决掉，否则报错。 然后要是build成功，就会发现多出一个dist隐藏文件，这个dist文件就是我们需要对外部署的文件。 git操作然后我们就需要将这个文件单独出一个分支，我们约定俗成给这个分支叫做”gh-pages”，并将dis导入进这个分支。 操作如下： 123git add dist -fgit commit -m &quot;adding dist&quot; git subtree push --prefix dist origin gh-pages git add dist -f ：注意-f是强制添加(force)的意思，因为这个是隐藏文件，git会默认将其忽略掉，因此需要强制添加到缓冲区。 git commit -m “adding dist” ：确认上传，并写入原因。 git subtree push –prefix dist origin gh-pages ：我们一个一个分析:”git subtree”用于管理项目中的子目录作为独立的 Git 树结构进行操作；”push –prefix dist”推入子文件dist(dist在整个项目中是子文件)；”origin gh-pages “是目标地，origin是仓库，gh-pages是分支 上线pages当你完成了上述git操作之后就可以在github pages里面操作了： 然后你就可以点击上面”Your site is live at https:&#x2F;&#x2F;**”，就可以访问了。 静态项目更新当我们发现错误需要更新的时候，我们要知道在原vite项目和dist文件中都需要更改。首先需要在原来的vite项目中更改，然后上传至仓库。接着再重复上述的git命令上传至gh-pages里面： 1234npm run buildgit add dist -fgit commit -m &quot;adding dist&quot; git subtree push --prefix dist origin gh-pages 然后就可以完成网站更新了。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"},{"name":"Git","slug":"Git","permalink":"https://bayeeaa.github.io/tags/Git/"}]},{"title":"Java IO流","slug":"Java-IO流","date":"2024-09-03T06:27:16.000Z","updated":"2024-09-16T07:30:01.999Z","comments":true,"path":"2024/09/03/Java-IO流/","link":"","permalink":"https://bayeeaa.github.io/2024/09/03/Java-IO%E6%B5%81/","excerpt":"","text":"Java I&#x2F;O流I&#x2F;O流即input和output产生的流。Java程序是通过“流”的形式进行数据输入和输出。 流流是一种抽象的概念，可以理解为输入&#x2F;输出的途径。I&#x2F;O部分内容是很庞大的，包括有标准的输入&#x2F;输出、文件操作、网络上的数据流、字符串流、对象流等。当程序需要读取数据时，就会开启一个通向数据源的流，这个数据源可以是文件、内存或网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。 流的概念Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类表示： InputStream OutputStream Reader Writer 输入流和输出流流可分为两类：输入流和输出流。用户可以从输入流中读取信息，但不能写它。相反，对于输出流，只能往其中写，而不能读它。 输入流输入流的信息源可以位于文件、内存或网络套接字(Socket)等地方，信息源可以是对象、字符、图像、声音等。 输出流与输入流类似，程序页能通过打开一个输出流并顺序地写入数据来将信息送至目的端。 字节流与字符流的区别1. 数据处理方式 字节流：处理原始的字节数据。它适用于所有类型的数据，包括图像、音频、视频等，因为这些数据并不依赖于特定的字符编码。常见的字节流类包括 InputStream 和 OutputStream 及其子类，例如 FileInputStream 和 FileOutputStream。 字符流：处理字符数据，并且能够自动处理字符编码和解码。字符流是基于字节流的封装，能将字节流转换成字符流，处理时考虑了字符编码（如 UTF-8、ISO-8859-1 等）。常见的字符流类包括 Reader 和 Writer 及其子类，例如 FileReader 和 FileWriter。 2. 适用场景 字节流：适合于二进制数据的读写，如图像、音频文件等，因为它们的数据通常不需要字符编码转换。例如，当你需要处理一个图片文件时，使用字节流是比较合适的选择。 字符流：适合于文本数据的读写，尤其是当你需要处理不同字符编码时。字符流可以直接处理字符、字符串，并且会根据指定的字符集进行编码和解码。例如，当你读取或写入文本文件时，使用字符流更为方便。 3. 处理单位 字节流：以字节为单位进行读写，操作的是原始的二进制数据。 字符流：以字符为单位进行读写，操作的是文本数据，并会进行字符编码的转换 字节流在前面我们知道I&#x2F;O类中所有对字节流处理的类，都继承与InputStream类和OutputStream类。 InputStream类InputStream 是 Java 中用于读取字节流的抽象类。它是所有字节输入流类的超类，提供了基本的输入流操作方法。InputStream 类的设计使得你可以从各种数据源（如文件、网络、内存等）读取字节数据。以下是关于 InputStream 类的一些关键点： int read() 读取下一个字节的数据。 如果流末尾已到达，返回 -1。 示例： 1int data = inputStream.read(); int read(byte[] b) 从输入流中读取数据到字节数组中。 返回实际读取的字节数，如果流末尾已到达，返回 -1。 示例： 12byte[] buffer = new byte[1024];int bytesRead = inputStream.read(buffer); int read(byte[] b, int off, int len) 从输入流中读取数据到字节数组中的指定位置。 参数 off 指定写入数据的起始位置，len 指定最大读取字节数。 返回实际读取的字节数，如果流末尾已到达，返回 -1。 示例： 12byte[] buffer = new byte[1024];int bytesRead = inputStream.read(buffer, 0, buffer.length); void close() 关闭输入流并释放与之关联的系统资源。 示例： 1inputStream.close(); long skip(long n) 跳过并丢弃输入流中的 n 个字节。 返回实际跳过的字节数。 示例： 1long skipped = inputStream.skip(100); available() 返回流中当前可读的字节数，但不一定能保证实际读取的字节数。 示例： 1int availableBytes = inputStream.available(); 常见子类： FileInputStream：从文件中读取字节流。 ByteArrayInputStream：从内存中的字节数组中读取字节流。 BufferedInputStream：提供缓冲功能的输入流，能提高读取效率。 DataInputStream：提供读取 Java 原始数据类型的输入流。 示例： 以下是一个简单的使用 FileInputStream 类读取文件内容的示例： 12345678910111213141516import java.io.FileInputStream;import java.io.IOException;public class FileReadExample &#123; public static void main(String[] args) &#123; try (FileInputStream fis = new FileInputStream(&quot;example.txt&quot;)) &#123; int content; while ((content = fis.read()) != -1) &#123; // 打印读取的字节（转换为字符） System.out.print((char) content); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： InputStream 是一个抽象类，不能直接实例化。通常，你会使用其具体子类来进行实际的字节读取操作。 操作完成后，一定要关闭流，以释放系统资源。这通常通过 try-with-resources 语句来自动完成。 OutputStream类OutputStream 是 Java 中用于写入字节流的抽象类。它是所有字节输出流类的超类，提供了基本的输出流操作方法。OutputStream 类的设计使得你可以将字节数据写入各种数据目标，如文件、网络连接、内存等。以下是 OutputStream 类的一些关键点： void write(int b) 将指定的字节写入输出流。 参数 b 是要写入的字节（实际上是一个 int 值，但只使用低 8 位）。 示例： 1outputStream.write(65); // 写入字节 &#x27;A&#x27; void write(byte[] b) 将字节数组中的所有字节写入输出流。 示例： 12byte[] data = &quot;Hello&quot;.getBytes();outputStream.write(data); void write(byte[] b, int off, int len) 将字节数组中的一部分写入输出流。 参数 off 是字节数组中的起始偏移量，len 是要写入的字节数。 示例： 12byte[] data = &quot;Hello World&quot;.getBytes();outputStream.write(data, 0, 5); // 写入 &quot;Hello&quot; void flush() 刷新输出流，确保所有缓冲的字节都被写入到目标地。 示例： 1outputStream.flush(); void close() 关闭输出流并释放与之关联的系统资源。 示例： 1outputStream.close(); 常见子类： FileOutputStream：将字节写入文件。 ByteArrayOutputStream：将字节写入内存中的字节数组。 BufferedOutputStream：提供缓冲功能的输出流，能提高写入效率。 DataOutputStream：提供写入 Java 原始数据类型的输出流。 示例： 以下是一个简单的使用 FileOutputStream 类写入文件的示例： 12345678910111213import java.io.FileOutputStream;import java.io.IOException;public class FileWriteExample &#123; public static void main(String[] args) &#123; try (FileOutputStream fos = new FileOutputStream(&quot;example.txt&quot;)) &#123; String content = &quot;Hello, World!&quot;; fos.write(content.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意: 关闭流：使用完 OutputStream 后一定要关闭流，以释放系统资源。通常使用 try-with-resources 语句来自动关闭流。 缓冲：如果你需要提高写入效率，可以使用 BufferedOutputStream 进行缓冲操作。 写入数据：在写入数据时，可以选择将字节数组、单个字节或字节数组的部分写入流。确保正确处理偏移量和长度，以避免写入不必要的数据或产生异常。 OutputStream 提供了处理字节数据的基本操作，了解其使用方法可以帮助你在处理文件、网络和其他数据目标时有效地输出字节数据。 字符流InputStream和OutputStream在早期的Java版本中就已经存在了，它们是基于字节流的，而基于字符流的Reader和Writer是后来加入作为补充的。 Rreader类Reader 类是 Java 中用于处理字符流的抽象类。它是所有字符输入流类的超类，提供了基本的字符读取操作方法。与 InputStream 类不同，Reader 处理的是字符而不是原始字节，因此它会根据指定的字符编码进行字符转换。 其主要操作方法有下述几种，因与IO类类似，故其不在赘述。 int read() int read(char[] cbuf) int read(char[] cbuf, int off, int len) long skip(long n) boolean ready() void close() 常见子类: FileReader：从文件中读取字符流。 BufferedReader：提供缓冲功能的字符流，能提高读取效率，并且提供了 readLine() 方法以便逐行读取文本。 CharArrayReader：从内存中的字符数组中读取字符流。 StringReader：从内存中的字符串读取字符流。 示例: 以下是一个简单的使用 FileReader 类读取文件内容的示例： 123456789101112131415import java.io.FileReader;import java.io.IOException;public class FileReadExample &#123; public static void main(String[] args) &#123; try (FileReader fr = new FileReader(&quot;example.txt&quot;)) &#123; int character; while ((character = fr.read()) != -1) &#123; System.out.print((char) character); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用 BufferedReader 逐行读取文本的示例： 12345678910111213141516import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderExample &#123; public static void main(String[] args) &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;example.txt&quot;))) &#123; String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： 字符编码：Reader 类会处理字符编码问题，因此在读取文件时，确保文件编码与你的 Reader 配置一致。 关闭流：使用完 Reader 后，一定要关闭流以释放系统资源。通常使用 try-with-resources 语句来自动关闭流。 缓冲：为了提高读取效率，可以使用 BufferedReader 类，它提供了缓冲功能，并且能更高效地读取数据。 Writer类Writer 类是 Java 中用于处理字符流的抽象类。它是所有字符输出流类的超类，提供了基本的字符输出操作方法。与 OutputStream 类不同，Writer 处理的是字符数据，而不是原始的字节数据，因此它会根据指定的字符编码进行字符转换。 void write(int c) 将指定的字符写入输出流。 参数 c 是要写入的字符（实际是一个 int 值，但只使用低 16 位）。 示例： 1writer.write(&#x27;A&#x27;); // 写入字符 &#x27;A&#x27; void write(char[] cbuf) 将字符数组中的所有字符写入输出流。 示例： 12char[] data = &quot;Hello&quot;.toCharArray();writer.write(data); void write(char[] cbuf, int off, int len) 将字符数组中的一部分写入输出流。 参数 off 是字符数组中的起始偏移量，len 是要写入的字符数。 示例： 12char[] data = &quot;Hello World&quot;.toCharArray();writer.write(data, 0, 5); // 写入 &quot;Hello&quot; void write(String str) 将字符串中的所有字符写入输出流。 示例： 1writer.write(&quot;Hello, World!&quot;); void write(String str, int off, int len) 将字符串的指定部分写入输出流。 参数 off 是字符串中的起始位置，len 是要写入的字符数。 示例： 1writer.write(&quot;Hello, World!&quot;, 0, 5); // 写入 &quot;Hello&quot; void flush() 刷新输出流，确保所有缓冲的字符都被写入到目标地。 示例： 1writer.flush(); void close() 关闭输出流并释放与之关联的系统资源。 示例： 1writer.close(); 常见子类: FileWriter：将字符写入文件。 BufferedWriter：提供缓冲功能的字符流，能提高写入效率。 CharArrayWriter：将字符写入内存中的字符数组。 PrintWriter：提供了更多格式化功能的字符输出流，支持打印各种数据类型。 示例: 以下是一个简单的使用 FileWriter 类写入文件的示例： 123456789101112import java.io.FileWriter;import java.io.IOException;public class FileWriteExample &#123; public static void main(String[] args) &#123; try (FileWriter fw = new FileWriter(&quot;example.txt&quot;)) &#123; fw.write(&quot;Hello, World!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用 BufferedWriter 提高写入效率的示例： 123456789101112131415import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class BufferedWriterExample &#123; public static void main(String[] args) &#123; try (BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;example.txt&quot;))) &#123; bw.write(&quot;Hello, World!&quot;); bw.newLine(); // 添加新行 bw.write(&quot;This is a new line.&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： 字符编码：Writer 类会处理字符编码问题，因此在写入文件时，确保文件编码与你的 Writer 配置一致。如果需要特定的编码格式，可以使用 OutputStreamWriter 类来指定编码。 关闭流：使用完 Writer 后，一定要关闭流以释放系统资源。通常使用 try-with-resources 语句来自动关闭流。 缓冲：为了提高写入效率，可以使用 BufferedWriter 类，它提供了缓冲功能，并能更高效地写入数据。 实现用户输入Java提供了java.util.Scanner类，可以直接接收控制台命令行的输入。 使用System.in获取用户输入Java提供了System.in、System.out及System.err类。 System.out是一个已经预先处理过的、被包装成PrintStream的对象。 System.err和System.out一样，也是一个PrintStream。 但System.in就不是了，它是一个未经处理的InputStream。 System.in输入示例： 12345678910import java.io.IOException;public class System_test &#123; public static void main(String[] args) throws IOException &#123; char a; System.out.println(&quot;请输入一个字符：&quot;); a=(char)System.in.read(); System.out.println(&quot;输入的是&quot; + a); &#125;&#125; 使用Scanner类获取用户输入java.util.Scanner类是JDK新增的一个类，可使用该类创建一个命令行读取数据的对象，而不必再进行流的转换。使用方法如下： 1Scannner sc = new Scanner(System.in); 然后我们就可以对sc进行调用操作，比如： 1String n = sc.nextLine(); 这里我们注意了，可以有多种调用方式： next()：字符串 nextInt()：整型 nextDouble()：浮点型 nextLine()：字符串，但可以读入空格 在绝对路径创建文件夹，并创建一个临时txt文件 FileCreateAndDir.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.bayeeaa.demo1.IO_test;import java.io.File;import java.io.IOException;public class FileCreateAndDir &#123; //文件创建和目录 public static boolean createDir(String destDirName)&#123; //创建目录 File dir = new File(destDirName); if(dir.exists())&#123; System.out.println(&quot;目标目录存在！&quot;); return false; &#125; if(!destDirName.endsWith(File.separator))&#123; //结尾是否以&quot;/&quot;结束 destDirName = destDirName + File.separator; &#125; if(dir.mkdir())&#123; //这里创建目录，并返回true System.out.println(&quot;目录成功创建！&quot;); return true; &#125; else&#123; System.out.println(&quot;创建失败！&quot;); return false; &#125; &#125; public static boolean createFile(String filePath)&#123; File file = new File(filePath); if(file.exists())&#123; System.out.println(&quot;目标文件已存在！&quot;); return false; &#125; if(filePath.endsWith(File.separator))&#123; System.out.println(&quot;目标文件不能是文件！&quot;); return false; &#125; if(!file.getParentFile().exists())&#123; System.out.println(&quot;目标文件文件夹不存在，正在创建它！&quot;); if(!file.getParentFile().mkdir())&#123; System.out.println(&quot;创建目标文件失败！&quot;); return false; &#125; &#125; try &#123; if(file.createNewFile())&#123; System.out.println(&quot;文件创建成功！&quot; + filePath); return true; &#125; else&#123; System.out.println(&quot;文件创建失败！&quot;); return false; &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; test： 1234567891011121314package com.bayeeaa.demo1.IO_test;import java.io.*;public class test &#123; public static void main(String[] args) &#123; String dirPath = &quot;C:\\\\Users\\\\yyn19\\\\Desktop\\\\demoTest&quot;; FileCreateAndDir.createDir(dirPath); // 创建目录 String filePath = dirPath + File.separator + &quot;myfile.txt&quot;; // 文件路径,并给出文件名 FileCreateAndDir.createFile(filePath); // 创建文件 &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://bayeeaa.github.io/tags/Java/"}]},{"title":"Java集合框架","slug":"Java集合框架","date":"2024-08-29T08:28:12.000Z","updated":"2024-09-16T07:27:09.462Z","comments":true,"path":"2024/08/29/Java集合框架/","link":"","permalink":"https://bayeeaa.github.io/2024/08/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Java集合框架集合有时又称容方法，简单地说就是个对象，能将具有相同性质的多个元素汇聚成一个整体。 集合框架(Collections Framework)是用来表现和操纵集合的一个统一的体系结构。 Collection接口Collection接口时Java集合框架的最顶层接口，它位于java.util包中，是Set接口和List接口(后面会讲)的父接口。 转换构造法Collection接口实现都有一个带有集合参数的构造方法。也就是说，在这里可以通过”转换”集合的类型来实现存储。 1Collection&lt;String&gt; a = new ArrayList&lt;&gt;(); a可以是一个List、Set或另外一中Collection。通常，习惯地创建一个新的ArrayList，初始化为包含a中的所有元素。 12List&lt;String&gt; list = new ArrayList&lt;String&gt;(a);Set&lt;String&gt; set = new HashSet&lt;String&gt;(a); 通过“转换构造法”，list或set对象就包含了集合a中的所有元素。 Collection接口的定义基本操作： boolean add(E e): 将指定的元素添加到集合中（如果集合允许添加）。 boolean remove(Object o): 从集合中移除指定的元素。 boolean contains(Object o): 检查集合是否包含指定的元素。 int size(): 返回集合中的元素数量。 boolean isEmpty(): 检查集合是否为空。 Iterator&lt;E&gt; iterator(): 返回一个迭代器，用于遍历集合中的元素。 以及批量操作： boolean addAll(Collection&lt;? extends E&gt; c): 批量添加 boolean removeAll(Collection&lt;?&gt; c): 从集合中批量移除元素。 boolean containsAll(Collection&lt;?&gt; c): 检查当前集合是否包含所有传入集合的元素 bollean retainAll(Collection&lt;?&gt; c): 删除当前集合中所有不在指定集合 c 中的元素 void clear(): 移除集合中的所有元素。 数组操作： Object[] toArray(): 将集合转换为数组，数组类型为object &lt;T&gt; T[] toArry(T[] a): 将集合中的元素转换为指定类型的数组，并将其存储在提供的数组中。如果提供的数组足够大，则元素将被存储在这个数组中；否则，将创建一个新的数组。 Collection接口的基本操作123456789101112131415161718dog d1 = new dog(&quot;andy&quot;,5);dog d2 = new dog(&quot;tom&quot;,2);Collection&lt;dog&gt; collection = new ArrayList&lt;&gt;();collection.add(d1);collection.add(d2);for(dog o : collection)&#123; //for-each遍历 System.out.println(o.getName());&#125;Iterator&lt;String&gt; iterator = collection.iterator(); //迭代遍历while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;collection.remove(d1); //删除d1对象collection.clear(); //清空 这里我创建了一个dog对象，并给它name和age。 要注意的是，iterator迭代方法同样有遍历的功能，但是Iterator.remove是修改集合唯一安全的方法。如果要移除当前元素。for-each结构隐藏迭代方法，因此不能调用remove方法。同样在多重集合上进行并行迭代也要用迭代器迭代。 下面演示如何过滤Collection集合： 12345static void filter(Collection&lt;?&gt; c)&#123; for(Iterator&lt;?&gt; it = c.iterator();it.hasNext();)&#123; if(?cond(it.next())) it.remove(); &#125;&#125; Collection接口的批量操作下面展示表现批量操作强大功能的一个示例，从一个名为c的Collection中移除一个指定元素e的所有实例： 1c.removeAll(Collections.singleton(e))； 或者也可以移除所有null元素： 1c.removeAll(Collections.singleton(null))； Collections.singleton是一个静态工厂方法，返回一个只包含指定元素的不可变Set集合(没有重复元素)。 在例子中Collections.singleton(e)方法只包含元素e的Set集合，然后就可以用removeAll删除。 Collection数组操作toArray()方法主要作为集合和老的期望输入数组的API之间的桥梁。 1234567891011// 创建并初始化一个 ListList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);// 使用 toArray() 方法将集合转换为 Object 数组Object[] array = list.toArray();// 使用 toArray(T[] a) 方法将集合转换为指定类型的数组String[] array = list.toArray(new String[0]); Set接口Set是一个不能包含重复元素的接口，是Collection接口的子接口，并且只包含从Collection继承过来的方法，并增加了对add()方法的使用限制，不允许有重复的元素。Set()还修改了equals()和hashCode()方法的实现，允许对Set实例进行内容上的比较，即使它们实现类型不同。如果两个Set实例包含相同的元素，那么它们就是相等的。 Set定义主要方法: 继承了Collection接口的所有方法。 没有专门定义新的方法，但子接口和实现类提供了对集合不重复性要求的具体实现。 主要实现类: HashSet: 基于哈希表的实现，不保证元素的顺序，通常提供快速的插入、删除和查找操作。 TreeSet: 基于红黑树的实现，按自然顺序或构造时提供的比较器进行排序。 LinkedHashSet: 结合了哈希表和链表的特点，保持插入顺序的同时提供较快的操作速度。 Java平台包含3个通用目的的Set实现就是HashSet、TreeSet、LinkedHashSet这三个。 Set接口的基本操作那么Set和Collection有什么区别呢？下面看这个实例。 12345678910111213141516171819202122import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class CollectionSetExample &#123; public static void main(String[] args) &#123; // 使用 Collection 接口 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); collection.add(&quot;Apple&quot;); collection.add(&quot;Banana&quot;); collection.add(&quot;Cherry&quot;); System.out.println(&quot;Collection: &quot; + collection); // 使用 Set 接口 Set&lt;String&gt; set = new HashSet&lt;&gt;(); //这里用了哈希存放 set.add(&quot;Apple&quot;); set.add(&quot;Banana&quot;); set.add(&quot;Apple&quot;); // 重复元素不会被添加 System.out.println(&quot;Set: &quot; + set); &#125;&#125; 我们可以看到，这其中最大的区别就是Set不能重复添加元素。 Set接口的批量操作批量操作特别适合于Set接口： s1.containsAll(s2)：如果s2是s1的一个子集合，返回true s1.addAll(s2)：将s1变换为s1和s2的并集 s1.retain(s2)：将s1变换为s1和s2的交集 s1.removeAll(s2)：将s1不对称地变换为s1和s2的差集 addAll示例： 12345678910111213Set&lt;String&gt; set1 = new HashSet&lt;&gt;();set1.add(&quot;Apple&quot;);set1.add(&quot;Banana&quot;);Set&lt;String&gt; set2 = new HashSet&lt;&gt;();set2.add(&quot;Cherry&quot;);set2.add(&quot;Date&quot;);// 将 set2 的所有元素添加到 set1 中set1.addAll(set2);System.out.println(&quot;Set1 after addAll: &quot; + set1);//Set1 after addAll: [Apple, Banana, Cherry, Date] removeAll示例： 12345678910111213Set&lt;String&gt; set1 = new HashSet&lt;&gt;();set1.add(&quot;Apple&quot;);set1.add(&quot;Banana&quot;);set1.add(&quot;Cherry&quot;);Set&lt;String&gt; set2 = new HashSet&lt;&gt;();set2.add(&quot;Banana&quot;);set2.add(&quot;Cherry&quot;);// 从 set1 中移除 set2 中的所有元素set1.removeAll(set2);System.out.println(&quot;Set1 after removeAll: &quot; + set1); List接口List是一个有序的集合(又是被称为序列)。List可以包含重复的元素。除了从Collection继承过来的操作之外，List接口还包括以下操作： 按位置访问：根据元素在序列中的位置索引访问元素 查找：在序列中查找指定对象，并返回其位置索引 迭代：扩展了Iteractor接口，以利用序列的顺序特性 List子集合：在序列上执行任意范围的操作 List接口的定义如下： 1234567891011121314import java.util.Collection;public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; void add(int index, E element); boolean addAll(int index, Collection&lt;? extends E&gt; c); E get(int index); E set(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; Java平台常见的List实现包括： ArrayList（基于动态数组）、LinkedList（基于双向链表）和 Vector（线程安全的动态数组）。 List接口的操作1. 添加元素 void add(int index, E element) 在指定位置插入元素。 示例: 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(1, &quot;Orange&quot;); // 在位置 1 插入 &quot;Orange&quot; boolean addAll(int index, Collection&lt;? extends E&gt; c) 从指定位置开始，将指定集合中的所有元素添加到当前列表中。 示例: 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);List&lt;String&gt; newItems = Arrays.asList(&quot;Orange&quot;, &quot;Grapes&quot;);list.addAll(1, newItems); // 从位置 1 开始添加 newItems 中的元素 2. 访问元素 E get(int index) 获取指定位置的元素。 示例: 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);String item = list.get(0); // 获取位置 0 的元素 E set(int index, E element) 替换指定位置的元素。 示例: 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.set(1, &quot;Orange&quot;); // 将位置 1 的元素替换为 &quot;Orange&quot; 3. 删除元素 E remove(int index) 移除指定位置的元素。 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.remove(1); // 移除位置 1 的元素 4. 查找元素 int indexOf(Object o) 返回指定元素第一次出现的索引，如果不在列表中，则返回 -1。 示例: 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);int index = list.indexOf(&quot;Banana&quot;); // 获取 &quot;Banana&quot; 的位置 int lastIndexOf(Object o) 返回指定元素最后一次出现的索引，如果不在列表中，则返回 -1。 示例: 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Banana&quot;);int index = list.lastIndexOf(&quot;Banana&quot;); // 获取 &quot;Banana&quot; 最后出现的位置 5. 子列表 List&lt;E&gt; subList(int fromIndex, int toIndex) 返回当前列表中从 fromIndex（包含）到 toIndex（不包含）的部分列表。 1234567List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);list.add(&quot;Date&quot;);List&lt;String&gt; subList = list.subList(1, 3); // 获取子列表 [Banana, Cherry] 6. 迭代器 ListIterator&lt;E&gt; listIterator() 返回一个 ListIterator，从列表的开始处迭代。 ListIterator&lt;E&gt; listIterator(int index) 返回一个 ListIterator，从指定的位置开始迭代。 1234567891011121314List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);ListIterator&lt;String&gt; iterator = list.listIterator();while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;ListIterator&lt;String&gt; iteratorFromIndex = list.listIterator(1);while (iteratorFromIndex.hasNext()) &#123; System.out.println(iteratorFromIndex.next());&#125; Map接口Map接口的定义1234567891011121314151617181920212223242526272829import java.util.Collection;import java.util.Set;public interface Map&lt;K, V&gt; &#123; //基本操作 int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); //批量操作 void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); //集合视图 Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); //嵌套接口 interface Entry&lt;K, V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); &#125;&#125; Java平台包括3中通用的Map实现：HashMap、TreeMap和LinkedHashMap。 Map接口的基本操作1. 基本操作 int size() 返回 Map 中键值对的数量。 示例: 12345Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;One&quot;, 1);map.put(&quot;Two&quot;, 2);int size = map.size(); // 返回 2 boolean isEmpty() 检查 Map 是否为空（即是否没有键值对）。 示例: 1boolean isEmpty = map.isEmpty(); // 返回 false 2. 键和值的存在性检查 boolean containsKey(Object key) 检查 Map 是否包含指定的键。 示例: 1boolean hasKey = map.containsKey(&quot;One&quot;); // 返回 true boolean containsValue(Object value) 检查 Map 是否包含指定的值。 示例: 1boolean hasValue = map.containsValue(2); // 返回 true 3. 获取和设置键值对 V get(Object key) 根据键获取对应的值。如果键不存在，则返回 null。 示例: 1Integer value = map.get(&quot;One&quot;); // 返回 1 V put(K key, V value) 将指定的键值对添加到 Map 中。如果键已经存在，则更新对应的值，并返回之前的值。 示例: 1map.put(&quot;Three&quot;, 3); // 将 &quot;Three&quot; 键与 3 值添加到 map 中 V remove(Object key) 根据键移除对应的键值对，并返回被移除的值。 示例: 1Integer removedValue = map.remove(&quot;Two&quot;); // 移除 &quot;Two&quot; 键对应的值 2 4. 批量操作 void putAll(Map&lt;? extends K, ? extends V&gt; m) 将指定 Map 中的所有键值对添加到当前 Map 中。 示例: 12345Map&lt;String, Integer&gt; anotherMap = new HashMap&lt;&gt;();anotherMap.put(&quot;Four&quot;, 4);anotherMap.put(&quot;Five&quot;, 5);map.putAll(anotherMap); // 将 anotherMap 的所有键值对添加到 map 中 void clear() 移除 Map 中的所有键值对，使 Map 变为空。 示例: 1map.clear(); // 清空 map 5. 视图操作 Set&lt;K&gt; keySet() 返回 Map 中所有键的集合。 示例: 1Set&lt;String&gt; keys = map.keySet(); // 获取 map 的所有键 Collection&lt;V&gt; values() 返回 Map 中所有值的集合。 示例: 1Collection&lt;Integer&gt; values = map.values(); // 获取 map 的所有值 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 返回 Map 中所有键值对的集合，每个键值对作为 Map.Entry 对象存在。 示例: 1234Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());&#125; 6. 嵌套接口 Entry K getKey() 返回 Map.Entry 对象中的键。 V getValue() 返回 Map.Entry 对象中的值。 V setValue(V value) 设置 Map.Entry 对象中的值，并返回之前的值。 boolean equals(Object o) 判断两个 Map.Entry 对象是否相等。 int hashCode() 返回 Map.Entry 对象的哈希码。 示例比如我们可以做一个数组中单词的显示次数小程序： 1234567Map&lt;String,Integer&gt; m = new HashMap&lt;&gt;();for(String a : args)&#123; Integer freq = m.get(a); m.put( a, (freq == null) ? 1 : freq+1 ); //（键，值）&#125;System.out.println(m.size() + &quot;个不同的单词&quot;);System.out.println(m); args: 1java to is is be if if output: 125个不同的单词&#123;java=1, be=1, is=2, to=1, if=2&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"AutoCAD学习笔记","slug":"AutoCAD学习笔记","date":"2024-08-27T15:20:24.000Z","updated":"2024-08-28T06:54:22.527Z","comments":true,"path":"2024/08/27/AutoCAD学习笔记/","link":"","permalink":"https://bayeeaa.github.io/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"AutoCAD学习笔记这段时间在金工行业实习了一段时间，了解到一般机械制图是用到cad来绘画草图，然后再将画出的.dwg文件导入到ug(或者solidworks)中将其拉伸成3d图形。下面我将记录下这段时间使用cad的较多的快捷键以及指令操作。 界面设置介于方便我们操作，免得每次都要点开找，我们可以将一些常用的操作直接放在边框layout处。 那么怎么设置呢？我们可以右键上方layout处(灰色处)，然后将光标放到AutoCAD上： 然后将出现的小框拖到上述界面的位置即可，这样方便我们使用。 命令操作常用快捷键 快捷键 操作 快捷键 操作 l (L) 直线 s 拉伸 e 清除 tr 修剪 co 复制 ex 延伸 m 移动 cha 倒直角 o 偏移 f 倒圆角 c 圆 dli 直线标注 上面这些快捷键只需要对着界面输入然后按下空格(或者回车)后就可以触发。 还有一点，就是我们要是按下空格就可以重复上一个操作，比如我c完一个圆后还想画一个圆，那就再按下空格，就可以直接再画一个圆。 c圆我们对着界面输入c然后空格后，光标处就会变成十字形，然后只需在图中点一下就可以圆出来： 注意我们可以看到下面命令框告诉我们可以输入圆的半径，比如我们想让圆的半径为10mm，那我们就可以输入10然后空格，或者想要直径为10mm，那就要输入d+空格，然后再输入10。 我们可以用旁边的标记列操作看下是否是10mm： 注意这里只是用于检查，实际标注不能用和轮廓线一样颜色的线。 l直线这里注意我们画下直线的时候会出现两个标注： 长度和角度可以用tab键来切换输入(如果没有这两个框是没有点开正交模式左边那个加号按钮)。 如果我们希望更方便操作角度我们可以开启下面的两个模式： 正交模式 (f8)：点开后直线就是只能为直角(正交)状态。 极角模式 (f10)：可以设置角度，点开到相应角会有直线吸附。 e清除这个很好理解，我们只需要选中需要被删除的线段，按下e+空格即可。 co复制我们co完后指令框显示： 也就是告诉我们需要选中对象。比如我像copy一个圆，那我选择这个圆后，再按下空格，然后出现： 告诉我们寻找基准线，我以点圆的中心为例。 可以看到一个新圆已经被复制出来。 m移动移动跟复制同理，需要选中对象，然后确定基准点来移动。 o偏移o+空格后出现下图 当我们输入距离(比如8mm)，然后再空格，选中对象就可以了 ro旋转和上一个一样，都是选中对象，然后选中基准点，再输入旋转角度。 tr修剪这个特殊点，比如我们要删除这段： 我们就可以tr+两个空格(注意是两个空格)。然后就可以对这段点一下就可以删除了。 ex延伸这个需要选中两个对象，要求这两个对象是要有交点的，然后就可以延长一个对象直至相交。 f倒圆角、cha倒直角倒角只需要我们输入f + r(倒角半径)，然后再指定两个对象即可。 dli正交直线标注也就是直线注释，这里注意是正交线，如果是斜线的话要输入dal。 螺纹孔标注这里附上一张实习用到的表： 我们可以看到不同螺纹孔大小都是有标准的螺纹距离和深度的。比如我们想话一个M6的螺纹孔，我们要这样画： 由于螺纹只有长度的，因此我们在画实际钻孔时要减去螺纹的长度。注意图中标注的细节，这些可以在图层里设置，方便我们选用： 阴影标注找到左边列的打圈处，选中。 点击“添加：拾取点”就可以选择需要阴影的位置了，选择成功再空格选择比例、样例，点击确定即可。 一圆与两圆相切同样我们c+空格打开圆的快捷键，然后选择图中操作。 然后选择圆中需要相切的两个位置，再输入圆的半径即可。 块创建块说白了就是自己写一个模板然后方便下次直接用。 比如我随便画一个矩形想作为块： 我们可以点开绘画然后找到块创建 然后就可以输入名称保存了，需要时就i + 空格换出块就行了。 实际运用中比如这个粗糙度的标注符号在cad里是没有的，那就可以自己画一个然后创建块，方便后续使用。","categories":[],"tags":[{"name":"制图","slug":"制图","permalink":"https://bayeeaa.github.io/tags/%E5%88%B6%E5%9B%BE/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2024-08-21T14:17:45.000Z","updated":"2024-09-16T07:27:46.866Z","comments":true,"path":"2024/08/21/KMP算法/","link":"","permalink":"https://bayeeaa.github.io/2024/08/21/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"KMP算法KMP:一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。——某位哲学大师(雾) 上面这句话很直观的体现了kmp算法的一个重要的特点：前后缀比较。比如我们看下面这道例题： 找出字符串中第一个匹配项的下标给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例 1： 123输入：haystack = &quot;abxabcabcaby&quot;, needle = &quot;abcaby&quot;输出：6解释：&quot;abcaby&quot; 在下标 6 处匹配。 示例 2： 123输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。 提示： 1 &lt;= haystack.length, needle.length &lt;= 104 haystack 和 needle 仅由小写英文字符组成 普通暴力解法最直观的解法就是双循环，把haystack里面的字符都遍历一遍，然后再看这个字符后面是不是和needle匹配的，要是有不匹配的，直接break。 123456789101112131415161718192021222324class Solution &#123; public int strStr(String haystack, String needle) &#123; if (needle.length() == 0) &#123; return 0; // 如果 needle 是空字符串，则返回 0 &#125; if (haystack.length() &lt; needle.length()) &#123; return -1; // 如果 haystack 比 needle 短，则不能包含 needle &#125; for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) &#123; int j; for (j = 0; j &lt; needle.length(); j++) &#123; if (haystack.charAt(i + j) != needle.charAt(j)) &#123; break; // 如果字符不匹配，退出内层循环 &#125; &#125; if (j == needle.length()) &#123; return i; // 如果完整匹配，返回起始位置 &#125; &#125; return -1; // 如果没有找到 needle，返回 -1 &#125;&#125; 可以看到这里套了双层循环，假设m&#x3D;haystack.length() - needle.length() ,n&#x3D;needle.length()那么时间复杂度是O(mn)。但是如果我们使用kmp算法，就可以让时间复杂度控制到O(m+n)。 KMP思路我们想想当在字符串比较的时候，什么操作是多余的操作？ 12text: abxabcabcabypattern: abcaby 以上述例子比较的时候可以发现：在text的[3:7]部分是和pattern[0:4]部分是重合的，由于最后一个y和text中的下一个c没对上，所以没有配对成功，但是在pattern这部分前面的[0:4]中前缀”ab”和后缀的”ab”是一样的，说明我们只需要重新比较text中[6:7]这个”ab”后面的与pattern[0:1]这个”ab”后面的即可，不用再重新比较”ab”。这样就可以优化算法。 next表为了方便我们这样索引，我们将要建立一个next表，里面记录的是由后缀到前缀的索引值，也就是说当我们匹对字符串的时候，如果发现不对，那只需要通过索引值跳到需要比较的部分。 建立思路首先我们给pattern字符串前面加上一个哨兵空字符，为什么要加这个呢？这里是由于之后我们比较的时候如果指针指的字符不匹配，那么我们就要找到指针前面那个字符的所对应的索引值，如果我们加上一个哨兵，那就可以每次不用指针减一，直接j就可以(有点拗口，之后看图会清楚点)。 以上就是next表创建的手画过程，用代码来写就是这样： 12345for(int i=2, j=0;i&lt;=m;i++)&#123; //p就是pattern的缩写，通过toCharArray()来变成字符数组 while(j&gt;0 &amp;&amp; p[j+1] != p[i]) j = next[j]; //如果对不上，就让j不断往前找，直到找到能对上的数 if(p[j+1] == p[i]) j++; //如果对上了，就让j向后移动一位 next[i] = j; //next赋值操作&#125; 可以看到i就是从2开始的，所以我在途中所以为1的地方就没有写值。 与字符串开始匹配 这里发现无法匹配后就直接通过b的前一个字符(a)的索引来向前找有没有为”x”的字符(然而没有)，于是j就停在哨兵字符上。 发现不符，j不动(因为j已经是最上面了，找不上去了)，text中的字符再往后面找。然后重复上面的步骤不停往后比对。最后发现”y”和⑥的”c”不符，于是乎j就往下找(此时j下面的索引为2，因此j跳到”b”上，j+1为”c”)，此时我们就只需要比较”c”和text后面的值了(因为我们知到了”ab”肯定是一样的，不用再比较了)。 这一步就是kmp算法的核心，有了上面这个思路我们就可以解决上面的例题了。 123456789101112131415161718192021222324252627class Solution &#123; public int strStr(String ss, String pp) &#123; if (pp.isEmpty()) return 0; int n = ss.length(), m = pp.length(); //注意长度的取值是在加入哨兵之前的 ss = &quot; &quot; + ss; //加入哨兵 pp = &quot; &quot; + pp; char[] s = ss.toCharArray(); char[] p = pp.toCharArray(); int[] next = new int[m + 1]; //创建next表 for(int i=2, j=0;i&lt;=m;i++)&#123; //填写next表 while(j&gt;0 &amp;&amp; p[j+1] != p[i]) j = next[j]; //找不到的情况，让&quot;j&quot;往前找 if(p[j+1] == p[i]) j++; //核对成功&quot;j&quot;往前走 next[i] = j; //将目前这个下标的值改成此时&quot;j&quot;的值 &#125; for(int i=1,j=0;i&lt;=n;i++)&#123; //核对字符 while(j&gt;0 &amp;&amp; s[i] != p[j+1]) j = next[j]; //找不到的情况，让&quot;j&quot;往前找 if(p[j+1] == s[i]) j++; //核对成功往前走 if(j == m)&#123; //长度相等就return return i - m; //输出第一个元素下标 &#125; &#125; return -1; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"static静态标签","slug":"static静态标签","date":"2024-08-14T02:17:15.000Z","updated":"2024-09-16T07:27:39.454Z","comments":true,"path":"2024/08/14/static静态标签/","link":"","permalink":"https://bayeeaa.github.io/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","excerpt":"","text":"static静态变量我们都知道在测试文件中都需要有： 1public static void main(String[] args) 这段文字，而文字中public void main这几个我都已经数值，但是这个static是什么意思呢？今天我们来一起探讨一下这个词语。 属性静态调用当我们遇到不同的成员需要有相同的属性的时候，为了方便同时输入和调用属性，我们引入了static(静态)修饰符： user: 123456789101112131415161718192021222324252627282930313233package com.bayeeaa.demo1.d9_static;public class user &#123; private String name; private int number; public static String tea; //static修饰tea这个变量 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; public user(String name, int number) &#123; this.name = name; this.number = number; &#125; public void say() &#123; System.out.println(&quot;hi&quot;); &#125;&#125; test: 1234567891011package com.bayeeaa.demo1.d9_static;public class test &#123; public static void main(String[] args) &#123; user u1 = new user(&quot;bb&quot;,123); user u2 = new user(&quot;ye&quot;,11); user.tea = &quot;black tea&quot;; //直接对类进行调取 System.out.println(u2.tea); //black tea System.out.println(u1.tea); //black tea &#125;&#125; 我们可以看到当我们给tea用static修饰了之后，在test文件中我们就可以直接用类来进行赋值而不需要用成员来赋值，并且赋值后每个成员所访问的值都是一样的。被static所修饰的成员变量叫做静态变量，它有这三个特点： 被该类所有对象共享 不属于对象，属于类 随着类的加载而加载，优先于对象的存在 当然被static修饰的成员方法，叫做静态方法，它有这些特点： 多用在测试类和工具类中 Javabean类中很少会用到 这里我们就可以讨论到工具类的创建。 工具类创建创建一个工具类，首先我们要将其私有化，这样外部就不会创建这个类的对象了(因为我们这个要让这个类作为工具，那我们就要写死在这里了，不能再让别人有所操作，不然工具变化会带来不便)： 123public class ArrUtil &#123; private arrUtil()&#123;&#125;&#125; 我们写一个工具类的例子： ArrUtil: 12345678910111213141516171819202122232425package com.bayeeaa.demo1.d9_static;import java.util.ArrayList; //集合listpublic class ArrUtil &#123; private ArrUtil()&#123;&#125;; //工具类私有化 //设置为静态方便调用 public static int get_sum(int[] arr)&#123; //计算数组所有数据和 int sum=0; for (int i = 0; i &lt; arr.length; i++) &#123; sum = sum + arr[i]; &#125; return sum; &#125; public static int get_num_sum(ArrayList&lt;user&gt; list)&#123; //计算集合中所有对象的num属性和 int sum = 0; for (int i = 0; i &lt; list.size(); i++) &#123; sum = sum + list.get(i).getNumber(); &#125; return sum; &#125;&#125; test: 1234567891011121314151617181920212223package com.bayeeaa.demo1.d9_static;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3,4,5,6&#125;; System.out.println(ArrUtil.get_sum(a)); //输出数组的数字和 ArrayList&lt;user&gt; list = new ArrayList&lt;&gt;(); //这是个集合 user u1 = new user(&quot;ye&quot;,1); user u2 = new user(&quot;yee&quot;,2); user u3 = new user(&quot;yeee&quot;,12); list.add(u1); //对象压入集合 list.add(u2); list.add(u3); System.out.println(ArrUtil.get_num_sum(list)); //输出集合中num的和 &#125;&#125; 可以看到可以直接通过 类名.方法名() 来调用工具。 this关键字其实，static有这几个注意事项： 静态方法中，只能访问静态 非静态方法可以访问所有 静态方法中没有this关键字 而这几个关键都和this关键字有关。以下我来举一些例子。 test： 1234567891011package com.bayeeaa.demo1.d9_static;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; methods_class pj = new methods_class(); pj.repeat(); &#125;&#125; methods_class： 123456789101112131415package com.bayeeaa.demo1.d9_static;public class methods_class &#123; String s; public void repeat(methods_class this)&#123; System.out.println(this); //输出com.bayeeaa.demo1.d9_static.methods_class@b4c966a &#125; public static void again()&#123; System.out.println(this); //飘红，静态方法中没有this &#125;&#125; 我在methods_class文件中输出了两个方法，一个是非静态方法，一个是静态方法，当我们分别用test文件来打印的时候会发现第一个repeat方法打印出了对象的地址，而第二个again方法会报错。 在我们平时使用非静态方法应该是不会在非静态方法中手动调入methods_class this这个值的，但是我们却可以直接用方法调用，这是因为在非静态方法中是默认包括this的，而this的赋值又由jvm调取。所以说在非静态方法中如果我们要调用参数，比如num，实际上应该是这样的： 123public void repeat(methods_class this)&#123; System.out.println(this.s);&#125; 但是通过上图的报错我们可以看到静态方法中是没有this的。因此在其中要是强行引入this会导致报错。 有了这样的解释就可以理解上面的三个结论了。 内存解释在作内存解释之前我们要知道： 栈内存（Stack Memory） 结构和管理方式： 栈内存按照先进后出的原则进行管理（LIFO，即 Last In, First Out）。 内存分配和回收由系统自动管理。每当一个函数被调用时，系统会在栈上为其分配内存，函数返回时，这部分内存会被自动释放。 用途： 用于存储局部变量、函数调用参数和返回地址等。 栈内存的管理非常高效，因为内存分配和释放的操作非常简单，只需调整栈顶指针即可。 特点： 内存分配速度快。 栈内存的大小通常较小，固定大小，超过限制会导致栈溢出（stack overflow）。 数据的生命周期由函数调用的生命周期决定，一旦函数返回，栈内存中的数据就会失效。 堆内存（Heap Memory） 结构和管理方式： 堆内存没有固定的管理顺序，分配和释放内存是由程序员或垃圾回收机制管理的。 内存的分配和释放可以发生在程序的任何地方，不像栈内存那样有固定的顺序。 用途： 用于动态分配内存，比如创建对象、数组等，需要程序员显式地请求内存空间。 适用于需要在多个函数调用间共享数据的情况。 特点： 内存分配和释放相对较慢，因为涉及到更复杂的管理机制。 堆内存的大小通常较大，由操作系统和系统配置决定。 需要程序员显式管理内存，未正确释放的内存会导致内存泄漏（memory leak），一些语言如 Java 和 Python 使用垃圾回收机制来自动处理这一问题。 总结 栈内存适用于存储生命周期短、大小固定的数据，管理简单且高效。 堆内存适用于存储生命周期长或大小不确定的数据，管理复杂但灵活。 我们可以简单的将内存划为三个区域： 字节文件加载：引入main文件，加载里面的方法、类文件中的属性、静态属性等等。 然后开始创建对象，在堆内存中开辟一块地，并返回其地址给对象pj。 然后pj就可以根据地址去寻找所要找的元素。 main的解释现在我们再来看下我们每次的入口文件： 1public static void main(String[] args) public： 被JVM调用，访问权限足够大 static：被JVM调用，不用创建对象，直接类名访问。因为main方法是静态的，所以测试类中其他方法也需要是静态的。(这里注意下,不是静态的叫实例变量,非static方法需要new一个实例出来才能使用,这里意思是main默认只能调用静态方法,实例要new) void：被JVM调用，不需要给JVM返回值 main：一个通用的名称，虽然不是关键字，但是被JVM识别 String[] args：以前用于接收键盘录入数据的，现在没有，被保留是为了上下版本兼容","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"Java面向对象编程封装","slug":"Java面向对象编程封装","date":"2024-08-04T07:14:43.000Z","updated":"2024-09-16T07:27:15.392Z","comments":true,"path":"2024/08/04/Java面向对象编程封装/","link":"","permalink":"https://bayeeaa.github.io/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/","excerpt":"","text":"面向对象编程封装我们先从最简单的一个对象设置开始，设置一个phone对象，并赋予里面brand和number，为了进行比对，我让number私有化，而让brand变成public。 主入口文件： 1234567891011package com.bayeeaa.demo1;public class newphone &#123; public static void main(String[] args) &#123; phone p = new phone(); //通过：类名 对象名 = new 类名()来自定义对象 p.brand = &quot;小米&quot;; //这里为了形成对比没有让brand私有化 p.setNumber(20); System.out.println(p.getNumber()); &#125;&#125; 类文件： 1234567891011121314151617181920212223package com.bayeeaa.demo1;public class phone &#123; private int number; //private使这个number私有化，让其更改操作只能在本类中实现 String brand; public int getNumber()&#123; //这里方便输出内容 return number; &#125; public void setNumber(int n)&#123; //通过方法使对象值在本函数中实现改变，函数名最好用set+双驼峰写法 if(n&gt;=18 &amp;&amp; n&lt;50)&#123; number = n; &#125;else&#123; System.out.println(&quot;输入不被允许&quot;); &#125; &#125; public void call()&#123; System.out.println(&quot;手机在打电话&quot;); &#125; &#125; 我们可以看到当number被私有化后，其值的修改就只能在类文件中发送，这样可以提高文件的安全性，我们只要通过调用getNumber和setNumber函数就可以实现值的传递并修改。 两种不同的构造方式空参构造：123public phone()&#123; &#125; 不带任何的参数。 有参构造：1234public phone(String brand,int number)&#123; this.brand = brand; //this.brand指的是类中的brand，是成员变量。右边的brand是方法里的局部变量(this遵循就近原则) this.number = number;&#125; 这里的方法不带void或int等，没有return，是由于它的执行是由jvm调动的，所以主函数调用时候就会执行，无需手动执行。 主函数： 1phone p = new phone(&quot;小米&quot;,20); //有参函数直接可以传入数据 这样就可以直接传入参数。 快捷键：1234567public class User &#123; private String name; private int number; // alt + INSERT就可以帮我们快速生成constructer和set,get函数 // ptg插件也可以帮我们快速构造JAVABEAN&#125; alt + INSERT ptg这个方法需要在setting中下载ptg插件。 通过快捷键我们可以快速的进行javabean构造。 文字游戏的简单应用我们可以设置一个文字游戏，通过血量，攻击力等为对象创建属性，然后循环攻击最后输出结果。 类文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.bayeeaa.demo1.d3; //这里是package，不是import,这是类文件和主入口文件的区别import java.util.Random;public class Role &#123; private int blood; private String name; String[] attack_desc = &#123; &quot;虚弱地&quot;, //1~5 &quot;小心地&quot;, //6~10 &quot;用力地&quot;, //10~20 &#125;; String[] injureds_desc = &#123; &quot;他似乎自信满满&quot;, //HP 100~80 &quot;他认为还有胜算&quot;, //HP 79~50 &quot;他还不肯认输&quot;, //HP 49~20 &quot;他疲惫不堪&quot; //HP 20~0 &#125;; public Role() &#123; &#125; public Role(int blood, String name) &#123; //有参构造 this.blood = blood; //this所表示的就是这个对象的值 this.name = name; &#125; public int getBlood() &#123; //得到血量 return blood; &#125; public void setBlood(int blood) &#123; //设置血量 this.blood = blood; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int get_attack_desc(int hurt) &#123; //要注意这里函数最后无论如何都是要return 0的 if(hurt&lt;=5 &amp;&amp; hurt&gt;0) return 0; else if (hurt&lt;=10 &amp;&amp; hurt&gt;5) return 1; else if (hurt&lt;=20 &amp;&amp; hurt&gt;10) return 2; return 0; &#125;; public int get_injureds_desc(int remain) &#123; if(remain&lt;=100 &amp;&amp; remain&gt;=80) return 0; if(remain&lt;80 &amp;&amp; remain&gt;=50) return 1; if(remain&lt;50 &amp;&amp; remain&gt;=20) return 2; if(remain&lt;20 &amp;&amp; remain&gt;=0) return 3; return 0; &#125; public void attack(Role role)&#123; //Role赋予role这个变量意义，也就是变成了对象 Random r = new Random(); int hurt = r.nextInt(20) + 1; int remainblood = role.getBlood() - hurt; remainblood = remainblood &lt; 0 ? 0 : remainblood; //三元判断，&quot;?&quot;左边为结果，true就是左边的，false为右边 role.setBlood(remainblood); System.out.println(this.getName() + attack_desc[get_attack_desc(hurt)] + &quot;打了&quot; + role.getName() + &quot;&quot; + hurt + &quot;点血，&quot; + role.getName() +&quot;还剩&quot; + role.getBlood() + &quot;，&quot; + injureds_desc[get_injureds_desc(remainblood)]); //this为调用对象，这里的role就是调入参数 &#125;&#125; 主入口： 1234567891011121314151617181920package com.bayeeaa.demo1.d3;public class RoleTest &#123; public static void main(String[] args) &#123; Role r1 = new Role(100,&quot;500c&quot;); Role r2 = new Role(100,&quot;joker&quot;); while(true)&#123; r1.attack(r2); if(r2.getBlood() == 0)&#123; System.out.println(r1.getName() + &quot; Win&quot;); break; &#125; r2.attack(r1); if(r1.getBlood() == 0)&#123; System.out.println(r2.getName() + &quot; Win&quot;); break; &#125; &#125; &#125;&#125; 其中一次运行结果： 12345678910111213141516171819202122500c用力地打了joker11点血，joker还剩89，他似乎自信满满joker用力地打了500c16点血，500c还剩84，他似乎自信满满500c虚弱地打了joker4点血，joker还剩85，他似乎自信满满joker用力地打了500c17点血，500c还剩67，他认为还有胜算500c虚弱地打了joker4点血，joker还剩81，他似乎自信满满joker用力地打了500c16点血，500c还剩51，他认为还有胜算500c小心地打了joker7点血，joker还剩74，他认为还有胜算joker用力地打了500c19点血，500c还剩32，他还不肯认输500c用力地打了joker17点血，joker还剩57，他认为还有胜算joker虚弱地打了500c4点血，500c还剩28，他还不肯认输500c小心地打了joker10点血，joker还剩47，他还不肯认输joker虚弱地打了500c1点血，500c还剩27，他还不肯认输500c用力地打了joker19点血，joker还剩28，他还不肯认输joker用力地打了500c16点血，500c还剩11，他疲惫不堪500c小心地打了joker7点血，joker还剩21，他还不肯认输joker虚弱地打了500c2点血，500c还剩9，他疲惫不堪500c虚弱地打了joker5点血，joker还剩16，他疲惫不堪joker小心地打了500c8点血，500c还剩1，他疲惫不堪500c用力地打了joker17点血，joker还剩0，他疲惫不堪500c WinProcess finished with exit code 0 可以看到我在类文件中先是设置了name和blood两个参数，而其攻击值是随机生成的。我也在类函数中加入了attack_desc和injureds_desc两个字符串数组来形容当前两人的状态。具体解释看代码中的注释。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"Vue的生命周期","slug":"Vue的生命周期","date":"2024-08-03T18:01:21.000Z","updated":"2024-08-04T07:04:52.465Z","comments":true,"path":"2024/08/04/Vue的生命周期/","link":"","permalink":"https://bayeeaa.github.io/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"Vue生命周期通俗的讲就是：一个vue实例从创建到销毁的整个过程 ①创建(响应式数据) ②挂载(渲染模板) ③更新(修改数据更新视图) ④销毁(关闭页面,销毁实例) Vue生命周期函数 创建阶段（Creation）： beforeCreate：实例刚被创建，数据观测和事件机制初始化之前被调用。 created：实例已经创建完成，完成数据观测、属性和方法的运算，初始化事件等。 挂载阶段（Mounting）： beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted：实例已经挂载到 DOM 上后被调用。 更新阶段（Updating）： beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 updated：数据更新后调用，发生在虚拟 DOM 重新渲染和打补丁之后。 销毁阶段（Destroying）： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：实例销毁后调用。在这一步，所有事件监听器被移除，所有子实例被销毁。 错误处理阶段（Error Handling）： errorCaptured：当子组件抛出错误时会触发该钩子。 为了深入的理解这段话，我们要知道什么是实例 实例在 Vue.js 中，”实例”（Instance）是指通过 Vue 构造函数创建的一个 Vue 实例对象。每个 Vue 应用都是通过创建一个 Vue 实例来实现的。当您使用 Vue 构造函数创建一个实例时，您可以传入一个选项对象，用于配置该实例的行为。 在 Vue 实例中，您可以定义数据、计算属性、方法、生命周期钩子函数等。这些属性和方法定义了该实例的行为和功能。Vue 实例还可以与 DOM 元素进行绑定，从而实现数据的双向绑定、事件处理等功能。 下面是一个简单的示例，演示了如何创建一个 Vue 实例： 12345678910111213141516// 创建一个 Vue 实例var vm = new Vue(&#123; // 选项对象 el: &#x27;#app&#x27;, // 指定要挂载的元素 data: &#123; message: &#x27;Hello, Vue!&#x27; &#125;, methods: &#123; greet: function() &#123; alert(this.message); &#125; &#125;, created: function() &#123; console.log(&#x27;Vue 实例已创建&#x27;); &#125;&#125;); 在上面的示例中，我们创建了一个 Vue 实例 vm，并传入了一个选项对象，其中包含了 el、data、methods 和 created 等属性。这个实例可以通过 vm 来访问，并且可以调用定义的方法、访问数据等。 Vue3 Composition API进入到vue3后，组合式API大为推广，在这其中的生命钩子函数有了更灵活的运用，有了这样的变化： onBeforeMount: 在组件挂载之前执行的函数，类似于 Vue 2.x 中的 beforeMount 钩子函数。 onMounted: 在组件挂载到 DOM 后执行的函数，类似于 Vue 2.x 中的 mounted 钩子函数。 onBeforeUpdate: 在组件更新之前执行的函数，类似于 Vue 2.x 中的 beforeUpdate 钩子函数。 onUpdated: 在组件更新完成后执行的函数，类似于 Vue 2.x 中的 updated 钩子函数。 onBeforeUnmount: 在组件卸载之前执行的函数，类似于 Vue 2.x 中的 beforeUnmount 钩子函数。 onUnmounted: 在组件卸载后执行的函数，类似于 Vue 2.x 中的 unmounted 钩子函数。 onActivated: 在组件被激活时执行的函数，用于配合 &lt;keep-alive&gt; 组件使用。 onDeactivated: 在组件被停用时执行的函数，用于配合 &lt;keep-alive&gt; 组件使用。 onErrorCaptured: 捕获子组件抛出的错误，类似于 Vue 2.x 中的 errorCaptured 钩子函数。 代码演示我们分两组进行演示，分别是onBeforeMount和onMounted，onBeforeUpdate和onUpdated。其中用到比较多的就是Mounted这组。 onMounted我们输入以下代码 1234567891011121314151617&lt;template&gt; &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onMounted, onBeforeMount &#125; from &#x27;vue&#x27;const title = &#x27;hello&#x27;onBeforeMount(() =&gt; &#123; console.log(&quot;onBeforeMount: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //undefined&#125;)onMounted(() =&gt; &#123; console.log(&quot;onMounted: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //hello&#125;)&lt;/script&gt; 我们可以看到我们分别让两个生命周期函数打印出此时的值，可以看到注释里的结果，在onBeforeMount，也就是实例还挂载到DOM上，此时还没有开始渲染因此式undefined，在onMounted里，hello被打印了出来，说明此时已经完成了渲染，可以操作DOM了。因此我们平时都习惯将网页进入时就需要触发的函数放在onMounted里，防止函数无法准确获取到DOM元素。 onUpdated1234567891011121314151617181920&lt;template&gt; &lt;h2&gt;&#123;&#123; count &#125;&#125;&lt;/h2&gt;&lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onBeforeUpdate, onUpdated, ref &#125; from &#x27;vue&#x27;let count = ref(1)onBeforeUpdate(() =&gt; &#123; console.log(&quot;onBeforeUpdate&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML) //1&#125;)onUpdated(() =&gt; &#123; console.log(&quot;onUpdated&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML); //2&#125;)const add = () =&gt; &#123; count.value++ &#125;&lt;/script&gt; 可以看到这里就是差异在内部数据更改和视图更新的区别，在onBeforeUpdate时数据并没有发生更新，而在onUpdated数据发生了更新并且可以显示出来。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"}]},{"title":"git使用时出现的问题小汇总","slug":"git使用时出现的问题小汇总","date":"2024-07-29T11:21:51.000Z","updated":"2024-08-01T12:48:51.561Z","comments":true,"path":"2024/07/29/git使用时出现的问题小汇总/","link":"","permalink":"https://bayeeaa.github.io/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/","excerpt":"","text":"git提交1234git add * //将所有上传文件进入缓存区域git commit -m &quot;submit&quot; //提交申请注释，双引号里面就是注释内容(*) git remote add origin https //关联远程仓库，关联后以后就可以不再重复关联git push -u origin main //推入仓库main分支 -m在 git commit 命令中，-m 选项用于指定提交消息。Git 提交时需要一个消息来描述这次提交的目的或更改内容。使用 -m 选项可以让你在命令行中直接输入提交消息，而不是打开编辑器。使用 -m 选项可以快速地提供提交消息。 如果你不使用 -m 选项，Git 会打开你配置的默认文本编辑器（例如 Vim、Nano 等），让你在编辑器中输入提交消息。这适用于较长或复杂的提交消息，允许你在编辑器中进行详细描述和格式化。 -u在git push -u origin main中我们可以看到有个-u，-u 是–set-upstream的缩写。它的作用是将本地分支与远程分支建立跟踪关系。它有一下这几点作用： 将本地分支与远程分支关联起来，使得以后可以简化 git push 和 git pull 命令的使用。 设置当前分支的上游分支（即跟踪的远程分支），方便在以后的操作中，Git 可以自动推送和拉取数据。 error: failed to push some refs to ‘http’ 这个报错是指本地的文件和仓库中有冲突的部分，所以要先拉取github上的，然后再推上去。 12git pull origingit push origin main (或者master) error: src refspec main does not match any由于是新创建的仓库还没有main分支(或者是你还没切换到这个分支上面) 1git checkout -b main 切换到当前分支main。 如何将msater的内容合并到main分支，并删除master？要将 master 分支的内容合并到 main 分支，并删除 master 分支，你可以按照以下步骤进行操作。这些步骤假设你已经在本地仓库中，并且你希望在本地和远程仓库中同步这些更改。 切换到 main 分支： 确保你在 main 分支上，使用以下命令切换到 main 分支： 1git checkout main 更新 main 分支： 确保 main 分支是最新的。如果你正在使用远程仓库，先拉取远程更新： 1git pull origin main **合并 master 分支到 main**： 使用以下命令将 master 分支的内容合并到 main 分支： 1git merge master 如果有合并冲突，Git 会提示你解决冲突。解决所有冲突后，完成合并并提交更改： 12git add &lt;conflicted-files&gt;git commit 推送合并后的 main 分支到远程仓库： 将合并后的 main 分支推送到远程仓库： 1git push origin main 删除 master 分支： 在本地删除 master 分支： 确保你已经切换到 main 分支后，可以删除本地的 master 分支： 1git branch -d master 如果 master 分支没有完全合并到 main，而你确定要删除，可以使用 -D 强制删除： 1git branch -D master 在远程删除 master 分支： 使用以下命令将 master 分支从远程仓库删除： 1git push origin --delete master fatal: refusing to merge unrelated histories表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下： 两个分支或仓库的历史完全不同： 比如，你尝试合并两个完全不同的项目，或者一个是新创建的仓库，另一个是老的仓库。 从远程仓库克隆时历史不同： 如果你从一个远程仓库克隆了一个新的仓库，而本地仓库中已经有一些历史记录，Git 会认为这些历史不相关。 可以使用 --allow-unrelated-histories 选项来允许合并不相关的历史。以下是详细的步骤： 切换到 main 分支： 确保你在目标分支（通常是 main 分支）上： 1git checkout main 执行合并命令并允许不相关的历史： 使用 --allow-unrelated-histories 选项来合并 master 分支到 main 分支： 1git merge master --allow-unrelated-histories 这会允许 Git 合并两个没有共同历史的分支。 解决合并冲突： 如果在合并过程中遇到冲突，Git 会提示你解决这些冲突。解决冲突后，完成合并： 12git add &lt;conflicted-files&gt;git commit 推送合并后的 main 分支到远程仓库： 将合并后的 main 分支推送到远程仓库： 1git push origin main","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"},{"name":"Git","slug":"Git","permalink":"https://bayeeaa.github.io/tags/Git/"}]},{"title":"vue3+ts项目的基本路由配置","slug":"vue3-ts项目的基本路由配置","date":"2024-07-20T08:06:02.000Z","updated":"2024-08-03T18:03:49.260Z","comments":true,"path":"2024/07/20/vue3-ts项目的基本路由配置/","link":"","permalink":"https://bayeeaa.github.io/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/","excerpt":"","text":"导入router首先在main.ts文件中导入router，并将其use入app中让其挂载。 12import router from &#x27;./router&#x27;;app.use(router) 这样就可以在app中导入router了。 路由文件index.ts配置为了更标准，我们在src文件中创立一个router文件夹，然后在文件夹中创建index.ts文件。 在index文件中，我们就可以将组件的路径记录到其中，这样就可以按照需要访问组件了。 12345678910111213141516import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &#x27;@/components/Home.vue&#x27;const router = createRouter(&#123; history:createWebHistory(), routes:[ &#123; name:&#x27;shouye&#x27; path:&#x27;/Home&#x27; , component: Home, &#125; ]&#125;)//将router暴露出去(default 默认)export default router 我们先导入createRouter和createWebHistory(或createWebHashHistory)，然后再const一个router对象，里面存入history和routes。像这里我导入的是Home.vue组件，然后就可以在routes中写入path和component(path可以和组件的名字不一样，而且浏览器地址栏是不区分大小写的)。在router中history是必不可少的，其中有两种模式可以选择，我们这里选择createWebHistory。 最后不要忘记将router方法暴露出去。 这样我们就已经可以访问”&#x2F;home”组件了，但是我们的组件应该要配合layout来显示，具体放在页面的那个地方才合适呢？ 控制组件存放位置使用中存放组件的位置用RouterView标签，触发标签用RouterLink标签。 首先我们还是一样要在script中导入RouterView，RouterLink： 1import &#123; RouterView, RouterLink &#125; from &#x27;vue-router&#x27; 然后就可以在template中使用了： 123&lt;div :style=&quot;&#123; padding: &#x27;24px&#x27;, background: &#x27;#fff&#x27;, minHeight: &#x27;600px&#x27; &#125;&quot;&gt; &lt;RouterView&gt;&lt;/RouterView&gt; &lt;/div&gt; 其中组件都会在RouterView的位置显示。而我们触发事件就要： 1&lt;RouterLink to=&quot;/home&quot;&gt; 首页 &lt;/RouterLink&gt; 这里需要配合button等来配合使用。 当然考虑到地址的变化，也可以这样写RouterLink： 1&lt;RouterLink :to=&quot;&#123;path:/home&#125;&quot;&gt; 首页 &lt;/RouterLink&gt; 或者： 1&lt;RouterLink :to=&quot;&#123;name:shouye&#125;&quot;&gt; 首页 &lt;/RouterLink&gt; 子路由配置我们上面配置都是一级路由，而二级子路由要怎么配置呢？ 首先我们找到index.ts文件，再里面添加children在path中： 12345678910111213141516const router = createRouter(&#123; history:createWebHistory(), routes:[ &#123; name:&#x27;shouye&#x27;, path:&#x27;/Home&#x27; , component:Home, children:[ &#123; path:&#x27;detail&#x27;, //不要加斜杠 component:Detail, &#125; ] &#125; ]&#125;) 然后我们只需在RouterLink里面修改to的路径就可以了，也就是我们可以localhost&#x2F;home&#x2F;detail来访问子组件了。 路由传参方法query使用query传参我们需要在RouterLink的to中加入需要传入的值，比如我们想传给子组件“qq”一词： 1&lt;RouterLink to=&quot;/detail?a=qq&amp;b=kk&quot;&gt;&lt;/RouterLink&gt; 可以看到我给子组件通过“路径?变量&#x3D;值”将值传递，然后在子组件中我们需要再导入router接收传递的信息，就可以使用了： 12import &#123; useRoute &#125; from &#x27;vue-router&#x27;;let route = useRoute() html: 1&#123;&#123; route.query.a &#125;&#125; 这样就可以在页面中呈现了。 顺便我们log route一下就可以看到页面传递的值： 而如果我们需要通过for来改变传递的值，可以按照示例中这样写： 12345&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt; &lt;RouterLink :to=&quot;`/detail?a=$&#123;shops.id&#125;`&quot;&gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt; &lt;/RouterLink&gt; &lt;/a-col&gt; 或者： 123456789101112&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt; &lt;RouterLink :to=&quot;&#123; path:&#x27;/detail&#x27; query:&#123; a:shops.id, &#125; &#125;&quot; &gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt; &lt;/RouterLink&gt; &lt;/a-col&gt; params与query传参不同的是，params传参在index.ts中的path需要提前占位，在to中就可以对path中占的位对号入座。 比如我在path中用x占位： 12path:&#x27;/detail/:x?&#x27;, //这里的冒号表示占位，问号表示这个地方可能有展位也可能没有（问号不加也可以）component:Detail, 然后在template中： 123&lt;RouterLink to=&quot;/detail/aa&quot;&gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;&lt;/RouterLink&gt; 再在子组件中console.log(route)一下就可以发现： 最后用params接收： 1&#123;&#123; route.params.a &#125;&#125; 然后同样可以用变量传递的方式传参： 123456789101112&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt; &lt;RouterLink :to=&quot;&#123; name:&#x27;xiangqing&#x27; query:&#123; a:shops.id, &#125; &#125;&quot; &gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt; &lt;/RouterLink&gt; &lt;/a-col&gt; 但注意这里不能用path，只能用name来判断路径。 props配置第一种写法在路由配置中加上props:true，再在组件中加入defineProps([… , … ,])就可以将路由收到的params参数作为props传给组件。 子路由： 123456&#123; name:&#x27;xiangqing&#x27;, path:&#x27;/detail/:id/:title/:content&#x27;, component:Detail, props:true&#125;, 组件： 1defineProps([&#x27;id&#x27;,&#x27;title&#x27;,&#x27;content&#x27;]) 使用： 1&#123;&#123; id &#125;&#125; 第二种写法也可以传递query参数： 12345678&#123; name:&#x27;xiangqing&#x27;, path:&#x27;/detail/:id/:title/:content&#x27;, component:Detail, props(route)&#123; return route.query &#125;&#125;, 总结query不用占位，params需要占位。 本节使用RouterLink标签进行跳转，其中to属性解释来添加跳转的位置，可以用对象的方法书写。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"},{"name":"TS","slug":"TS","permalink":"https://bayeeaa.github.io/tags/TS/"}]},{"title":"vite构建的项目“@”地址无法解析问题","slug":"vite构建的项目“-”地址无法解析问题","date":"2024-07-19T14:36:33.000Z","updated":"2024-07-19T14:43:38.611Z","comments":true,"path":"2024/07/19/vite构建的项目“-”地址无法解析问题/","link":"","permalink":"https://bayeeaa.github.io/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"使用vite构建项目后，发现无法识别”@”地址： 经过排查是由于config文件中没有配置”@”对应的路径： 12345678import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), ],&#125;) 打开vite.config.ts文件，改成： 123456789101112131415import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) //这里的配置就是可以让@可以读取成&#x27;./src&#x27; &#125; &#125;&#125;) 中间的reslove的alias所包含的就是”@”的配置项，这样我们就可以用@来代替.&#x2F;src。","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"}]},{"title":"IP地址","slug":"IP地址","date":"2024-07-10T09:15:10.000Z","updated":"2024-07-17T05:23:40.744Z","comments":true,"path":"2024/07/10/IP地址/","link":"","permalink":"https://bayeeaa.github.io/2024/07/10/IP%E5%9C%B0%E5%9D%80/","excerpt":"","text":"IP地址内网ip和公网ip内网IP（Internal Network IP）是指在局域网或者内部网络中使用的IP地址。在IPv4的网络中，内网IP地址通常属于私有IP地址范围，例如： 10.0.0.0 到 10.255.255.255 172.16.0.0 到 172.31.255.255 192.168.0.0 到 192.168.255.255 这些地址是专门为局域网内部使用而保留的，不会被分配到互联网上，因此可以重复使用。内网IP地址的作用是在局域网内部进行设备之间的通信和连接，比如连接本地打印机、路由器、局域网内的计算机等。 与内网IP相对的是公网IP（Public IP），公网IP是可以被全球互联网访问到的IP地址，用于在不同的网络之间进行通信。 我们可以通过 1$ ipconfig 来访问我们电脑现在的内网ip(也就是ipv4地址) 公网IP（Public IP）是指可以直接在全球互联网上访问到的IP地址。它是由互联网服务提供商（ISP，也就是移动，联通这些公司）分配给网络设备（如路由器、服务器等）的唯一标识符，用于在互联网上进行通信和数据交换。 公网IP地址是全球唯一的，不同的设备在互联网上需要具有不同的公网IP地址，这样才能保证它们之间能够正确地进行通信和数据传输。公网IP地址通常是静态或动态分配的，静态公网IP地址在一段时间内不会改变，而动态公网IP地址可能会在连接重新建立时发生变化。 通常情况下，个人用户使用的是动态公网IP地址，而企业或特定应用可能会使用静态公网IP地址，以便更稳定地提供服务和进行网络管理，一般情况下我们个人都是先使用内网然后再通过了路由将数据与公网进行交换，如果想要个人直接接入公网，需要向ISP特别申请。 通俗的说，内网ip与公网ip就好比寄快递，内网ip是几栋几号室，而公网ip是哪个省哪个市，有了这些ip地址后，我们才能把信息精确分配到每一个计算机个体。 ipv4和ipv6IPv4（Internet Protocol version 4）是互联网协议第四版，是当前广泛使用的互联网协议之一。IPv4定义了互联网上数据的传输方式，它使用32位（4个字节）的地址长度来标识网络上的每个设备或节点。 IPv4地址通常以点分十进制表示，例如：192.168.1.1。每个IPv4地址由四个八位组成，每个八位组可以表示0到255之间的数值，总共有约42亿个不同的IPv4地址。然而，由于互联网的迅速发展和设备的增多，IPv4地址已经逐渐不足以支持所有连接到互联网的设备。 为了解决IPv4地址耗尽的问题，IPv6（Internet Protocol version 6）被设计出来，它使用128位（16个字节）的地址长度，大大增加了可用的地址空间，预计能够长期解决IP地址耗尽的问题。IPv6的推广和采用逐渐增加，但目前仍然有大部分互联网流量使用IPv4协议。 总结起来，IPv4是互联网上广泛使用的网络协议之一，使用32位地址长度来标识网络上的设备或节点，其地址格式为点分十进制。 NAT由上面我们知道随着互联网的发展，ipv4逐渐枯竭。为了应对这样的情况，NAT（网络地址转换）技术孕育而生。 NAT 的主要类型包括： 静态 NAT：静态NAT是将一个固定的私有IP地址映射到一个固定的公共IP地址的一种形式，通常用于需要特定设备具有公共IP地址的情况，如服务器。 动态 NAT：动态NAT是动态地将内部设备的私有IP地址映射到公共IP地址池中的一个可用地址，通常在需要大量设备同时访问互联网时使用。 PAT（端口地址转换）：也称为Overload NAT，它允许多个设备使用相同的公共IP地址访问互联网，但通过不同的端口号进行区分。 一般情况我们我们就是通过路由器来将私有的ip地址映射到固定的公共ip地址，所以路由器在这里就充当了网关的作用。但是通过路由器传输的终端就不止一个，另一端接收方路由器对应的终端也不止一个，我们传输就无法一一对应，所以我们就要用到端口映射，通过端口号来确定我们要传输数据的终端彼此。 子网掩码在知道子网掩码之前，我们要知道什么是子网。 子网（Subnet）是指将一个大的IP地址块（IP地址空间）划分成若干个较小的子集，每个子集称为一个子网。在网络中，子网的作用是将一个大的网络划分成多个较小的、更易管理的部分，以便于组织和管理网络设备。 每个子网由一组连续的IP地址组成，这些IP地址共享一个公共的网络前缀（网络标识符）。这个网络前缀通常由IP地址和子网掩码（Subnet Mask）共同决定，子网掩码定义了IP地址中哪些部分是网络部分，哪些部分是主机部分。 子网的使用可以帮助网络管理员更有效地管理IP地址，减少广播风暴（Broadcast Storm）和冲突，提高网络的安全性和性能。常见的子网划分方式包括按照部门、功能或地理位置来划分子网，以便于根据需要对每个子网进行管理和配置。 那么如何确定这个ip是否在这个子网中呢？这就需要有子网掩码。子网掩码通过”&amp;”操作辨别子网： 121 &amp; X = X0 &amp; X = X 比如我们可以将： 12192.168.1.10 &amp; 255.255.255.0 = 192.168.1.0IP &amp; 子网掩码 =&gt; 结果相同 =&gt; 同一子网 如果我们通过ip和子网掩码的与操作都得到相同的结果，说明他们都在同一个子网当中。 端口端口（Port）是一种逻辑概念，用于区分不同应用程序或服务在同一台计算机上的通信终点。每个端口都有一个数字标识，称为端口号，用于标识特定的网络服务或应用程序。 主要特点和用途： 端口号：端口号是一个16位的整数，范围从0到65535。其中，0到1023的端口号被称为“系统端口”或“well-known端口”，它们通常分配给常见的网络服务，如HTTP（端口号80）、HTTPS（端口号443）、FTP（端口号21）等。 通信终点：在一台计算机上，每个运行的应用程序或服务都可以通过一个或多个端口号来进行通信。例如，Web服务器使用HTTP协议通过端口号80接收Web请求，而电子邮件服务器使用SMTP协议通过端口号25接收邮件。 传输层概念：端口属于传输层（第四层）协议的概念，在TCP&#x2F;IP模型中，这一层负责提供可靠的数据传输服务。TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们通过端口号来确定数据包应该被交付给哪个应用程序或服务。 端口分类： 系统端口：0到1023，预留给众所周知的服务。 注册端口：1024到49151，分配给用户进程或应用程序。 动态&#x2F;私有端口：49152到65535，用于临时的短暂会话。 端口的重要性： 多路复用：端口允许一台计算机上的多个应用程序同时进行网络通信，通过端口号区分不同的应用数据流。 网络安全：端口号有助于防火墙和安全设备识别和控制不同类型的网络流量，提高网络安全性。 网络管理：端口号使网络管理员可以轻松地监控和管理网络上的各种服务和应用程序。 以太网和因特网以太网（Ethernet）和因特网（Internet）是两个不同的概念，它们在计算机网络中有着不同的角色和范围。 以太网（Ethernet）： 定义：以太网是一种局域网（LAN）技术，用于在较小的范围内连接多台计算机和网络设备，如在办公室、校园或家庭内部。 传输介质：以太网通常使用双绞线、光纤或者无线电波作为传输介质，传输速度可以从几百Mbps到几十Gbps不等。 协议：以太网使用一组标准的数据链路层和物理层协议（如IEEE 802.3标准），定义了数据包在局域网内的传输方式。 拓扑结构：以太网的拓扑结构可以是星型、总线型或者环型，其中最常见的是星型拓扑，每台设备连接到一个中央集线器或交换机。 因特网（Internet）： 定义：因特网是全球范围内的公共计算机网络，由许多不同的网络（包括以太网、光纤网络、卫星网络等）连接起来，通过TCP&#x2F;IP协议族进行数据传输和通信。 范围：因特网是全球性的网络，连接了世界上几乎所有的计算机和网络设备，允许它们之间进行跨地域和跨国界的通信。 协议：因特网使用TCP&#x2F;IP协议族，包括TCP（Transmission Control Protocol）和IP（Internet Protocol），定义了数据在全球范围内的传输和路由方式。 服务和应用：因特网支持各种应用和服务，如电子邮件、网页浏览、文件传输、实时通信等，是人们日常生活中广泛使用的平台。 简单的说以太网就是局域网，而因特网就是互联网。 TCP&#x2F;IP协议TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）是一组通信协议，它定义了互联网和许多私有网络中数据如何传输和交换的标准。TCP&#x2F;IP协议族是现代互联网通信的基础，它包括多个协议，每个协议负责不同的功能。 IP（Internet Protocol）： IP协议负责在网络中传送数据包，并确保它们能够从源地址到目标地址安全地传输。 它定义了数据包的结构和格式，以及如何在网络中路由和转发数据包。 TCP（Transmission Control Protocol）： TCP协议是一种面向连接的协议，负责在通信的两端建立可靠的数据传输连接。 它确保数据包按顺序到达目的地，并处理丢失数据包的重传，以及流量控制和拥塞控制。 UDP（User Datagram Protocol）： UDP协议是一种无连接的协议，它提供了一种简单的数据传输服务，适用于实时应用程序和广播通信。 与TCP不同，UDP不保证数据的顺序和可靠性，但是它提供了较低的延迟和更高的传输速度。 其他协议： ICMP（Internet Control Message Protocol）：用于在IP网络上发送控制消息，如错误报告和网络诊断。 ARP（Address Resolution Protocol）：用于将IP地址映射为MAC地址（硬件地址）。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"前端如何将pdf等文件传入后端","slug":"前端如何将pdf等文件传入后端","date":"2024-07-04T13:12:22.000Z","updated":"2024-08-03T18:03:36.079Z","comments":true,"path":"2024/07/04/前端如何将pdf等文件传入后端/","link":"","permalink":"https://bayeeaa.github.io/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/","excerpt":"","text":"前端如何将pdf等文件传入后端我们知道在js中我们可以通过： 1&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot; accept=&quot;image/*&quot;&gt; 来输入文件。其中type指后端url，accept来限制传入类型。 前端通过表单形式将其传入后端那么前端是怎么将这一整个文件打包传入后端的呢？ 原来前端通过文件上传表单的方式将文件传输到后端。这通常涉及使用 HTML 的 &lt;form&gt; 元素和 &lt;input type=&quot;file&quot;&gt; 输入框，以及设置适当的表单属性来支持文件上传。 可以看到我在使用ant design vue框架时其文件传输的内容包含状态，上传时间，文件名字等。 文件上传的流程： 用户在文件输入框中选择一个文件。 用户点击提交按钮，浏览器将会把表单数据（包括选定的文件）打包成 multipart/form-data 格式的请求体。 请求被发送到指定的后端URL（在这个例子中是 /upload）。 后端接收到请求后，可以通过相应的框架或库来解析 multipart/form-data，获取到文件数据，并进行进一步处理，例如保存文件到服务器或者进行文件内容分析等操作。 文件上传表单示例：1234&lt;form id=&quot;uploadForm&quot; action=&quot;/upload&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt; &lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt;&lt;/form&gt; 解释： &lt;form&gt; 元素定义了一个表单，其中： action=&quot;/upload&quot; 指定了表单提交的目标后端URL。 method=&quot;POST&quot; 指定了使用POST方法提交表单。 enctype=&quot;multipart/form-data&quot; 表示表单中包含文件上传，这是必需的，因为文件上传需要使用 multipart/form-data 类型来传输文件数据。 &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt; 是文件上传的输入框，其中： type=&quot;file&quot; 表示这是一个文件输入框，允许用户选择文件。 name=&quot;file&quot; 指定了后端接收文件时的字段名称，这个名称在后端处理文件时很重要。 id=&quot;fileInput&quot; 可以用来通过 JavaScript 获取文件输入框的引用，以便在用户选择文件后执行一些操作（例如显示文件名或大小）。 &lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt; 是一个提交按钮，点击它会触发表单提交操作。 后端处理文件上传的例子： Node.js（使用 Express 框架）： 123456789101112131415javascript复制代码const express = require(&#x27;express&#x27;);const multer = require(&#x27;multer&#x27;);const upload = multer(&#123; dest: &#x27;uploads/&#x27; &#125;);const app = express();app.post(&#x27;/upload&#x27;, upload.single(&#x27;file&#x27;), (req, res) =&gt; &#123; const file = req.file; // 处理文件，例如保存到服务器或者返回其他响应 res.send(&#x27;文件上传成功&#x27;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器运行在 http://localhost:3000&#x27;);&#125;); 在这个例子中，使用了 multer 中间件来处理单个文件上传，upload.single(&#39;file&#39;) 表示期望接收一个名为 file 的文件字段。 PHP： 1234567891011php复制代码&lt;?php$target_dir = &quot;uploads/&quot;;$target_file = $target_dir . basename($_FILES[&quot;file&quot;][&quot;name&quot;]);$uploadOk = 1;if (move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $target_file)) &#123; echo &quot;文件上传成功&quot;;&#125; else &#123; echo &quot;文件上传失败&quot;;&#125;?&gt; PHP 示例使用了 $_FILES 超全局数组来接收上传的文件，并使用 move_uploaded_file() 函数将文件从临时位置移动到指定的目标位置。 用JS将文件传入后端上面以及展示了html文件上传表单的示例，下面再展示通过JavaScript监听文件选择事件来传递。 html1234&lt;div&gt; &lt;input type=&quot;file&quot; id=&quot;File&quot;&gt; &lt;button&gt;点击上传文件&lt;/button&gt;&lt;/div&gt; JS绑定事件12345document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, e =&gt; &#123; let fileList = document.querySelector(&#x27;#File&#x27;).files&#125;)let fd = new FormData()fd.append(&#x27;aaa&#x27;,fileList[0]) 如果接口文档要求传递请求体(包括Content-Disposition, Content-Type等)我们使用window提供的FormData构造函数来实例化一个表单类型。 axios传递1234567axios(&#123; url: &#x27;&#x27;, method: &#x27;POST&#x27;, data: fd&#125;).then(res =&gt; &#123; console.log(res);&#125;) 通过ajax就可以将文件传入后端。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"}]},{"title":"面向JS的TypeScript","slug":"面向JS的TypeScript","date":"2024-07-02T05:52:53.000Z","updated":"2024-07-02T05:55:10.580Z","comments":true,"path":"2024/07/02/面向JS的TypeScript/","link":"","permalink":"https://bayeeaa.github.io/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/","excerpt":"","text":"面向JS的TypeScript说到TypeScript，就不得不从Javascript说起。我们知道JavaScript（也称为 ECMAScript）最初是一种用于浏览器的简单脚本语言。在它被发明时，它被期望用于嵌入网页中的简短代码片段 - 编写几十行以上的代码有点不寻常。因此，早期的网络浏览器执行此类代码的速度非常慢。不过，随着时间的推移，JS 变得越来越流行，Web 开发者开始使用它来创建交互式体验。 JavaScript是一种为快速使用而设计的语言，与众不同的是，每种语言都有自己的“怪癖“，而 JavaScript 的卑微起步使其拥有许多这样的”怪癖“。 JavaScript 的相等运算符 (==) 强制转换其操作对象，导致意外行为： 123456if (&quot;&quot; == 0) &#123; // It is! But why??&#125;if (1 &lt; x &lt; 3) &#123; // True for any value of x!&#125; JavaScript 还允许访问不存在的属性： 123const obj = &#123; width: 10, height: 15 &#125;;// Why is this NaN? Spelling is hard!const area = obj.width * obj.heigth; TypeScript：静态类型检查器静态检查：在不运行代码的情况下检测代码中的错误。 TypeScript 能在执行前检查程序是否有错误，并根据值的种类进行检查，使其成为静态类型检查器。 比如： 1234const obj = &#123; width: 10, height: 15 &#125;;const area = obj.width * obj.heigth;* Property &#x27;heigth&#x27; does not exist on type &#x27;&#123; width: number; height: number; &#125;&#x27;. Did you mean &#x27;height&#x27;?Property &#x27;heigth&#x27; does not exist on type &#x27;&#123; width: number; height: number; &#125;&#x27;. Did you mean &#x27;height&#x27;? TypeScript是JavaScript的超集因此JS的许多语法在TS中是合法的。由于其语法，TypeScript 不会将任何 JavaScript 代码视为错误。这意味着你可以将任何有效的 JavaScript 代码放入 TypeScript 文件中，而不必担心它的具体编写方式。 语法12let a = (4 *&#x27;)&#x27;expected. 在TS中不会将任何JS代码看成错误。因此你可以将任何有效的JS都放入TS文件中，而不必担心其具体用法。 类型化的JS超集TS是一个类型超集，这意味着它添加了关于如何使用不同类型的值的规则。比如在一些JS中的错误不是语法错误而是“以不正确的方式使用某种值（类型）的错误”。 1console.log(4 / []); 这个语法上合法的程序记录了 Infinity。但是，TypeScript 将数字除以数组视为无意义的操作，并且会触发错误：“The right-hand side of an arithmetic operation must be of type ‘any’, ‘number’, ‘bigint’ or an enum type.”(分母必须是‘any’,’number’,’bigint’,’enum type’)。 运行时的行为TypeScript 也是一种保留了 JavaScript 运行时行为的编程语言。例如，在 JavaScript 中除以零会产生 Infinity 而不是抛出运行时异常。原则上，TypeScript 不会改变 JavaScript 代码的运行时行为。 擦除类型一旦TS的编译器检查完代码，它就会擦除类型以生成结果的“编译”代码。这意味着一旦代码被TS编译后。生成的普通JS就没有类型信息了。","categories":[],"tags":[{"name":"TS","slug":"TS","permalink":"https://bayeeaa.github.io/tags/TS/"}]},{"title":"二叉树的建立、遍历规则、以及节点计算","slug":"二叉树的建立、遍历规则、以及节点计算","date":"2024-06-21T17:24:02.000Z","updated":"2024-07-02T05:54:18.850Z","comments":true,"path":"2024/06/22/二叉树的建立、遍历规则、以及节点计算/","link":"","permalink":"https://bayeeaa.github.io/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/","excerpt":"","text":"二叉树的建立、遍历规则、以及节点计算二叉树故名思意就是只有两个度的树，这里讨论其最基本的用法及逻辑。 树的创立定义一颗二叉树首先要有一个度里的数据data，以及左右孩子，我们可以用结构体定义以方便其理解。 结构体定义：12345678typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;; 我们给左右孩子分别定位Left和Right，这样我们就可以使用T-&gt;Left和T-&gt;Right等方式进行调用，利于理解。 树的构建：1234567891011121314151617binTree creatBintree()&#123; int a; binTree b; scanf(&quot;%d&quot;, &amp;a); if (0 == a) //如果输入0，则停止创建 b = NULL; else &#123; b = (binTree)malloc(sizeof(struct binNode)); b-&gt;element = a; b-&gt;leftChild = creatBintree(); b-&gt;rightChild = creatBintree(); &#125; return b;&#125; 树的遍历当我们构建起了一个树后我们怎么对树进行遍历读取呢？可以用前、中、后序遍历，打比方我们用前序遍历就是通过（根、左、右）对树进行读取，也就是首先将最上面的节点作为root，然后将所有左边和右边的节点看作孩子，然后再将此时左孩子最上面的节点作为root进一步（根、左、右）读取，以此类推进行遍历。我们可以用递归的方式来实现代码。 前序遍历123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT==NULL) return; if(BT-&gt;Left==NULL &amp;&amp; BT-&gt;Right==NULL)&#123; printf(&quot; %c&quot;,BT-&gt;Data); //输出结果 &#125; PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right);&#125; 中序遍历123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT==NULL) return; PreorderPrintLeaves(BT-&gt;Left); if(BT-&gt;Left==NULL &amp;&amp; BT-&gt;Right==NULL)&#123; printf(&quot; %c&quot;,BT-&gt;Data); &#125; PreorderPrintLeaves(BT-&gt;Right);&#125; 后序遍历123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT==NULL) return; PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right); if(BT-&gt;Left==NULL &amp;&amp; BT-&gt;Right==NULL)&#123; printf(&quot; %c&quot;,BT-&gt;Data); &#125; &#125; 节点的计算节点的计算需要通过左右子树的孩子判断来对其进行加法运算，我们可以用T-&gt;lchild!&#x3D;NULL来表示没有左孩子，同理可以右孩子也是T-&gt;rchild!&#x3D;NULL，这样就可以区分度为1、2或叶子节点。 计算节点数12345int NodeCount ( BiTree T)&#123; if(T==NULL) return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1; //全部一次性+1&#125; 计算度为1的节点数123456int NodeCount ( BiTree T)&#123; if(T==NULL) return 0; if(( T-&gt;lchild!=NULL &amp;&amp; T-&gt;rchild==NULL) || ( T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild!=NULL)) return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1; //这里次数+1 return NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); //直接return，次数不变&#125; 计算度为2的节点数123456int NodeCount ( BiTree T)&#123; if(T==NULL) return 0; if( T-&gt;lchild!=NULL &amp;&amp; T-&gt;rchild!=NULL) return 1+NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); return NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);&#125; 计算叶子节点个数12345int LeafCount ( BiTree T)&#123; if(T == NULL) return 0; if(T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild==NULL) return 1; return LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);&#125; 树高计算我们可以定义两个整型m，n分别来表示左右两边的树高度，用递归的方式实现向下计算。 12345678910111213int GetHeight( BinTree BT )&#123; int m, n; if (BT == NULL) return 0; else&#123; m = GetHeight(BT-&gt;Left); n = GetHeight(BT-&gt;Right); if (m &gt; n) return (m + 1); else return (n + 1); &#125; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"图算法-用Dijkstra和Prim求最小路径","slug":"图算法-用Dijkstra和Prim求最小路径","date":"2024-06-15T14:44:05.000Z","updated":"2024-06-15T14:44:30.930Z","comments":true,"path":"2024/06/15/图算法-用Dijkstra和Prim求最小路径/","link":"","permalink":"https://bayeeaa.github.io/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/","excerpt":"","text":"图算法-用Dijkstra和Prim求最小路径解决问题：在一个树中有多个节点和多条有向或无向的边，若我们给各个边附上权值，那么利用这两个算法可以计算从一个节点到所有节点的最小距离。实际中可以解决比如快递在区域配送最短的路径等问题。 Dijkstra思路例如以第1个节点为树根并循环整个树的节点，找到与1连接的所有点然后比较到这个点的距离是否小于原点(节点1)到这个点的距离(此时还没有)，若此时的距离比另一条路到这个点的距离小，则存入数据，以此类推。 具体如下：我们用dist数组来存入原点到所有点的最小距离，最开始的时候设置所有的点到原点的距离为无穷大。 12memset(dist, 0x3f, sizeof(dist));dist[1] = 0;//原点到原点的距离为0 用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。 首先用for遍历每个点，寻找到每一个点的到原点的距离。 再在用一个for来确定这个点是到原点的最短距离。 1234567891011for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t if(!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; state[t] = 1;//state[i]置为1。 for(int j = h[t]; j != -1; j = ne[j])&#123;//遍历t所有可以到达的节点i int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新dist[j] &#125;&#125; 整个函数： 123456789101112131415void Dijkstra()&#123; memset(dist, 0x3f, sizeof(dist));//dist数组的各个元素为无穷大 dist[1] = 0;//源点到源点的距离为置为 0 for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t if(!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; state[t] = 1;//state[i]置为1。 for(int j = h[t]; j != -1; j = ne[j])&#123;//遍历t所有可以到达的节点i int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新dist[j] &#125; &#125;&#125; Prim思路prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。prim算法相比于dijkstra是贪心的，它要寻找的是每一个点之间的最短距离。 具体如下与Dijkstra一样用dist存入距离，并最开始用无穷大赋值。 用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。 用pre数组来保存节点是和谁连通的。 伪代码： 12345678int dist[n],state[n],pre[n];dist[1] = 0;for(i : 1 ~ n)&#123; t &lt;- 没有连通起来，但是距离连通部分最近的点; state[t] = 1; 更新 dist 和 pre;&#125; 我们在prim里面相当于是将树的每个点一个一个加入到一个集合中，这个集合就是生成的树。每次选择树都要看看是否在树中并且到树的距离最短，如果是则加入到集合中。 12345678910111213141516171819202122232425void prim()&#123; memset(dt,0x3f, sizeof(dt));//初始化距离数组为一个很大的数（10亿左右） int res= 0; dt[1] = 0;//从 1 号节点开始生成 for(int i = 0; i &lt; n; i++)&#123;//每次循环选出一个点加入到生成树 int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//每个节点一次判断 if(!st[j] &amp;&amp; (t == -1 || dt[j] &lt; dt[t]))//如果没有在树中，且到树的距离最短，则选择该点 t = j; &#125; if(dt[t] == 0x3f3f3f3f) &#123; cout &lt;&lt; &quot;impossible&quot;; return; &#125; st[t] = 1;// 选择该点 res += dt[t]; for(int i = 1; i &lt;= n; i++)&#123;//更新生成树外的点到生成树的距离 if(dt[i] &gt; g[t][i] &amp;&amp; !st[i])&#123;//从 t 到节点 i 的距离小于原来距离，则更新。 dt[i] = g[t][i];//更新距离 pre[i] = t;//从 t 到 i 的距离更短，i 的前驱变为 t. &#125; &#125; &#125; cout &lt;&lt; res;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"本地已经后端部署，前端response返回“Method Post not allowed”问题","slug":"本地已经后端部署，前端response返回“Method-Post-not-allowed”问题","date":"2024-05-04T15:38:25.000Z","updated":"2024-05-04T15:49:16.020Z","comments":true,"path":"2024/05/04/本地已经后端部署，前端response返回“Method-Post-not-allowed”问题/","link":"","permalink":"https://bayeeaa.github.io/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/","excerpt":"","text":"这次是在做前端的时候，前后端联调发生的问题。接口名前后都对的上然而显示“Post方法不被允许”： 第一反应是去看自定义端口最后的url是不是少一个“&#x2F;”： 发现并没有少。 最后经过排查发现前后端地址没有对上。前端地址没有连接本地的地址。 修改target的请求地址为”http://127.0.0.1:3381“，成功解决。","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"}]},{"title":"Promise链式调用与async函数解决回调地狱问题","slug":"Promise链式调用与async函数解决回调地狱问题","date":"2024-05-01T02:36:23.000Z","updated":"2024-05-02T15:54:31.017Z","comments":true,"path":"2024/05/01/Promise链式调用与async函数解决回调地狱问题/","link":"","permalink":"https://bayeeaa.github.io/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/","excerpt":"","text":"在平时我们使用vue的时候经常会看到在请求接口的时候总是会有async与await： 这是为什么呢？不能直接请求接口吗？ 这里其实是为了避免出现回调地狱的问题。要理解清楚这个问题不妨从promise的链式调用开始讲起。 什么是回调地狱？概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调地狱。 我们知道一个axios函数中包含一些url等请求参数和一个.then的回调函数，由于其异步性，一个接口的请求需要等到回调函数成功调回才算结束。于是要是我们在.then里面在嵌入一个axios函数的话就需要等到上一层请求后再进入这层，再由这层回调到上层。代码量一多，不仅可读性差而且异常无法捕获，耦合性严重，牵一发动全身。比如看下面代码： 12345678910axios(&#123;url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; const pname = res.data.list[5] console.log(pname); axios(&#123;url:&#x27;http://hmajax.itheima.net/api/city!&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; const cname = res.data.list[0] console.log(cname); &#125;) &#125;).catch(error =&gt; &#123; console.log(error);&#125;) 我在第二个url中最后加了一个“!”让其错误，并让catch寻找错误的地方。然而我们发现： 其错误直接来源于axios的源码处，而且显示Uncaught (in promise)，这就是回调地狱最直接的一个弊端处。 好了这里又涉及到一个词叫promise。 何为Promise？mdn的解释是：“Promise是一个对象，它代表了一个异步操作的最终完成或者失败。”所以说Promise就是一个函数返回的对象，不然每次做回调操作都要自己手动传一个回调函数进去。 解释：依靠then()方法回返回一个新生成的Promise对象特性，继续串联下一环任务，直到结束。而then()回调函数中的返回值会影响新生成的Promise对象最终状态和结果。这样通过链式调用，可以有效解决回调函数嵌套问题。 123456789const p = new Promise((reslove, reject) =&gt; &#123; setTimeout(() =&gt; &#123; //设置时间模拟ajax请求 reslove(&#x27;北京市&#x27;) &#125;, 2000)&#125;)const p2 = p.then(res =&gt; &#123; console.log(res); //北京&#125;)console.log(p2 === p); //false 可以看到我们创建了一个新的promise对象并赋值给p，然后再用p触发回调函数，并生成了一个全新的promise对象并赋值给p2。 在最后一行的log中，使用了三等判断进行比较，我们知道三等判断，判断的是两个变量保存的内存地址，最后其返回了false更可以说明生成的是一个全新的promise对象。 所以知道了promise的工作原理，我们就可以这样写： 12345678910axios(&#123;url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; const pname = res.data.list[5] console.log(pname); return axios(&#123;url:&#x27;http://hmajax.itheima.net/api/city!&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; const cname = res.data.list[0] console.log(cname); &#125;) &#125;).catch(error =&gt; &#123; console.log(error);&#125;) 没错，就是在第二个axios前面多了一个return，就可以捕获到第二层的错误了。 async函数和await我们现在知道了promise可以解决回调地狱，但是这还是在回调函数里面不断嵌套，可读性极差，这时async函数(意思为“异步”)的引入就极大的改善了这个问题。 定义：async函数是使用async关机字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键词。async和await关键词让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。 因此我们只需要这样： 123456789const getData = async () =&gt; &#123; const pObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;) const pname = pObj.data.list[5] const cObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;) const cname = cObj.data.list[0] console.log(pname); console.log(cname);&#125;getData() //别忘了调用函数 或者： 12345678910111213let pname = []let cname = []const getData = async () =&gt; &#123; await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; pname = res.data.list[5] &#125;) await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; cname = res.data.list[0] &#125;) console.log(pname); console.log(cname);&#125;getData() 注意上面第二个代码中pname和cname没有用const定义，是因为当我在外面用 12const pname = []const cname = [] 定义时发现报出错误：Assignment to constant variable（把常量赋值给了变量） 这是因为我们使用 const 定义了变量且存在初始值。 后面又给这个变量赋值，所以报错了。ES6 标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域：使用 const 定义的常量，不能修改它的值，且定义的常量必须赋初值；let 定义的是变量，可以进行变量赋值操作，且不需要赋初值。这个错误就是因为我们修改了常量而引起的错误，虽然某些浏览器不报错，但是无效果！所以解决方法就是前面加： 12let pname = []let cname = [] 成功解决问题。 – 这里debug的时候发现const和let这块还有点含糊，const似乎最好是赋值一个对象或数组，再对对象进行赋值。等我哪天彻底搞明白了后单独出一期讲讲_(:3 ⌒ﾞ)__","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"JavaScript-ES6箭头函数使用细则","slug":"ES6箭头函数","date":"2024-04-29T10:47:55.000Z","updated":"2024-04-29T14:10:11.114Z","comments":true,"path":"2024/04/29/ES6箭头函数/","link":"","permalink":"https://bayeeaa.github.io/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们知道在ES6之前使用函数要使用function： 123function fn(形参) &#123; 函数体&#125; 然而在function中this指向的对象不够清晰明确，以及其表达不够简洁，于是引入的箭头函数： 123(形参) =&gt; &#123; 函数体&#125; 由于其重要性，以及在vue中的大量使用，我将着重讨论下箭头函数的使用方法，函数参数和this指向问题。 使用方法以及简写条件1234567const fn = function () &#123; console.log(123) //function写法&#125;const fn = () =&gt; &#123; console.log(123) //箭头写法&#125; 当传入只有一个形参时，小括号可以省略: 1234const fn = x =&gt; &#123; console.log(x+x)&#125;fn(1) //2 当函数体只有一行时可以省略大括号: 123456789const fn = x =&gt; console.log(x+x)fn(2) //4const f = (x,y) =&gt; console.log(x+y)f(1,2) //3const form = document.querySelector(&#x27;form&#x27;)form.addEventListener(&#x27;click&#x27;, ev =&gt; ev.preventDefault()) //形参小括号和函数体大括号都省略//阻止表单默认提交时事件 箭头函数可以直接返回一个对象： 123const fn = (uname) =&gt; (&#123; uname: uname &#125;) // 属性: 值const fn = (uname) =&gt; (&#123; uname &#125;) //属性和值的名字一样的时候也可以简写fn(&#x27;ye&#x27;) //&#123;uname: &#x27;ye&#x27;&#125; 这里不用大括号包着是因为对象的大括号和其冲突了，所以用小括号代替了。 箭头函数没有arguments动态参数箭头函数里面只有剩余参数…arr,所以只能用剩余参数来传入数组进行计算。 12345678const getSum = (...arr) =&gt; &#123; let sum=0 for(let i = 0;i &lt; arr.length; i++)&#123; sum +=arr[i] &#125; return sum&#125;console.log(getSum(2,3)); //5 那么何为动态参数，何为剩余参数呢？ arguments动态参数123456789function getSum() &#123; let sum=0 console.log(arguments) //[2,3,4] for(let i = 0;i &lt; arguments.length; i++)&#123; sum +=arguments[i] &#125; console.log(sum)&#125;getSum(2,3,4) //9 arguments动态参数只存在于function函数里面，其是个伪数组，在函数里充当傀儡。 函数剩余参数剩余参数没有的固定名字，这里以arr为例。 123456789function getSum(a,b,...arr) &#123; //这里arr是名字，可以自定义 let sum=0 console.log(arr) //[4,5] for(let i = 0;i &lt; arr.length; i++)&#123; sum += arr[i] &#125; console.log(sum)&#125;getSum(2,3,4,5) //9 可以看到剩余参数顾名思义就是取剩下没有对号入座的参数。a&#x3D;2,b&#x3D;3,那么剩下的就由arr接收。注意前面的三个点是展开运算符，它可以让这几个数字组合成一个数组。 1234fn = (...arr) =&gt; &#123; console.log(arr); &#125;fn(1,2,3) //[1,2,3] 没有展开运算符： 1234fn = (arr) =&gt; &#123; console.log(arr); &#125;fn(1,2,3) //1 箭头函数this问题我们知道this是指向的是环境对象，比如我们输入： 1234567const obj = &#123; number: &#x27;1&#x27;, hello: function () &#123; console.log(this) &#125;&#125;obj.hello() //&#123;number: &#x27;1&#x27;, hello: ƒ&#125; 可以看到，我们定义了一个obj对象然后里面放了一个number和一个hello函数，当我们用obj调用hello函数时，this就指向了obj。那么我们就可以初次判断出谁调用的这个函数，this就指向谁。是不是这样呢？我们可以就单纯输入下面这行。 1console.log(this) //window 我们发现返回的是window，而我们知道window是作用域链的链头。因为我们清楚其实我们每次调用函数都应该要在前面加上window作为调用的对象，但是这样极其的重复与单调故将其省去了。这样也就说明了this确实是指向其调用的对象。 12345function fn() &#123; console.log(this)&#125;fn() //windowwindow.fn() //window 回到这个论题，我们可以发现每一个新函数都要根据它是被如何调用的来定义这个函数的this值，非常让人讨厌。因此在箭头函数中，箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。 当我们再输入： 1234567const obj = &#123; number: &#x27;1&#x27;, hello: () =&gt; &#123; console.log(this) &#125;&#125;obj.hello() //Window hello的上一级时obj，而调用obj的对象是window，所以输出window。 再比如： 1234567891011const obj = &#123; number: &#x27;1&#x27;, hello: function () &#123; let i = 10 const count = () =&gt; &#123; console.log(this) &#125; count() &#125;&#125;obj.hello() //&#123;number: &#x27;1&#x27;, hello: ƒ&#125; count函数的上一层是hello，而调用hello的是obj对象，所以输出obj。 然而在实际开发中，事件回调函数使用箭头函数时，this为全局的window。因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。 123btn.addEventListner(&#x27;click&#x27;, function () &#123; console.log(this) //this指向btn&#125;)","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"AJAX-axios库使用与http协议","slug":"axios","date":"2024-04-26T15:41:11.000Z","updated":"2024-05-02T13:51:08.409Z","comments":true,"path":"2024/04/26/axios/","link":"","permalink":"https://bayeeaa.github.io/2024/04/26/axios/","excerpt":"","text":"AJAX-axios库使用与http协议当我们需要将前后端数据进行传递时，我们可以运用AJAX技术。AJAX也就是异步的JavaScript和XML(Asynchronous JavaScript And XML)。简单的说，就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON,XML,HTML和text文本等格式发送和接收数据。 AJAX工作原理 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） axios使用axios是基于Promise的HTTP客户端作用于浏览器和node.js，属于网络请求库。 语法引入axios.js的两种方法： 使用 jsDelivr CDN: 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用 unpkg CDN: 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 函数基本使用： 12345axios(&#123; url:&#x27;目标地址&#x27;&#125;).then(result=&gt;&#123; //后端返回数据&#125;) axios-查询参数使用axios提供的params选项(param是“参数”的意思) 123456789axios(&#123; url:&#x27;&#x27;, params:&#123; 参数名:值 &#125;&#125;).then(result=&gt;&#123; //返回值 //console.log(result)&#125;) 比如： 12345678axios(&#123; url: &#x27;https://hmajax.itheima.net/api/city&#x27;, params:&#123; pname: &#x27;河北省&#x27; &#125;&#125;).then(result=&gt;&#123; console.log(result);&#125;) 查询完的数据就可以在Response里找到result值，一般情况是返回一个message和一个res，其返回的数据是个json文件。 axios-请求配置12345678910axios(&#123; url:&#x27;&#x27;, method:&#x27;请求方法&#x27;, data:&#123; 参数名:值 &#125;&#125;).then(result=&gt;&#123; //返回值 //console.log(result)&#125;) axios将data对象的数据通过上述方式传入后端，后端就会根据其传入的关键词获得对应的res并在then后面得到。 axios-错误处理在then方法的后面，通过点语法调用catch方法，传入回调函数并定义形参。 12345678axios(&#123; //请求选项&#125;).then(result =&gt; &#123; //处理数据&#125;).catch(error =&gt; &#123; //处理错误 //console.log(error)&#125;) 该方法可以捕捉到错误数据，并将数据传入error形参中，于是就可以将错误数据解析并返回客户端中显示。（其实error可以用console.log在控制台查看，但是catch可以将数据传入并可解析） 1alert(error.response.data.message) //一般情况下可以通过这样解析json文件并弹出问题 HTTP协议Request Headershttp协议规定了浏览器发送及服务器返回内容的格式，也就是如果你传入data对象，报文会将其转化为一个json文件打包传给后端，然后后端再传入对应的json文件。 如下图就是一个请求报文(也就是请求头)： Accept中可以看到返回的是个json文件，Host是域名，User-Agent是用来模仿用户登录。 Resonpse Headers当我们后端受到前端的request headers后就会相应的传入response headers，这个headers包括：响应行，响应头，空行，响应体。响应体就包含了我们需要的json文件，浏览器会将该文件通过js渲染，显示于页面中。在文件传输的时候可能会有前后传递出错的时候，这时候就需要状态码来告知错误信息。 状态码有如下几种： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"并查集","slug":"并查集","date":"2024-04-19T13:41:40.000Z","updated":"2024-05-02T15:58:02.740Z","comments":true,"path":"2024/04/19/并查集/","link":"","permalink":"https://bayeeaa.github.io/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集其实解决的内容就是类似于集合合并的问题，然而如果用普通的数组去储存一个集合若数据量大，不仅调用时占用内存空间大，而且不便于插入或查询操作，因此引入并查集可以很好的解决这点。 功能1.将两个集合合并 2.询问两个元素是否再一个集合当中 思路理解这个问题就需要把集合给看成一个树，然后这个树的树根就代表这个集合。当想询问其中一个节点时，我们只要访问这个节点father，然后再找这个father的grandfather直到到树根，就能确定这个点的树根。 123//p[x]表示x的父节点if(p[x]==x) //判断树根while(p[x]!=x) x=p[x] //求x的集合编号 合并两个集合合并集合只需要将其中一个集合的树根的编号改成另一个集合的根。 1p[x]=y//px是x的集合编号，py是y的集合编号 (俗称：给x的祖宗又认了一个爹) 路径压缩当你找到这个节点的根节点时，就把这些节点的父亲全部变成根节点的编号，也就是让这些节点全部指向根节点。当实现了这个操作后，其查询操作直接将时间复杂度变成O(1)。 1234int find(int x)&#123; //寻找根+路径压缩 if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125; 例题1.合并集合一共有 n𝑛 个数，编号是 1∼n1∼𝑛，最开始每个数各自在一个集合中。 现在要进行 m𝑚 个操作，操作共有两种： M a b，将编号为 a𝑎 和 b𝑏 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作； Q a b，询问编号为 a𝑎 和 b𝑏 的两个数是否在同一个集合中； 输入格式第一行输入整数 n𝑛 和 m𝑚。 接下来 m𝑚 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。 输出格式对于每个询问指令 Q a b，都要输出一个结果，如果 a𝑎 和 b𝑏 在同一集合内，则输出 Yes，否则输出 No。 每个结果占一行。 数据范围1≤n,m≤1051≤𝑛,𝑚≤105 输入样例：1234564 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4 输出样例：123YesNoYes 题解12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int p[100005];int find(int x)&#123; //核心函数，find(x)最终返回值就是x的根节点编号 if(x!=p[x]) p[x]=find(p[x]); return p[x];&#125;int main()&#123; int n,m,a,b; string s; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;=n;i++)&#123; p[i]=i; &#125; while(m--)&#123; cin&gt;&gt;s&gt;&gt;a&gt;&gt;b; if(s==&quot;M&quot;)&#123; p[find(a)]=find(b);//让a根节点的父亲变成b节点的根节点 &#125; else if(s==&quot;Q&quot;)&#123; if(find(a)==find(b))&#123; //判断两个数是不是属于同一个集合，其实就是两个根编号是不是一样 cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; &#125; &#125;&#125; 2.合并根题目描述w 星球的一个种植园，被分成 m×n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。 这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。 如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？ 输入格式第一行，两个整数 m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。 接下来一行，一个整数 k，表示下面还有 k 行数据(0&lt;k&lt;1e5)。 接下来 k 行，每行两个整数 a，b，表示编号为 a 的小格子和编号为 b 的小格子合根了。 格子的编号一行一行，从上到下，从左到右编号。 比如：5×4 的小格子，编号： 123451 2 3 45 6 7 89 10 11 1213 14 15 1617 18 19 20 输出格式一行一个整数，表示答案 输入样例1234567891011121314151617185 4162 31 55 94 87 89 1010 1111 1210 1412 1614 1817 1815 1919 209 1313 17 输出样例15 题解： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int p[1000005],vis[1000005];int find(int x)&#123; //寻找根 if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int main()&#123; int n,m,k,a,b,sum=0; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;k; for(int i=1;i&lt;=n*m;i++) p[i]=i; while(k--)&#123; cin&gt;&gt;a&gt;&gt;b; p[find(a)]=find(b);//合并集合 &#125; for(int i=1;i&lt;=n*m;i++)&#123; // cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; if(i==p[i])sum++; &#125; cout&lt;&lt;sum;&#125; 这题使用并查集解题，核心主要两个步骤：寻找该元素的根、合并两个集合 然后最后判断是用if(i&#x3D;&#x3D;p[i])来判断这里的根有几个，因为我们知道只有p[x]&#x3D;&#x3D;x时，才是这个树的根(因为在数组上理解就是所有的数字比如：[-1，1，2，3，4] —&gt; [ -1，4，2，1，3]，我们可以发现数组的顺序表示数字，而对应上面的数字就是其根的索引，在并查集的操作下只有根节点是i&#x3D;&#x3D;p[i]，因此我们也可以将其作为判断几个集合的依据)。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"c++基础数据结构之栈、队列、链表","slug":"c-基础数据结构之栈、队列","date":"2024-04-18T04:50:41.000Z","updated":"2024-08-06T10:56:34.515Z","comments":true,"path":"2024/04/18/c-基础数据结构之栈、队列/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/","excerpt":"","text":"c++基础数据结构之栈、队列、链表队列1234567queue&lt;int&gt;q //queue&lt;定义类型&gt;定义名称q.pop()//出队q.push()//入队q.front()//队首q.rear()//队尾q.size()//队长(队长可以为0)q.empty()//是否为空队(若是则返回1) 栈123456stack&lt;int&gt;stst.pop()//出栈st.push()//入栈st.top()//栈顶st.size()//栈长st.empty()//判断是否为空栈 1.单链表(注意结构体写法)题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 https://www.ixigua.com/7241418740699824643 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： (1) “H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 (3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式共一行，将整个链表从头到尾输出。 数据范围1≤M≤100000所有操作保证合法。 输入样例 复制123456789101110H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例 复制16 4 6 5 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;struct node &#123; //建立了一个对象 int num; //节点值 int time; //第几次插入 node* next; //定义下一个节点的指针位置&#125;;node* head = new node();//创建一个新对象叫headvoid headin(int n,int i)&#123; node* p=new node();//创建一个新节点 p-&gt;num=n;//把值输入节点中，箭头写法表示对象的属性 p-&gt;time=i;//这是次数 //下面就是插入模板操作 p-&gt;next=head-&gt;next; head-&gt;next=p;&#125;void de(int t)&#123; node* p, * q;//定义两个节点 p=head-&gt;next;//p为指向head的下一个节点 if(!t)&#123; head-&gt;next=p-&gt;next;//head指的是头，里面没值，所以实际的链表头是p delete(p);//p是实际头节点 &#125; else&#123; while(p)&#123;//找到第t次插入的数 if(p-&gt;time==t)break; p=p-&gt;next; &#125; q=p-&gt;next;//让q在p的前面，辅助删除p后面的节点 p-&gt;next=q-&gt;next; delete(q);//删除q &#125;&#125;void insert(int t,int n,int i)&#123; node* p=head-&gt;next; //让p指针指向head的下一个，然后用p节点找欲插入的值 //下面三行是创建新节点然后给其赋值的操作 node* q=new node(); q-&gt;num=n; q-&gt;time=i; //从链表头开始找 while(p)&#123; if(p-&gt;time == t)break;//找第t次插入的数 p=p-&gt;next; &#125; //把q节点插到第t次插入的数后面 q-&gt;next=p-&gt;next; p-&gt;next=q;&#125;int main()&#123; head-&gt;next=NULL;//开始时链表没有值 int m,i,x,k; char op; i=1; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;op; if(op==&#x27;H&#x27;)&#123; cin&gt;&gt;x; headin(x,i); i++; &#125; if(op==&#x27;D&#x27;)&#123; cin&gt;&gt;k; de(k); &#125; if(op==&#x27;I&#x27;)&#123; cin&gt;&gt;k&gt;&gt;x; insert(k,x,i); i++;//因为题目是记录第几次插入的数，所以要用i计数 &#125; &#125; node* p = head-&gt;next;//让p指向实际头节点 while(p)&#123; cout&lt;&lt; p-&gt;num &lt;&lt; &#x27; &#x27;; p=p-&gt;next; &#125;&#125; 2.简单计算器题目描述读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。 https://www.ixigua.com/7213692123635024436 输入格式每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。 100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2 输出格式对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入样例 复制14 + 2 * 5 - 7 / 11 输出样例 复制113.36 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;stack&lt;double&gt;d_st;stack&lt;char&gt;op_st;int level(char a)&#123; if(a==&#x27;+&#x27;||a==&#x27;-&#x27;)return 1; if(a==&#x27;*&#x27;||a==&#x27;/&#x27;)return 2;&#125;void cal()&#123; char c=op_st.top();op_st.pop(); double a,b; a=d_st.top(); d_st.pop(); b=d_st.top(); d_st.pop(); if(c==&#x27;+&#x27;)d_st.push(b+a); if(c==&#x27;-&#x27;)d_st.push(b-a); if(c==&#x27;*&#x27;)d_st.push(b*a); if(c==&#x27;/&#x27;)d_st.push(b/a);&#125;int main()&#123; string str; double x; getline(cin,str); int len=str.size(); for(int i=0;i&lt;len;i++)&#123; if(str[i]&gt;=&#x27;0&#x27; &amp;&amp; str[i]&lt;=&#x27;9&#x27;)&#123;//如果是数字 x=str[i]-&#x27;0&#x27;; while(str[i+1]&gt;=&#x27;0&#x27; &amp;&amp; str[i+1]&lt;=&#x27;9&#x27;)&#123; x=x*10+str[i+1]-&#x27;0&#x27;; i++; &#125; d_st.push(x);//把字符串数字转化为整型并推入栈 &#125; else if(str[i]==&#x27;+&#x27; || str[i]==&#x27;-&#x27; || str[i]==&#x27;*&#x27; || str[i]==&#x27;/&#x27;)&#123; if(op_st.empty()||level(str[i])&gt;level(op_st.top()))&#123;//只有优先级高于栈顶的情况才能入栈 op_st.push(str[i]); &#125; else if(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123; while(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123;//拿栈顶前两个计算 cal(); &#125; op_st.push(str[i]); &#125; &#125; &#125; while(!op_st.empty())&#123; cal(); &#125; printf(&quot;%.2lf&quot;,d_st.top());&#125; 3.约瑟夫环(队列解法)题目描述有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。 输入格式n和m。 输入样例14 17 输出样例11 3 4 2 题解1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt;qe; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; qe.push(i); &#125; while(!qe.empty())&#123; int x; for(int i=1;i&lt;=m-1;i++)&#123; x=qe.front(); qe.pop();qe.push(x);//把队头放到对尾 &#125; x=qe.front();qe.pop();//数到的数彻底出队 cout&lt;&lt;x&lt;&lt;&quot; &quot;; &#125;&#125; 4.走出迷宫(bfs)题目描述当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。 假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。 视频讲解：https://www.ixigua.com/7166253132702450212 输入格式第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。 接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。 输出格式输出从起点到出口最少需要走的步数。 输入样例12343 3S#T.#.... 输出样例16 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char a[105][105];int vis[105][105];int n,m;struct node&#123; int r,c; int step;&#125;;int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;void bfs(int sr,int sc,int er,int ec)&#123; queue&lt;node&gt;qe;//注意定义方式 node q,t;//t用来记录q的一圈4个方向 q.r=sr,q.c=sc; q.step=0; qe.push(q); vis[q.r][q.c]=1; while(!qe.empty())&#123; q=qe.front(); qe.pop(); if(q.r==er &amp;&amp; q.c==ec)&#123; cout&lt;&lt;q.step; break; &#125; for(int i=0;i&lt;4;i++)&#123; t.r=q.r+dir[i][0]; t.c=q.c+dir[i][1]; if(a[t.r][t.c]==&#x27;.&#x27; &amp;&amp; vis[t.r][t.c]==0 &amp;&amp; t.r&gt;=1&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=1&amp;&amp;t.c&lt;=n)&#123; t.step=q.step+1; vis[t.r][t.c]=1; qe.push(t); &#125; &#125; &#125;&#125;int main()&#123; int sr,sc,er,ec; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]==&#x27;S&#x27;)sr=i,sc=j; if(a[i][j]==&#x27;T&#x27;)er=i,ec=j,a[i][j]=&#x27;.&#x27;; &#125; bfs(sr,sc,er,ec);&#125; 5.出入栈判断题目描述现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。 输入格式输入第一行表示一个整数n, n&lt;&#x3D;100 接下来输入n行，每行表示一个a~z的排列。 输出格式每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。 输入样例 复制1232abcdefghijklmnopqrstuvwxyzzabcdefghijklmnopqrstuvwxy 输出样例 复制12yesno 数据范围与提示5abcdegfhijklnmopqrstuvwxyzabcdegfhijklnmopqrstzyxwvudcbaegfhijklnmopqrstuvwxyzabcdegfhijkwxyzlnmopqrstuvabcdegfhijklnmouvwxyztsrqp yesyesyesnoyes 题解12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; stack &lt;char&gt; st; int n; cin&gt;&gt;n; while(n--)&#123; string s; cin&gt;&gt;s; int len=s.size(),j=0; for(int i=0;i&lt;len;i++)&#123; char ch=i+&#x27;a&#x27;; st.push(ch); while(!st.empty() &amp;&amp; st.top()==s[j])&#123; st.pop(),j++; &#125; &#125; if(j==len)cout&lt;&lt;&quot;yes\\n&quot;; else cout&lt;&lt;&quot;no\\n&quot;; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript基本语法","slug":"JavaScript基本语法","date":"2024-04-18T04:48:23.000Z","updated":"2024-04-29T11:07:33.889Z","comments":true,"path":"2024/04/18/JavaScript基本语法/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"JavaScript基础语法介绍JavaScript介绍1.1 JavaScript是什么是一个运行在浏览器上的编程语言。 1.2JavaScript书写位置内部式： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 外部式： 1234&lt;body&gt; &lt;script src=&quot;./my.js&quot;&gt; &lt;/script&gt;&lt;/body&gt; 使用外部时，script标签里面不要写内容，否则会被忽略。 1.3JavaScript输入输出语法输出语法1： 123456&lt;body&gt; &lt;script&gt; document.write(&#x27;hey&#x27;) document.write(&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;) &lt;/script&gt;&lt;/body&gt; 输出语法2： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 输出语法3： 12345&lt;body&gt; &lt;script&gt; console.log(&#x27;haha&#x27;)//控制台输出语法，程序员调试使用 &lt;/script&gt;&lt;/body&gt; 输入语法1： 1prompt(&#x27;请输入&#x27;)//弹出一个对话框 prompt输入类型为字符串。 1.4 字面量比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量 变量2.1 变量是什么白话：用来装数据的盒子。可以用来存放数据。 2.2 变量的基本使用(与c语言定义类似) 1.声明变量1let variable //var存在与老版的JavaScript中 age为变量。 2.变量赋值1variable = 18 variable为变量，18为字面量。 变量不允许多次定义。 小小的变量使用一下： 123456&lt;body&gt; &lt;script&gt; let n=prompt(&#x27;请输入&#x27;) document.write(n) &lt;/script&gt;&lt;/body&gt; 2.3 变量命名规则与规范1. 规则①不能用关键字。 ②只能用下划线、字母、数字、＄组成，且不能用数字开头。 ③字母严格区分大小写。 2.规范①起名要有意义。 ②遵守小驼峰命名法。 数组1.1 声明数组1let arr = [1，2，3] 1.2 数组的基本使用12console.log(arr[0]) //索引console.log(arr.length) //获取长度 常量1.1 基本使用1const G = 9.8 常量不允许重新赋值，声明的时候必须赋值。 数据类型js为弱数据类型语言，只有赋值了才知道是什么数据类型。 基本数据类型number 数字型 string 字符串型 boolean 布尔型 undefined 未定义型 null 空类型 引用数据类型object 对象 1.数字类型数字类型可以由+ - * &#x2F; %各个符号进行运算。 NaN (not a number)：表示计算错误。 NaN是粘性的，任何对NaN的操作都会返回NaN。 2.字符串通过单引号、双引号或反引号包裹的数据都叫字符串。 字符串拼接：1234console.log(&#x27;12&#x27;+&#x27;34&#x27;) //字符串可以用加号拼接let a=&#x27;k&#x27;let b=&#x27;q&#x27;console.log(k+q) 模板字符串：1document.write(`大家好，我叫$&#123;name&#125;,今年$&#123;age&#125;岁`) //用反引号,变量用＄&#123;&#125;包裹 3.布尔型 (bollean)12let n=trueconsole.log(n) 4.未定义类型 (undefined)12let numconsole.log(num) //输出undefined 5.空类型 (null)12let obj=null //表示赋值了一个空的内容console.log(obj) 如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null 6.检测数据类型12typeof num //num为变量typeof(num) 7.类型转换隐式转换+号两边只要有一个是字符串，都会把另外一个转成字符串。 除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。 1234console.log(&#x27;数字&#x27; + 1) //返回&#x27;数字1&#x27;console.log(&#x27;1&#x27; + 1) //返回&#x27;11&#x27;console.log(&#x27;1&#x27; - 1) //返回0console.log(+&#x27;123&#x27;) //返回123 显示转换通过函数来进行数据转换： 12Number(str) //转换为数字类型let num = +prompt(&#x27;输入&#x27;) //输入的可以转换为数字类型 parse系列： 1234parseInt(num) //只保留数字且只保留整数parseFloat(num) //保留数字并保留小数parseInt(12px) //12 parseFloat(12.86px) //12.86 运算一元运算符前置自增12let i=1console.log(++i + 2) //2+2=4 先自加再使用。 后置自增12let i=1console.log(i++ + 2) //1+2=3 此时i已经为2，但是没有参与运算 先使用再自加。 12let i=1console.log(i++ + ++i + i) //1+3+3=7 第二个i时i为2 比较运算符1234567&gt;&lt;&gt;=&lt;=== //左右两边值是否相等=== //左右两边是否类型和值都相等!== //左右两边是否不全等 NaN不等于任何人，包括它自己。 1console.log(NaN === NaN) //false if语句123if (条件) &#123; 满足条件执行的代码&#125; 条件中只有数字0或者空字符会触发false，其余都是true。 三元运算符可以代替if双分支。 1条件 ? 满足条件执行的代码 : 不满足条件执行的代码 例子： 123456if(3&lt;5)&#123; alert(&#x27;真的&#x27;)&#125;else&#123; alert(&#x27;假的&#x27;)&#125; 和 13&lt;5 ? alert(&#x27;真的&#x27;) : alert(&#x27;假的&#x27;) 等价。 还可以作赋值操作： 1let sum = 3 &lt; 5 ? 3 : 5 //sum=3 数字补0例子123let num = prompt(&#x27;请您输入一个数字&#x27;) //类型为stringnum = num &lt; 10 ? 0 + num : num //判断小于10才补0alert(num) 输入9，输出09 输入11，输出11 数组查询12let arr=[1,2,3]console.log(arr[0]) 修改123let arr=[1,2,3]arr[0]=3console.log(arr[0]) //[3,2,3] 增加push() 添加数组末尾 unshift() 添加数组开头 1234let arr=[1,2,3]arr.push(4) //[1,2,3,4]arr.push(4,5) //[1,2,3,4,5]arr.unshift(0) //[0,1,2,3] 删除pop() 弹出最后一个元素 shift() 弹出第一个元素 splice() 切片删除 &#x2F;&#x2F;arr.plice(起始位置，删除几个) 12345678let arr=[1,2,3]arr.pop() //[1,2]console.log(arr.pop()) //3arr.shift() //[2,3]console.log(arr.shift) //1arr.splice(1,1) //[1,3]arr.splice(1) //[1] 删除索引1后面的所有arr.splice(1,2) //[1] 函数123function 函数名() &#123; 函数体&#125; 调用: 1函数名() 例如： 12345function sayhi&#123; console.log(&#x27;hi&#x27;)&#125;sayhi() 异常处理语句throw语句1throw expression; 使用这个语句后就会弹出error： 12345678for(let i=1;i&lt;=5;i++)&#123; if(i!=4)&#123; console.log(&quot;yes&quot;); &#125; else&#123; throw &quot;not 4&quot;; //Uncaught not 4 &#125;&#125; try…catch语句123456try&#123; ...&#125; catch (error)&#123; console.error(error)&#125; catch块可以用来处理所有try块总产生的异常。 finally块12345678openMyFile();try &#123; writeMyFile(theData); //This may throw a error&#125; catch (e) &#123; handleError(e); // If we got a error we handle it&#125; finally &#123; closeMyFile(); // always close the resource&#125; finally块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。 循环与迭代 for 语句 do…while 语句 while 语句 label 语句 break 语句 continue 语句 for…in 语句 for…of 语句 其循环方式与c语言相似，不再一一赘述。 对象一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法。 对象及其属性： 1234var myCar = new Object();myCar.make = &quot;Ford&quot;;myCar.model = &quot;Mustang&quot;;myCar.year = 1969; 可以按如下方法访问对象： 123myCar[&quot;make&quot;] = &quot;Ford&quot;;myCar[&quot;model&quot;] = &quot;Mustang&quot;;myCar[&quot;year&quot;] = 1969; 创建新对象使用对象初始化器创建1234567var obj = &#123; property_1: value_1, // property_# 可以是一个标识符... 2: value_2, // 或一个数字... [&quot;property&quot; + 3]: value_3, // 或一个可计算的 key 名... // ..., &quot;property n&quot;: value_n,&#125;; // 或一个字符串 使用构造函数创建用构造函数创建分两种： 通过创建一个构造函数来定义对象的类型。(建议首字母大写) 通过 new 创建对象实例。 这里首先定义一个对象类型，并且赋予其make,model,year属性。 12345function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125; 注意这里是通过this来给对象类型属性值赋值 然后你就可以创建一个新对象啦 1var mycar = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993); 或者你也可以让类中加入一个owner： 123456function Car(make, model, year, owner) &#123; this.make = make; this.model = model; this.year = year; this.owner = owner;&#125; 那么你就可以这样创建： 12var car1 = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993, rand);var car2 = new Car(&quot;Nissan&quot;, &quot;300ZX&quot;, 1992, ken); 就可以这样索引读取： 1car2.owner.name; 你也可以为之前定义的对象增加新的属性： 1car1.color = &quot;black&quot;; 注意这里只是这个car1增加了新属性，不影响其他car1,car3 使用Object.create方法创建及使用Object.create()函数创建 123456789101112131415var Animal = &#123; type: &quot;Invertebrates&quot;, // 属性默认值(无脊椎动物) displayType: function () &#123; //类里面可以包含函数 console.log(this.type); //该函数用来显示type的值 &#125;,&#125;;// 创建一种新的动物——animal1var animal1 = Object.create(Animal);animal1.displayType(); // 输出:Invertebrates(因为没有没有给type赋值)// 创建一种新的动物——Fishesvar fish = Object.create(Animal);fish.type = &quot;Fishes&quot;;fish.displayType(); // 输出:Fishes","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"如何优雅的将秒换算成-时:分:秒？","slug":"秒转换时间","date":"2024-04-18T01:29:59.000Z","updated":"2024-04-29T11:06:44.553Z","comments":true,"path":"2024/04/18/秒转换时间/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/","excerpt":"","text":"如何优雅的将秒换算成-时:分:秒？思路先看一下题目，发现就是一道模拟题，但是又一些细节的。 首先是数据的规模：时间不超过 10^18,所以需要开 long long。 然后首先要忽略掉毫秒。 这里普及一个知识:1s &#x3D; 1000ms 所以需要忽略后面的三位。直接整除 1000 就可以了。 之后就是处理时分秒了： 1.小时由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用24*60*60来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数60*60（也就是3600），就是小时值了。 2.分钟分钟要先对每小时的秒数60*60取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。 3.秒直接对60取余，剩下的就是秒了。 时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。 当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。 要用到两个函数： 一个是setw()函数，这个函数可以限定域宽，宽度就是括号里的数字。 另外一个setfill()函数，这个函数可以设置当实际的宽度不足setw()函数的值时，用某个字符来补足。（setfill()函数最好放在setw()函数前面） 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,h,m,s; cin&gt;&gt;n; n=n/1000; h=n%(24*3600)/3600; m=n%3600/60; s=n%60; cout&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;s;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"css背景","slug":"css-bgc","date":"2024-01-20T04:25:09.000Z","updated":"2024-04-29T11:07:56.347Z","comments":true,"path":"2024/01/20/css-bgc/","link":"","permalink":"https://bayeeaa.github.io/2024/01/20/css-bgc/","excerpt":"","text":"CSS背景背景颜色background-color(bgc) 123div &#123; background-color: pink;&#125; 颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制… 背景图片background-image(bgi) 123div &#123; background-image: url(&#x27;图片的路径&#x27;);&#125; ①背景图片中url可以省略引号。 ②背景图片默认是在水平和垂直方向平铺的。 ③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。 背景平铺background-repeat(bgr) 123div&#123; background-repeat:no-repeat;&#125; repeat (默认值)水平和垂直方向都平铺 no-repeat 不平铺 repeat-x 沿着水平方向(x轴)平铺 repeat-y 沿着垂直方向(y轴)平铺 背景位置background-position(bgp) 123div&#123; background-position:&#125; 方位名词水平方向left、center、right 垂直方向top、center、bottom 123div&#123; background-position: right bottom; //水平位置 垂直位置&#125; 数字+px坐标轴①原点(0,0) 盒子左上角 ②x轴 水平向右 ③y轴 垂直向下 操作将图片左上角与坐标点重合即可 123div&#123; background-position: 50px 100px; //水平位置 垂直位置&#125; 背景相关属性连写background: color image repeat position 可以不按顺序写。 123div&#123; background: pink url(./images/1.jpg) no-repeat bottom center ;&#125; 与img的区别①img标签是一个标签，不设置宽高默认会以原尺寸显示。 ②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"}]},{"title":"递归——深度优先搜索(dfs)","slug":"递归——深度优先搜索(dfs)","date":"2023-11-06T14:26:27.000Z","updated":"2024-04-29T11:06:51.155Z","comments":true,"path":"2023/11/06/递归——深度优先搜索(dfs)/","link":"","permalink":"https://bayeeaa.github.io/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/","excerpt":"","text":"递归——深度优先搜索(dfs)区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索： 递归方法类似于栈，将数据一直递取到底后自下往上出栈。 大致框架如下： 1234567891011121314viod dfs(int k)&#123; if(输出条件)&#123; cout&lt;&lt; &#125; else&#123; for(int i=0;i&lt;n;i++)&#123; if(vis[i]==0)&#123; a[k]=数字,vis[i]=1//标记使用; dfs(k+1);//向下递取 vis[i]=0;//将其拿出，返回原先状态 &#125; &#125; &#125;&#125; 下列题目方式解决一些排列组合问题。 组合输出 –5个数字组合输入3个盒子 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,r;int a[200],vis[200];//a用来记录牌子，vis用来记录牌子的使用情况int is_rise(int b[])&#123;//判断是否是递增数组 int flag=1; for(int i=1;i&lt;r;i++)&#123; if(a[i]&gt;a[i+1])&#123; flag=0; &#125; &#125; return flag;&#125;void dfs(int k)&#123;//k为盒子的编号，或可以理解为步数 if(k==r+1&amp;&amp;is_rise(a))&#123; for(int i=1;i&lt;=r;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; return; &#125; for(int i=1;i&lt;=n;i++)&#123;//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。 if(vis[i]==0)&#123; a[k]=i,vis[i]=1; dfs(k+1); vis[i]=0;//将牌子拿出来，此时就要把vis归回0 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;r; dfs(1);&#125; 这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。 素数环 eg：输入8 输出4 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[25],vis[25];int n,cnt;int isPrime(int x)&#123; if(x&lt;2)return 0; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)return 0; &#125; return 1;&#125;void dfs(int k)&#123; if(k==n+1 &amp;&amp; isPrime(a[1]+a[n]))&#123;//是否超出边界&amp;&amp;是否头尾相加是素数 cnt++; return; &#125; for(int i=2;i&lt;=n;i++)&#123; if(vis[i]==0 &amp;&amp; isPrime(i+a[k-1]))&#123;//vis用来看有没有用过这个数字 a[k]=i,vis[i]=1;//a用来保存数字 dfs(k+1); vis[i]=0;//当前的这个数字清除，再向下dfs &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; a[1]=1,vis[1]=1; dfs(2); cout&lt;&lt;cnt; &#125; 全排列问题 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[25],b[25]; //a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里void dfs(int k)&#123; //depth first search if(k==n+1)&#123; //k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了 for(int i=1;i&lt;=n;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for(int i=1;i&lt;=n;i++)&#123;//i是指拿在你手上的牌的数字，没用0为了更好理解 if(b[i]==0)&#123;//看看这个牌用过没有，b数组用来看这个牌用过没有用的 a[k]=i,b[i]=1;//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了 dfs(k+1);//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里 b[i]=0;//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推 &#125;&#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(1);&#125; 体积 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt;int a[25],vis[1005];void dfs(int k,int sum)&#123; if(k==n+1)&#123;// cout&lt;&lt;sum&lt;&lt;&quot; &quot;; vis[sum]=1; return; &#125; dfs(k+1,sum+a[k]); dfs(k+1,sum);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; dfs(1,0); for(int i=1;i&lt;=1000;i++)&#123; if(vis[i])cnt++; &#125; cout&lt;&lt;cnt; return 0;&#125; 若把上面代码的注释删除则可以得到： 12331 3 48 4 5 1 7 3 4 0 6 由此可知上面深度搜索遍历的顺序是： 123456781+3+41+31+413+4340 以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。 相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"爬取pixiv日前十图片并下载至本地","slug":"pixiv-crawler","date":"2023-09-11T04:21:25.000Z","updated":"2024-04-29T11:07:14.360Z","comments":true,"path":"2023/09/11/pixiv-crawler/","link":"","permalink":"https://bayeeaa.github.io/2023/09/11/pixiv-crawler/","excerpt":"","text":"爬取pixivic日前十图片实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期： 1.发送请求首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址： 于是我们就可以向这个api发送请求： 1234import requestsurl = &quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;reponse = requests.get(url)print(reponse) #返回&lt;Response [200]&gt; 因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。 2.解析数据返回数据长这个样子： json使用这就是标准的json形式文件，但还不是一个字典(其实很像)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。 我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可： 123response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;]#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png#就是日排行第一的图 但是当你将网站复制进浏览器时你会发现打不开。 url拼接也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接 图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。 3.下载图片至本地目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了： 12345img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot;img = requests.get(img_url)with open(&quot;./top1.jpg&quot;,&quot;wb&quot;) as f: #&quot;wb&quot;是以二进制写入 f.write(img.content) #content是指获取二进制内容 此时你已经可以看到top1的图片下载当前文件夹了。 同理，下载前十的图片只需要加入for循环就可以了，以下省略。 4.下载至指定文件夹这里就需要导入os包： 1234import ospath = &#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27; #这是我的绝对地址if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹，文件夹名字为2023-9-7 path书写这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法： 第二条中的r是用来申明不是转义字符。 这样就可以创建一个文件夹了~ 然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。 5.关于api中日期的变化因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期： 123import datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3) 然后只需要再拼接如url中就可以啦~ 完整代码123456789101112131415161718192021import requestsimport osimport datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3)url = &quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;+str(api_day)+&quot;&amp;mode=day&amp;pageSize=302&quot;response = requests.get(url)date = url[40:50]path = &#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;+date #linux写法if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹for i in range(10): img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][i][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot; img = requests.get(img_url) with open(path+&quot;/top&quot;+str(i+1)+&quot;.jpg&quot;,&quot;wb&quot;) as f: f.write(img.content) print(&quot;正在保存top&quot;+str(i+1)+&quot;中...&quot;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫 --- 以爬取笔趣阁小说为例","slug":"biquge","date":"2023-08-31T07:40:23.000Z","updated":"2024-04-29T11:07:47.514Z","comments":true,"path":"2023/08/31/biquge/","link":"","permalink":"https://bayeeaa.github.io/2023/08/31/biquge/","excerpt":"","text":"爬虫 — 以爬取笔趣阁小说为例1.发送请求123456import requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers) 这是requests请求，若返回response值为200，则表示请求成功 2.获取数据1response = requests.get(url,headers).text 可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析 3.解析数据有以下几种途径：css、xpath、re正则表达 等等 让我们来看看分别用这三种方法怎么去解析到一个章节的标题 css123import parselselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() 这种方法通过css选择器进行选择 xpath123import parselselector = parsel.Selector(response)novel_title = selector.xpath(&quot;//*[@class=&quot;bookname&quot;]/h1/text()&quot;).get() 注意text后面的() re12import renovel_title = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0] 这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串 *注意：以上方法各有利弊，选择合适的方式来解析数据 4.保存数据12with open(&quot;file_name&quot;+&quot;.txt&quot;,mode=&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: #w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入f.write(novel_context) #写入文件 with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径 以上思路已经理清楚了，下面开始实践：爬取一章12345678910111213import parselimport requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers).textselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() #css方法解析数据novel_context_list = selector.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) 注意：join函数的使用： 123456a=[&quot;1&quot;,&quot;2&quot;,&quot;8&quot;,&quot;9&quot;]print(&quot; &quot;.join(a)) #输出1 2 8 9print(&quot;\\n&quot;.join(a)) #输出1(换行)2(换行)8(换行)9b=&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;print(&quot; &quot;.join(a)) #输出a b （注意seq不能是int整形） 爬取各章url12345678910111213import requestsimport reurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] print(novel_url) print(novel_title) 在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的： 我们就可以用re来解析到各个章节的url和title 完整代码123456789101112131415161718192021222324import requestsimport reimport parselurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] novel_response = requests.get(novel_url, headers).text selectors = parsel.Selector(novel_response) novel_context_list = selectors.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) print(&quot;正在保存&quot;+novel_title) novel_title = &quot;*&quot; + novel_title with open(novel_name+&quot;.txt&quot;,mode=&quot;a&quot;) as f: f.write(novel_title) f.write(&quot;\\n&quot;) f.write(novel_context) f.write(&quot;\\n&quot;) f.write(&quot;\\n&quot;) 运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"CSS选择器","slug":"css选择器","date":"2023-08-23T04:35:42.000Z","updated":"2024-04-29T11:08:02.355Z","comments":true,"path":"2023/08/23/css选择器/","link":"","permalink":"https://bayeeaa.github.io/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"引入方式引入方式有以下三种： 1.内嵌式 12345678910111213&lt;!-- 内嵌式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; colour&#123; colour:pink; &#125; &lt;/style&gt;&lt;/head&gt; 2.外联式 12345678910&lt;!-- 外联式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./111.css&quot;&gt; &lt;!-- 111为引入文件名 --&gt;&lt;/head&gt; 3.行内式 1234567&lt;!-- 行内式 --&gt;&lt;body&gt; &lt;div class=&quot;colour&quot;&gt; abcd &lt;/div&gt; &lt;div style=&quot;color: aqua;font-size: large;&quot;&gt;abab&lt;/div&gt;&lt;/body&gt; 选择器一共有4种：标签选择器、类选择器、id选择器、通符选择器 注：一下选择器均是在style标签下的 1.标签123div&#123; color:blue;&#125; 所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div) 2.类选择器123.color-choose&#123; color:blue;&#125; 其html调用方式为： 1&lt;div class=&quot;color-choose&quot;&gt; abab &lt;/div&gt; 3.id选择器123#color&#123; color:blue;&#125; 其html调用方式为： 1&lt;div id=&quot;color&quot;&gt; abab &lt;/div&gt; 注意：id只得调用一次 4.通符选择器12345*&#123; margin:0; padding:0;&#125;&lt;!-- 清除内外边距 --&gt; 对全局内容生效 选择器的选择1.后代 （后面所有代）问题如下 1234&lt;p&gt; abab &lt;/p&gt;&lt;div&gt; &lt;p&gt; 哈哈哈 &lt;/p&gt;&lt;/div&gt; 欲选择div中的p标签，而不是外部的p 以如下方法实现： 12345&lt;style&gt; div p &#123; color:blue; &#125;&lt;/style&gt; 2.子代 （后面一代）问题是要选中div后面的一代 123456&lt;div&gt; &lt;p&gt; dd &lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot;&gt; ddd &lt;/a&gt; &lt;/p&gt;&lt;/div&gt; 以如下方法实现： 123div&gt;p&#123; color:blue;&#125; 3.并集问题：想要让以下这些标签被选到 1234&lt;p&gt; p &lt;/p&gt;&lt;div&gt; div &lt;/div&gt;&lt;span&gt; span &lt;/span&gt;&lt;h1&gt; haha &lt;/h1&gt; 以下面方法实现： 123p,div,span,h1&#123; color:blue;&#125; 4.交集问题：只想要选中下面p中带class&#x3D;”c”的 1234&lt;div class=&quot;c&quot;&gt;abcd&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;a&lt;/p&gt;&lt;div class=&quot;c&quot;&gt;d&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;b&lt;/p&gt; 以下面方法实现： 123p.c&#123; color:blue;&#125; p是标签，c是类名（前面带个.的） 5.伪类问题：想要让鼠标悬停在如下超链接上能够变色 1&lt;a href=&quot;~~~&quot;&gt;传送&lt;/a&gt; 一下方法实现： 1234a:hover&#123; color:red; background-color:yellow;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"}]},{"title":"破壳啦","slug":"page1","date":"2023-08-21T11:25:42.000Z","updated":"2024-04-29T11:07:26.258Z","comments":true,"path":"2023/08/21/page1/","link":"","permalink":"https://bayeeaa.github.io/2023/08/21/page1/","excerpt":"","text":"终于创建好一个博客啦！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://bayeeaa.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"},{"name":"Git","slug":"Git","permalink":"https://bayeeaa.github.io/tags/Git/"},{"name":"Java","slug":"Java","permalink":"https://bayeeaa.github.io/tags/Java/"},{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"},{"name":"制图","slug":"制图","permalink":"https://bayeeaa.github.io/tags/%E5%88%B6%E5%9B%BE/"},{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"},{"name":"TS","slug":"TS","permalink":"https://bayeeaa.github.io/tags/TS/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"生活","slug":"生活","permalink":"https://bayeeaa.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}