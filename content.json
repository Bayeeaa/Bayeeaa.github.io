{"meta":{"title":"ye's blog","subtitle":"","description":"","author":"Ye","url":"https://Bayeeaa.github.io","root":"/"},"pages":[{"title":"about","date":"2023-08-22T07:06:19.000Z","updated":"2023-08-22T07:07:20.142Z","comments":false,"path":"about/index.html","permalink":"https://bayeeaa.github.io/about/index.html","excerpt":"","text":"hello!"}],"posts":[{"title":"图算法-用Dijkstra和Prim求最小路径","slug":"图算法-用Dijkstra和Prim求最小路径","date":"2024-06-15T14:44:05.000Z","updated":"2024-06-15T14:44:30.930Z","comments":true,"path":"2024/06/15/图算法-用Dijkstra和Prim求最小路径/","link":"","permalink":"https://bayeeaa.github.io/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/","excerpt":"","text":"图算法-用Dijkstra和Prim求最小路径解决问题：在一个树中有多个节点和多条有向或无向的边，若我们给各个边附上权值，那么利用这两个算法可以计算从一个节点到所有节点的最小距离。实际中可以解决比如快递在区域配送最短的路径等问题。 Dijkstra思路例如以第1个节点为树根并循环整个树的节点，找到与1连接的所有点然后比较到这个点的距离是否小于原点(节点1)到这个点的距离(此时还没有)，若此时的距离比另一条路到这个点的距离小，则存入数据，以此类推。 具体如下：我们用dist数组来存入原点到所有点的最小距离，最开始的时候设置所有的点到原点的距离为无穷大。 12memset(dist, 0x3f, sizeof(dist));dist[1] = 0;//原点到原点的距离为0 用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。 首先用for遍历每个点，寻找到每一个点的到原点的距离。 再在用一个for来确定这个点是到原点的最短距离。 1234567891011for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t if(!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; state[t] = 1;//state[i]置为1。 for(int j = h[t]; j != -1; j = ne[j])&#123;//遍历t所有可以到达的节点i int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新dist[j] &#125;&#125; 整个函数： 123456789101112131415void Dijkstra()&#123; memset(dist, 0x3f, sizeof(dist));//dist数组的各个元素为无穷大 dist[1] = 0;//源点到源点的距离为置为 0 for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t if(!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; state[t] = 1;//state[i]置为1。 for(int j = h[t]; j != -1; j = ne[j])&#123;//遍历t所有可以到达的节点i int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新dist[j] &#125; &#125;&#125; Prim思路prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。prim算法相比于dijkstra是贪心的，它要寻找的是每一个点之间的最短距离。 具体如下与Dijkstra一样用dist存入距离，并最开始用无穷大赋值。 用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。 用pre数组来保存节点是和谁连通的。 伪代码： 12345678int dist[n],state[n],pre[n];dist[1] = 0;for(i : 1 ~ n)&#123; t &lt;- 没有连通起来，但是距离连通部分最近的点; state[t] = 1; 更新 dist 和 pre;&#125; 我们在prim里面相当于是将树的每个点一个一个加入到一个集合中，这个集合就是生成的树。每次选择树都要看看是否在树中并且到树的距离最短，如果是则加入到集合中。 12345678910111213141516171819202122232425void prim()&#123; memset(dt,0x3f, sizeof(dt));//初始化距离数组为一个很大的数（10亿左右） int res= 0; dt[1] = 0;//从 1 号节点开始生成 for(int i = 0; i &lt; n; i++)&#123;//每次循环选出一个点加入到生成树 int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//每个节点一次判断 if(!st[j] &amp;&amp; (t == -1 || dt[j] &lt; dt[t]))//如果没有在树中，且到树的距离最短，则选择该点 t = j; &#125; if(dt[t] == 0x3f3f3f3f) &#123; cout &lt;&lt; &quot;impossible&quot;; return; &#125; st[t] = 1;// 选择该点 res += dt[t]; for(int i = 1; i &lt;= n; i++)&#123;//更新生成树外的点到生成树的距离 if(dt[i] &gt; g[t][i] &amp;&amp; !st[i])&#123;//从 t 到节点 i 的距离小于原来距离，则更新。 dt[i] = g[t][i];//更新距离 pre[i] = t;//从 t 到 i 的距离更短，i 的前驱变为 t. &#125; &#125; &#125; cout &lt;&lt; res;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"本地已经后端部署，前端response返回“Method Post not allowed”问题","slug":"本地已经后端部署，前端response返回“Method-Post-not-allowed”问题","date":"2024-05-04T15:38:25.000Z","updated":"2024-05-04T15:49:16.020Z","comments":true,"path":"2024/05/04/本地已经后端部署，前端response返回“Method-Post-not-allowed”问题/","link":"","permalink":"https://bayeeaa.github.io/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/","excerpt":"","text":"这次是在做前端的时候，前后端联调发生的问题。接口名前后都对的上然而显示“Post方法不被允许”： 第一反应是去看自定义端口最后的url是不是少一个“&#x2F;”： 发现并没有少。 最后经过排查发现前后端地址没有对上。前端地址没有连接本地的地址。 修改target的请求地址为”http://127.0.0.1:3381“，成功解决。","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"}]},{"title":"Promise链式调用与async函数解决回调地狱问题","slug":"Promise链式调用与async函数解决回调地狱问题","date":"2024-05-01T02:36:23.000Z","updated":"2024-05-02T15:54:31.017Z","comments":true,"path":"2024/05/01/Promise链式调用与async函数解决回调地狱问题/","link":"","permalink":"https://bayeeaa.github.io/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/","excerpt":"","text":"在平时我们使用vue的时候经常会看到在请求接口的时候总是会有async与await： 这是为什么呢？不能直接请求接口吗？ 这里其实是为了避免出现回调地狱的问题。要理解清楚这个问题不妨从promise的链式调用开始讲起。 什么是回调地狱？概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调地狱。 我们知道一个axios函数中包含一些url等请求参数和一个.then的回调函数，由于其异步性，一个接口的请求需要等到回调函数成功调回才算结束。于是要是我们在.then里面在嵌入一个axios函数的话就需要等到上一层请求后再进入这层，再由这层回调到上层。代码量一多，不仅可读性差而且异常无法捕获，耦合性严重，牵一发动全身。比如看下面代码： 12345678910axios(&#123;url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; const pname = res.data.list[5] console.log(pname); axios(&#123;url:&#x27;http://hmajax.itheima.net/api/city!&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; const cname = res.data.list[0] console.log(cname); &#125;) &#125;).catch(error =&gt; &#123; console.log(error);&#125;) 我在第二个url中最后加了一个“!”让其错误，并让catch寻找错误的地方。然而我们发现： 其错误直接来源于axios的源码处，而且显示Uncaught (in promise)，这就是回调地狱最直接的一个弊端处。 好了这里又涉及到一个词叫promise。 何为Promise？mdn的解释是：“Promise是一个对象，它代表了一个异步操作的最终完成或者失败。”所以说Promise就是一个函数返回的对象，不然每次做回调操作都要自己手动传一个回调函数进去。 解释：依靠then()方法回返回一个新生成的Promise对象特性，继续串联下一环任务，直到结束。而then()回调函数中的返回值会影响新生成的Promise对象最终状态和结果。这样通过链式调用，可以有效解决回调函数嵌套问题。 123456789const p = new Promise((reslove, reject) =&gt; &#123; setTimeout(() =&gt; &#123; //设置时间模拟ajax请求 reslove(&#x27;北京市&#x27;) &#125;, 2000)&#125;)const p2 = p.then(res =&gt; &#123; console.log(res); //北京&#125;)console.log(p2 === p); //false 可以看到我们创建了一个新的promise对象并赋值给p，然后再用p触发回调函数，并生成了一个全新的promise对象并赋值给p2。 在最后一行的log中，使用了三等判断进行比较，我们知道三等判断，判断的是两个变量保存的内存地址，最后其返回了false更可以说明生成的是一个全新的promise对象。 所以知道了promise的工作原理，我们就可以这样写： 12345678910axios(&#123;url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; const pname = res.data.list[5] console.log(pname); return axios(&#123;url:&#x27;http://hmajax.itheima.net/api/city!&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; const cname = res.data.list[0] console.log(cname); &#125;) &#125;).catch(error =&gt; &#123; console.log(error);&#125;) 没错，就是在第二个axios前面多了一个return，就可以捕获到第二层的错误了。 async函数和await我们现在知道了promise可以解决回调地狱，但是这还是在回调函数里面不断嵌套，可读性极差，这时async函数(意思为“异步”)的引入就极大的改善了这个问题。 定义：async函数是使用async关机字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键词。async和await关键词让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。 因此我们只需要这样： 123456789const getData = async () =&gt; &#123; const pObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;) const pname = pObj.data.list[5] const cObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;) const cname = cObj.data.list[0] console.log(pname); console.log(cname);&#125;getData() //别忘了调用函数 或者： 12345678910111213let pname = []let cname = []const getData = async () =&gt; &#123; await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; pname = res.data.list[5] &#125;) await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; cname = res.data.list[0] &#125;) console.log(pname); console.log(cname);&#125;getData() 注意上面第二个代码中pname和cname没有用const定义，是因为当我在外面用 12const pname = []const cname = [] 定义时发现报出错误：Assignment to constant variable（把常量赋值给了变量） 这是因为我们使用 const 定义了变量且存在初始值。 后面又给这个变量赋值，所以报错了。ES6 标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域：使用 const 定义的常量，不能修改它的值，且定义的常量必须赋初值；let 定义的是变量，可以进行变量赋值操作，且不需要赋初值。这个错误就是因为我们修改了常量而引起的错误，虽然某些浏览器不报错，但是无效果！所以解决方法就是前面加： 12let pname = []let cname = [] 成功解决问题。 – 这里debug的时候发现const和let这块还有点含糊，const似乎最好是赋值一个对象或数组，再对对象进行赋值。等我哪天彻底搞明白了后单独出一期讲讲_(:3 ⌒ﾞ)__","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"JavaScript-ES6箭头函数使用细则","slug":"ES6箭头函数","date":"2024-04-29T10:47:55.000Z","updated":"2024-04-29T14:10:11.114Z","comments":true,"path":"2024/04/29/ES6箭头函数/","link":"","permalink":"https://bayeeaa.github.io/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们知道在ES6之前使用函数要使用function： 123function fn(形参) &#123; 函数体&#125; 然而在function中this指向的对象不够清晰明确，以及其表达不够简洁，于是引入的箭头函数： 123(形参) =&gt; &#123; 函数体&#125; 由于其重要性，以及在vue中的大量使用，我将着重讨论下箭头函数的使用方法，函数参数和this指向问题。 使用方法以及简写条件1234567const fn = function () &#123; console.log(123) //function写法&#125;const fn = () =&gt; &#123; console.log(123) //箭头写法&#125; 当传入只有一个形参时，小括号可以省略: 1234const fn = x =&gt; &#123; console.log(x+x)&#125;fn(1) //2 当函数体只有一行时可以省略大括号: 123456789const fn = x =&gt; console.log(x+x)fn(2) //4const f = (x,y) =&gt; console.log(x+y)f(1,2) //3const form = document.querySelector(&#x27;form&#x27;)form.addEventListener(&#x27;click&#x27;, ev =&gt; ev.preventDefault()) //形参小括号和函数体大括号都省略//阻止表单默认提交时事件 箭头函数可以直接返回一个对象： 123const fn = (uname) =&gt; (&#123; uname: uname &#125;) // 属性: 值const fn = (uname) =&gt; (&#123; uname &#125;) //属性和值的名字一样的时候也可以简写fn(&#x27;ye&#x27;) //&#123;uname: &#x27;ye&#x27;&#125; 这里不用大括号包着是因为对象的大括号和其冲突了，所以用小括号代替了。 箭头函数没有arguments动态参数箭头函数里面只有剩余参数…arr,所以只能用剩余参数来传入数组进行计算。 12345678const getSum = (...arr) =&gt; &#123; let sum=0 for(let i = 0;i &lt; arr.length; i++)&#123; sum +=arr[i] &#125; return sum&#125;console.log(getSum(2,3)); //5 那么何为动态参数，何为剩余参数呢？ arguments动态参数123456789function getSum() &#123; let sum=0 console.log(arguments) //[2,3,4] for(let i = 0;i &lt; arguments.length; i++)&#123; sum +=arguments[i] &#125; console.log(sum)&#125;getSum(2,3,4) //9 arguments动态参数只存在于function函数里面，其是个伪数组，在函数里充当傀儡。 函数剩余参数剩余参数没有的固定名字，这里以arr为例。 123456789function getSum(a,b,...arr) &#123; //这里arr是名字，可以自定义 let sum=0 console.log(arr) //[4,5] for(let i = 0;i &lt; arr.length; i++)&#123; sum += arr[i] &#125; console.log(sum)&#125;getSum(2,3,4,5) //9 可以看到剩余参数顾名思义就是取剩下没有对号入座的参数。a&#x3D;2,b&#x3D;3,那么剩下的就由arr接收。注意前面的三个点是展开运算符，它可以让这几个数字组合成一个数组。 1234fn = (...arr) =&gt; &#123; console.log(arr); &#125;fn(1,2,3) //[1,2,3] 没有展开运算符： 1234fn = (arr) =&gt; &#123; console.log(arr); &#125;fn(1,2,3) //1 箭头函数this问题我们知道this是指向的是环境对象，比如我们输入： 1234567const obj = &#123; number: &#x27;1&#x27;, hello: function () &#123; console.log(this) &#125;&#125;obj.hello() //&#123;number: &#x27;1&#x27;, hello: ƒ&#125; 可以看到，我们定义了一个obj对象然后里面放了一个number和一个hello函数，当我们用obj调用hello函数时，this就指向了obj。那么我们就可以初次判断出谁调用的这个函数，this就指向谁。是不是这样呢？我们可以就单纯输入下面这行。 1console.log(this) //window 我们发现返回的是window，而我们知道window是作用域链的链头。因为我们清楚其实我们每次调用函数都应该要在前面加上window作为调用的对象，但是这样极其的重复与单调故将其省去了。这样也就说明了this确实是指向其调用的对象。 12345function fn() &#123; console.log(this)&#125;fn() //windowwindow.fn() //window 回到这个论题，我们可以发现每一个新函数都要根据它是被如何调用的来定义这个函数的this值，非常让人讨厌。因此在箭头函数中，箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。 当我们再输入： 1234567const obj = &#123; number: &#x27;1&#x27;, hello: () =&gt; &#123; console.log(this) &#125;&#125;obj.hello() //Window hello的上一级时obj，而调用obj的对象是window，所以输出window。 再比如： 1234567891011const obj = &#123; number: &#x27;1&#x27;, hello: function () &#123; let i = 10 const count = () =&gt; &#123; console.log(this) &#125; count() &#125;&#125;obj.hello() //&#123;number: &#x27;1&#x27;, hello: ƒ&#125; count函数的上一层是hello，而调用hello的是obj对象，所以输出obj。 然而在实际开发中，事件回调函数使用箭头函数时，this为全局的window。因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。 123btn.addEventListner(&#x27;click&#x27;, function () &#123; console.log(this) //this指向btn&#125;)","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"AJAX-axios库使用与http协议","slug":"axios","date":"2024-04-26T15:41:11.000Z","updated":"2024-05-02T13:51:08.409Z","comments":true,"path":"2024/04/26/axios/","link":"","permalink":"https://bayeeaa.github.io/2024/04/26/axios/","excerpt":"","text":"AJAX-axios库使用与http协议当我们需要将前后端数据进行传递时，我们可以运用AJAX技术。AJAX也就是异步的JavaScript和XML(Asynchronous JavaScript And XML)。简单的说，就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON,XML,HTML和text文本等格式发送和接收数据。 AJAX工作原理 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） axios使用axios是基于Promise的HTTP客户端作用于浏览器和node.js，属于网络请求库。 语法引入axios.js的两种方法： 使用 jsDelivr CDN: 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用 unpkg CDN: 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 函数基本使用： 12345axios(&#123; url:&#x27;目标地址&#x27;&#125;).then(result=&gt;&#123; //后端返回数据&#125;) axios-查询参数使用axios提供的params选项(param是“参数”的意思) 123456789axios(&#123; url:&#x27;&#x27;, params:&#123; 参数名:值 &#125;&#125;).then(result=&gt;&#123; //返回值 //console.log(result)&#125;) 比如： 12345678axios(&#123; url: &#x27;https://hmajax.itheima.net/api/city&#x27;, params:&#123; pname: &#x27;河北省&#x27; &#125;&#125;).then(result=&gt;&#123; console.log(result);&#125;) 查询完的数据就可以在Response里找到result值，一般情况是返回一个message和一个res，其返回的数据是个json文件。 axios-请求配置12345678910axios(&#123; url:&#x27;&#x27;, method:&#x27;请求方法&#x27;, data:&#123; 参数名:值 &#125;&#125;).then(result=&gt;&#123; //返回值 //console.log(result)&#125;) axios将data对象的数据通过上述方式传入后端，后端就会根据其传入的关键词获得对应的res并在then后面得到。 axios-错误处理在then方法的后面，通过点语法调用catch方法，传入回调函数并定义形参。 12345678axios(&#123; //请求选项&#125;).then(result =&gt; &#123; //处理数据&#125;).catch(error =&gt; &#123; //处理错误 //console.log(error)&#125;) 该方法可以捕捉到错误数据，并将数据传入error形参中，于是就可以将错误数据解析并返回客户端中显示。（其实error可以用console.log在控制台查看，但是catch可以将数据传入并可解析） 1alert(error.response.data.message) //一般情况下可以通过这样解析json文件并弹出问题 HTTP协议Request Headershttp协议规定了浏览器发送及服务器返回内容的格式，也就是如果你传入data对象，报文会将其转化为一个json文件打包传给后端，然后后端再传入对应的json文件。 如下图就是一个请求报文(也就是请求头)： Accept中可以看到返回的是个json文件，Host是域名，User-Agent是用来模仿用户登录。 Resonpse Headers当我们后端受到前端的request headers后就会相应的传入response headers，这个headers包括：响应行，响应头，空行，响应体。响应体就包含了我们需要的json文件，浏览器会将该文件通过js渲染，显示于页面中。在文件传输的时候可能会有前后传递出错的时候，这时候就需要状态码来告知错误信息。 状态码有如下几种： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"并查集","slug":"并查集","date":"2024-04-19T13:41:40.000Z","updated":"2024-05-02T15:58:02.740Z","comments":true,"path":"2024/04/19/并查集/","link":"","permalink":"https://bayeeaa.github.io/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集其实解决的内容就是类似于集合合并的问题，然而如果用普通的数组去储存一个集合若数据量大，不仅调用时占用内存空间大，而且不便于插入或查询操作，因此引入并查集可以很好的解决这点。 功能1.将两个集合合并 2.询问两个元素是否再一个集合当中 思路理解这个问题就需要把集合给看成一个树，然后这个树的树根就代表这个集合。当想询问其中一个节点时，我们只要访问这个节点father，然后再找这个father的grandfather直到到树根，就能确定这个点的树根。 123//p[x]表示x的父节点if(p[x]==x) //判断树根while(p[x]!=x) x=p[x] //求x的集合编号 合并两个集合合并集合只需要将其中一个集合的树根的编号改成另一个集合的根。 1p[x]=y//px是x的集合编号，py是y的集合编号 (俗称：给x的祖宗又认了一个爹) 路径压缩当你找到这个节点的根节点时，就把这些节点的父亲全部变成根节点的编号，也就是让这些节点全部指向根节点。当实现了这个操作后，其查询操作直接将时间复杂度变成O(1)。 1234int find(int x)&#123; //寻找根+路径压缩 if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125; 例题1.合并集合一共有 n𝑛 个数，编号是 1∼n1∼𝑛，最开始每个数各自在一个集合中。 现在要进行 m𝑚 个操作，操作共有两种： M a b，将编号为 a𝑎 和 b𝑏 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作； Q a b，询问编号为 a𝑎 和 b𝑏 的两个数是否在同一个集合中； 输入格式第一行输入整数 n𝑛 和 m𝑚。 接下来 m𝑚 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。 输出格式对于每个询问指令 Q a b，都要输出一个结果，如果 a𝑎 和 b𝑏 在同一集合内，则输出 Yes，否则输出 No。 每个结果占一行。 数据范围1≤n,m≤1051≤𝑛,𝑚≤105 输入样例：1234564 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4 输出样例：123YesNoYes 题解12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int p[100005];int find(int x)&#123; //核心函数，find(x)最终返回值就是x的根节点编号 if(x!=p[x]) p[x]=find(p[x]); return p[x];&#125;int main()&#123; int n,m,a,b; string s; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;=n;i++)&#123; p[i]=i; &#125; while(m--)&#123; cin&gt;&gt;s&gt;&gt;a&gt;&gt;b; if(s==&quot;M&quot;)&#123; p[find(a)]=find(b);//让a根节点的父亲变成b节点的根节点 &#125; else if(s==&quot;Q&quot;)&#123; if(find(a)==find(b))&#123; //判断两个数是不是属于同一个集合，其实就是两个根编号是不是一样 cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; &#125; &#125;&#125; 2.合并根题目描述w 星球的一个种植园，被分成 m×n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。 这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。 如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？ 输入格式第一行，两个整数 m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。 接下来一行，一个整数 k，表示下面还有 k 行数据(0&lt;k&lt;1e5)。 接下来 k 行，每行两个整数 a，b，表示编号为 a 的小格子和编号为 b 的小格子合根了。 格子的编号一行一行，从上到下，从左到右编号。 比如：5×4 的小格子，编号： 123451 2 3 45 6 7 89 10 11 1213 14 15 1617 18 19 20 输出格式一行一个整数，表示答案 输入样例1234567891011121314151617185 4162 31 55 94 87 89 1010 1111 1210 1412 1614 1817 1815 1919 209 1313 17 输出样例15 题解： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int p[1000005],vis[1000005];int find(int x)&#123; //寻找根 if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int main()&#123; int n,m,k,a,b,sum=0; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;k; for(int i=1;i&lt;=n*m;i++) p[i]=i; while(k--)&#123; cin&gt;&gt;a&gt;&gt;b; p[find(a)]=find(b);//合并集合 &#125; for(int i=1;i&lt;=n*m;i++)&#123; // cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; if(i==p[i])sum++; &#125; cout&lt;&lt;sum;&#125; 这题使用并查集解题，核心主要两个步骤：寻找该元素的根、合并两个集合 然后最后判断是用if(i&#x3D;&#x3D;p[i])来判断这里的根有几个，因为我们知道只有p[x]&#x3D;&#x3D;x时，才是这个树的根(因为在数组上理解就是所有的数字比如：[-1，1，2，3，4] —&gt; [ -1，4，2，1，3]，我们可以发现数组的顺序表示数字，而对应上面的数字就是其根的索引，在并查集的操作下只有根节点是i&#x3D;&#x3D;p[i]，因此我们也可以将其作为判断几个集合的依据)。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"c++基础数据结构之栈、队列、链表","slug":"c-基础数据结构之栈、队列","date":"2024-04-18T04:50:41.000Z","updated":"2024-04-29T11:06:58.834Z","comments":true,"path":"2024/04/18/c-基础数据结构之栈、队列/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/","excerpt":"","text":"c++基础数据结构之栈、队列、链表队列1234567queue&lt;int&gt;q //queue&lt;定义类型&gt;定义名称q.pop()//出队q.push()//入队q.front()//队首q.rear()//队尾q.size()//队长(队长可以为0)q.empty()//是否为空队(若是则返回1) 栈123456stack&lt;int&gt;stst.pop()//出栈st.push()//入栈st.top()//栈顶st.size()//栈长st.empty()//判断是否为空栈 1.单链表(注意结构体写法)题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 https://www.ixigua.com/7241418740699824643 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： (1) “H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 (3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式共一行，将整个链表从头到尾输出。 数据范围1≤M≤100000所有操作保证合法。 输入样例 复制123456789101110H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例 复制16 4 6 5 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;struct node &#123; int num; //节点值 int time; //第几次插入 node* next; //定义下一个节点的位置&#125;;node* head = new node();//创建一个新节点叫headvoid headin(int n,int i)&#123; node* p=new node();//创建一个新节点 p-&gt;num=n;//把值输入节点中 p-&gt;time=i;//这是次数 //下面就是插入模板操作 p-&gt;next=head-&gt;next; head-&gt;next=p;&#125;void de(int t)&#123; node* p, * q;//定义两个节点 p=head-&gt;next;//p为指向head的下一个节点 if(!t)&#123; head-&gt;next=p-&gt;next;//head指的是头，里面没值，所以实际的链表头是p delete(p);//p是实际头节点 &#125; else&#123; while(p)&#123;//找到第t次插入的数 if(p-&gt;time==t)break; p=p-&gt;next; &#125; q=p-&gt;next;//让q在p的前面，辅助删除p后面的节点 p-&gt;next=q-&gt;next; delete(q);//删除q &#125;&#125;void insert(int t,int n,int i)&#123; node* p=head-&gt;next; //让p指针指向head的下一个，然后用p节点找欲插入的值 //下面三行是创建新节点然后给其赋值的操作 node* q=new node(); q-&gt;num=n; q-&gt;time=i; //从链表头开始找 while(p)&#123; if(p-&gt;time == t)break;//找第t次插入的数 p=p-&gt;next; &#125; //把q节点插到第t次插入的数后面 q-&gt;next=p-&gt;next; p-&gt;next=q;&#125;int main()&#123; head-&gt;next=NULL;//开始时链表没有值 int m,i,x,k; char op; i=1; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;op; if(op==&#x27;H&#x27;)&#123; cin&gt;&gt;x; headin(x,i); i++; &#125; if(op==&#x27;D&#x27;)&#123; cin&gt;&gt;k; de(k); &#125; if(op==&#x27;I&#x27;)&#123; cin&gt;&gt;k&gt;&gt;x; insert(k,x,i); i++;//因为题目是记录第几次插入的数，所以要用i计数 &#125; &#125; node* p = head-&gt;next;//让p指向实际头节点 while(p)&#123; cout&lt;&lt; p-&gt;num &lt;&lt; &#x27; &#x27;; p=p-&gt;next; &#125;&#125; 2.简单计算器题目描述读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。 https://www.ixigua.com/7213692123635024436 输入格式每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。 100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2 输出格式对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入样例 复制14 + 2 * 5 - 7 / 11 输出样例 复制113.36 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;stack&lt;double&gt;d_st;stack&lt;char&gt;op_st;int level(char a)&#123; if(a==&#x27;+&#x27;||a==&#x27;-&#x27;)return 1; if(a==&#x27;*&#x27;||a==&#x27;/&#x27;)return 2;&#125;void cal()&#123; char c=op_st.top();op_st.pop(); double a,b; a=d_st.top(); d_st.pop(); b=d_st.top(); d_st.pop(); if(c==&#x27;+&#x27;)d_st.push(b+a); if(c==&#x27;-&#x27;)d_st.push(b-a); if(c==&#x27;*&#x27;)d_st.push(b*a); if(c==&#x27;/&#x27;)d_st.push(b/a);&#125;int main()&#123; string str; double x; getline(cin,str); int len=str.size(); for(int i=0;i&lt;len;i++)&#123; if(str[i]&gt;=&#x27;0&#x27; &amp;&amp; str[i]&lt;=&#x27;9&#x27;)&#123;//如果是数字 x=str[i]-&#x27;0&#x27;; while(str[i+1]&gt;=&#x27;0&#x27; &amp;&amp; str[i+1]&lt;=&#x27;9&#x27;)&#123; x=x*10+str[i+1]-&#x27;0&#x27;; i++; &#125; d_st.push(x);//把字符串数字转化为整型并推入栈 &#125; else if(str[i]==&#x27;+&#x27; || str[i]==&#x27;-&#x27; || str[i]==&#x27;*&#x27; || str[i]==&#x27;/&#x27;)&#123; if(op_st.empty()||level(str[i])&gt;level(op_st.top()))&#123;//只有优先级高于栈顶的情况才能入栈 op_st.push(str[i]); &#125; else if(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123; while(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123;//拿栈顶前两个计算 cal(); &#125; op_st.push(str[i]); &#125; &#125; &#125; while(!op_st.empty())&#123; cal(); &#125; printf(&quot;%.2lf&quot;,d_st.top());&#125; 3.约瑟夫环(队列解法)题目描述有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。 输入格式n和m。 输入样例14 17 输出样例11 3 4 2 题解1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt;qe; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; qe.push(i); &#125; while(!qe.empty())&#123; int x; for(int i=1;i&lt;=m-1;i++)&#123; x=qe.front(); qe.pop();qe.push(x);//把队头放到对尾 &#125; x=qe.front();qe.pop();//数到的数彻底出队 cout&lt;&lt;x&lt;&lt;&quot; &quot;; &#125;&#125; 4.走出迷宫(bfs)题目描述当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。 假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。 视频讲解：https://www.ixigua.com/7166253132702450212 输入格式第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。 接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。 输出格式输出从起点到出口最少需要走的步数。 输入样例12343 3S#T.#.... 输出样例16 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char a[105][105];int vis[105][105];int n,m;struct node&#123; int r,c; int step;&#125;;int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;void bfs(int sr,int sc,int er,int ec)&#123; queue&lt;node&gt;qe;//注意定义方式 node q,t;//t用来记录q的一圈4个方向 q.r=sr,q.c=sc; q.step=0; qe.push(q); vis[q.r][q.c]=1; while(!qe.empty())&#123; q=qe.front(); qe.pop(); if(q.r==er &amp;&amp; q.c==ec)&#123; cout&lt;&lt;q.step; break; &#125; for(int i=0;i&lt;4;i++)&#123; t.r=q.r+dir[i][0]; t.c=q.c+dir[i][1]; if(a[t.r][t.c]==&#x27;.&#x27; &amp;&amp; vis[t.r][t.c]==0 &amp;&amp; t.r&gt;=1&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=1&amp;&amp;t.c&lt;=n)&#123; t.step=q.step+1; vis[t.r][t.c]=1; qe.push(t); &#125; &#125; &#125;&#125;int main()&#123; int sr,sc,er,ec; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]==&#x27;S&#x27;)sr=i,sc=j; if(a[i][j]==&#x27;T&#x27;)er=i,ec=j,a[i][j]=&#x27;.&#x27;; &#125; bfs(sr,sc,er,ec);&#125; 5.出入栈判断题目描述现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。 输入格式输入第一行表示一个整数n, n&lt;&#x3D;100 接下来输入n行，每行表示一个a~z的排列。 输出格式每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。 输入样例 复制1232abcdefghijklmnopqrstuvwxyzzabcdefghijklmnopqrstuvwxy 输出样例 复制12yesno 数据范围与提示5abcdegfhijklnmopqrstuvwxyzabcdegfhijklnmopqrstzyxwvudcbaegfhijklnmopqrstuvwxyzabcdegfhijkwxyzlnmopqrstuvabcdegfhijklnmouvwxyztsrqp yesyesyesnoyes 题解12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; stack &lt;char&gt; st; int n; cin&gt;&gt;n; while(n--)&#123; string s; cin&gt;&gt;s; int len=s.size(),j=0; for(int i=0;i&lt;len;i++)&#123; char ch=i+&#x27;a&#x27;; st.push(ch); while(!st.empty() &amp;&amp; st.top()==s[j])&#123; st.pop(),j++; &#125; &#125; if(j==len)cout&lt;&lt;&quot;yes\\n&quot;; else cout&lt;&lt;&quot;no\\n&quot;; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript基本语法","slug":"JavaScript基本语法","date":"2024-04-18T04:48:23.000Z","updated":"2024-04-29T11:07:33.889Z","comments":true,"path":"2024/04/18/JavaScript基本语法/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"JavaScript基础语法介绍JavaScript介绍1.1 JavaScript是什么是一个运行在浏览器上的编程语言。 1.2JavaScript书写位置内部式： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 外部式： 1234&lt;body&gt; &lt;script src=&quot;./my.js&quot;&gt; &lt;/script&gt;&lt;/body&gt; 使用外部时，script标签里面不要写内容，否则会被忽略。 1.3JavaScript输入输出语法输出语法1： 123456&lt;body&gt; &lt;script&gt; document.write(&#x27;hey&#x27;) document.write(&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;) &lt;/script&gt;&lt;/body&gt; 输出语法2： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 输出语法3： 12345&lt;body&gt; &lt;script&gt; console.log(&#x27;haha&#x27;)//控制台输出语法，程序员调试使用 &lt;/script&gt;&lt;/body&gt; 输入语法1： 1prompt(&#x27;请输入&#x27;)//弹出一个对话框 prompt输入类型为字符串。 1.4 字面量比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量 变量2.1 变量是什么白话：用来装数据的盒子。可以用来存放数据。 2.2 变量的基本使用(与c语言定义类似) 1.声明变量1let variable //var存在与老版的JavaScript中 age为变量。 2.变量赋值1variable = 18 variable为变量，18为字面量。 变量不允许多次定义。 小小的变量使用一下： 123456&lt;body&gt; &lt;script&gt; let n=prompt(&#x27;请输入&#x27;) document.write(n) &lt;/script&gt;&lt;/body&gt; 2.3 变量命名规则与规范1. 规则①不能用关键字。 ②只能用下划线、字母、数字、＄组成，且不能用数字开头。 ③字母严格区分大小写。 2.规范①起名要有意义。 ②遵守小驼峰命名法。 数组1.1 声明数组1let arr = [1，2，3] 1.2 数组的基本使用12console.log(arr[0]) //索引console.log(arr.length) //获取长度 常量1.1 基本使用1const G = 9.8 常量不允许重新赋值，声明的时候必须赋值。 数据类型js为弱数据类型语言，只有赋值了才知道是什么数据类型。 基本数据类型number 数字型 string 字符串型 boolean 布尔型 undefined 未定义型 null 空类型 引用数据类型object 对象 1.数字类型数字类型可以由+ - * &#x2F; %各个符号进行运算。 NaN (not a number)：表示计算错误。 NaN是粘性的，任何对NaN的操作都会返回NaN。 2.字符串通过单引号、双引号或反引号包裹的数据都叫字符串。 字符串拼接：1234console.log(&#x27;12&#x27;+&#x27;34&#x27;) //字符串可以用加号拼接let a=&#x27;k&#x27;let b=&#x27;q&#x27;console.log(k+q) 模板字符串：1document.write(`大家好，我叫$&#123;name&#125;,今年$&#123;age&#125;岁`) //用反引号,变量用＄&#123;&#125;包裹 3.布尔型 (bollean)12let n=trueconsole.log(n) 4.未定义类型 (undefined)12let numconsole.log(num) //输出undefined 5.空类型 (null)12let obj=null //表示赋值了一个空的内容console.log(obj) 如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null 6.检测数据类型12typeof num //num为变量typeof(num) 7.类型转换隐式转换+号两边只要有一个是字符串，都会把另外一个转成字符串。 除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。 1234console.log(&#x27;数字&#x27; + 1) //返回&#x27;数字1&#x27;console.log(&#x27;1&#x27; + 1) //返回&#x27;11&#x27;console.log(&#x27;1&#x27; - 1) //返回0console.log(+&#x27;123&#x27;) //返回123 显示转换通过函数来进行数据转换： 12Number(str) //转换为数字类型let num = +prompt(&#x27;输入&#x27;) //输入的可以转换为数字类型 parse系列： 1234parseInt(num) //只保留数字且只保留整数parseFloat(num) //保留数字并保留小数parseInt(12px) //12 parseFloat(12.86px) //12.86 运算一元运算符前置自增12let i=1console.log(++i + 2) //2+2=4 先自加再使用。 后置自增12let i=1console.log(i++ + 2) //1+2=3 此时i已经为2，但是没有参与运算 先使用再自加。 12let i=1console.log(i++ + ++i + i) //1+3+3=7 第二个i时i为2 比较运算符1234567&gt;&lt;&gt;=&lt;=== //左右两边值是否相等=== //左右两边是否类型和值都相等!== //左右两边是否不全等 NaN不等于任何人，包括它自己。 1console.log(NaN === NaN) //false if语句123if (条件) &#123; 满足条件执行的代码&#125; 条件中只有数字0或者空字符会触发false，其余都是true。 三元运算符可以代替if双分支。 1条件 ? 满足条件执行的代码 : 不满足条件执行的代码 例子： 123456if(3&lt;5)&#123; alert(&#x27;真的&#x27;)&#125;else&#123; alert(&#x27;假的&#x27;)&#125; 和 13&lt;5 ? alert(&#x27;真的&#x27;) : alert(&#x27;假的&#x27;) 等价。 还可以作赋值操作： 1let sum = 3 &lt; 5 ? 3 : 5 //sum=3 数字补0例子123let num = prompt(&#x27;请您输入一个数字&#x27;) //类型为stringnum = num &lt; 10 ? 0 + num : num //判断小于10才补0alert(num) 输入9，输出09 输入11，输出11 数组查询12let arr=[1,2,3]console.log(arr[0]) 修改123let arr=[1,2,3]arr[0]=3console.log(arr[0]) //[3,2,3] 增加push() 添加数组末尾 unshift() 添加数组开头 1234let arr=[1,2,3]arr.push(4) //[1,2,3,4]arr.push(4,5) //[1,2,3,4,5]arr.unshift(0) //[0,1,2,3] 删除pop() 弹出最后一个元素 shift() 弹出第一个元素 splice() 切片删除 &#x2F;&#x2F;arr.plice(起始位置，删除几个) 12345678let arr=[1,2,3]arr.pop() //[1,2]console.log(arr.pop()) //3arr.shift() //[2,3]console.log(arr.shift) //1arr.splice(1,1) //[1,3]arr.splice(1) //[1] 删除索引1后面的所有arr.splice(1,2) //[1] 函数123function 函数名() &#123; 函数体&#125; 调用: 1函数名() 例如： 12345function sayhi&#123; console.log(&#x27;hi&#x27;)&#125;sayhi() 异常处理语句throw语句1throw expression; 使用这个语句后就会弹出error： 12345678for(let i=1;i&lt;=5;i++)&#123; if(i!=4)&#123; console.log(&quot;yes&quot;); &#125; else&#123; throw &quot;not 4&quot;; //Uncaught not 4 &#125;&#125; try…catch语句123456try&#123; ...&#125; catch (error)&#123; console.error(error)&#125; catch块可以用来处理所有try块总产生的异常。 finally块12345678openMyFile();try &#123; writeMyFile(theData); //This may throw a error&#125; catch (e) &#123; handleError(e); // If we got a error we handle it&#125; finally &#123; closeMyFile(); // always close the resource&#125; finally块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。 循环与迭代 for 语句 do…while 语句 while 语句 label 语句 break 语句 continue 语句 for…in 语句 for…of 语句 其循环方式与c语言相似，不再一一赘述。 对象一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法。 对象及其属性： 1234var myCar = new Object();myCar.make = &quot;Ford&quot;;myCar.model = &quot;Mustang&quot;;myCar.year = 1969; 可以按如下方法访问对象： 123myCar[&quot;make&quot;] = &quot;Ford&quot;;myCar[&quot;model&quot;] = &quot;Mustang&quot;;myCar[&quot;year&quot;] = 1969; 创建新对象使用对象初始化器创建1234567var obj = &#123; property_1: value_1, // property_# 可以是一个标识符... 2: value_2, // 或一个数字... [&quot;property&quot; + 3]: value_3, // 或一个可计算的 key 名... // ..., &quot;property n&quot;: value_n,&#125;; // 或一个字符串 使用构造函数创建用构造函数创建分两种： 通过创建一个构造函数来定义对象的类型。(建议首字母大写) 通过 new 创建对象实例。 这里首先定义一个对象类型，并且赋予其make,model,year属性。 12345function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125; 注意这里是通过this来给对象类型属性值赋值 然后你就可以创建一个新对象啦 1var mycar = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993); 或者你也可以让类中加入一个owner： 123456function Car(make, model, year, owner) &#123; this.make = make; this.model = model; this.year = year; this.owner = owner;&#125; 那么你就可以这样创建： 12var car1 = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993, rand);var car2 = new Car(&quot;Nissan&quot;, &quot;300ZX&quot;, 1992, ken); 就可以这样索引读取： 1car2.owner.name; 你也可以为之前定义的对象增加新的属性： 1car1.color = &quot;black&quot;; 注意这里只是这个car1增加了新属性，不影响其他car1,car3 使用Object.create方法创建及使用Object.create()函数创建 123456789101112131415var Animal = &#123; type: &quot;Invertebrates&quot;, // 属性默认值(无脊椎动物) displayType: function () &#123; //类里面可以包含函数 console.log(this.type); //该函数用来显示type的值 &#125;,&#125;;// 创建一种新的动物——animal1var animal1 = Object.create(Animal);animal1.displayType(); // 输出:Invertebrates(因为没有没有给type赋值)// 创建一种新的动物——Fishesvar fish = Object.create(Animal);fish.type = &quot;Fishes&quot;;fish.displayType(); // 输出:Fishes","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"如何优雅的将秒换算成-时:分:秒？","slug":"秒转换时间","date":"2024-04-18T01:29:59.000Z","updated":"2024-04-29T11:06:44.553Z","comments":true,"path":"2024/04/18/秒转换时间/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/","excerpt":"","text":"如何优雅的将秒换算成-时:分:秒？思路先看一下题目，发现就是一道模拟题，但是又一些细节的。 首先是数据的规模：时间不超过 10^18,所以需要开 long long。 然后首先要忽略掉毫秒。 这里普及一个知识:1s &#x3D; 1000ms 所以需要忽略后面的三位。直接整除 1000 就可以了。 之后就是处理时分秒了： 1.小时由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用24*60*60来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数60*60（也就是3600），就是小时值了。 2.分钟分钟要先对每小时的秒数60*60取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。 3.秒直接对60取余，剩下的就是秒了。 时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。 当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。 要用到两个函数： 一个是setw()函数，这个函数可以限定域宽，宽度就是括号里的数字。 另外一个setfill()函数，这个函数可以设置当实际的宽度不足setw()函数的值时，用某个字符来补足。（setfill()函数最好放在setw()函数前面） 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,h,m,s; cin&gt;&gt;n; n=n/1000; h=n%(24*3600)/3600; m=n%3600/60; s=n%60; cout&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;s;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"css背景","slug":"css-bgc","date":"2024-01-20T04:25:09.000Z","updated":"2024-04-29T11:07:56.347Z","comments":true,"path":"2024/01/20/css-bgc/","link":"","permalink":"https://bayeeaa.github.io/2024/01/20/css-bgc/","excerpt":"","text":"CSS背景背景颜色background-color(bgc) 123div &#123; background-color: pink;&#125; 颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制… 背景图片background-image(bgi) 123div &#123; background-image: url(&#x27;图片的路径&#x27;);&#125; ①背景图片中url可以省略引号。 ②背景图片默认是在水平和垂直方向平铺的。 ③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。 背景平铺background-repeat(bgr) 123div&#123; background-repeat:no-repeat;&#125; repeat (默认值)水平和垂直方向都平铺 no-repeat 不平铺 repeat-x 沿着水平方向(x轴)平铺 repeat-y 沿着垂直方向(y轴)平铺 背景位置background-position(bgp) 123div&#123; background-position:&#125; 方位名词水平方向left、center、right 垂直方向top、center、bottom 123div&#123; background-position: right bottom; //水平位置 垂直位置&#125; 数字+px坐标轴①原点(0,0) 盒子左上角 ②x轴 水平向右 ③y轴 垂直向下 操作将图片左上角与坐标点重合即可 123div&#123; background-position: 50px 100px; //水平位置 垂直位置&#125; 背景相关属性连写background: color image repeat position 可以不按顺序写。 123div&#123; background: pink url(./images/1.jpg) no-repeat bottom center ;&#125; 与img的区别①img标签是一个标签，不设置宽高默认会以原尺寸显示。 ②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"}]},{"title":"递归——深度优先搜索(dfs)","slug":"递归——深度优先搜索(dfs)","date":"2023-11-06T14:26:27.000Z","updated":"2024-04-29T11:06:51.155Z","comments":true,"path":"2023/11/06/递归——深度优先搜索(dfs)/","link":"","permalink":"https://bayeeaa.github.io/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/","excerpt":"","text":"递归——深度优先搜索(dfs)区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索： 递归方法类似于栈，将数据一直递取到底后自下往上出栈。 大致框架如下： 1234567891011121314viod dfs(int k)&#123; if(输出条件)&#123; cout&lt;&lt; &#125; else&#123; for(int i=0;i&lt;n;i++)&#123; if(vis[i]==0)&#123; a[k]=数字,vis[i]=1//标记使用; dfs(k+1);//向下递取 vis[i]=0;//将其拿出，返回原先状态 &#125; &#125; &#125;&#125; 下列题目方式解决一些排列组合问题。 组合输出 –5个数字组合输入3个盒子 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,r;int a[200],vis[200];//a用来记录牌子，vis用来记录牌子的使用情况int is_rise(int b[])&#123;//判断是否是递增数组 int flag=1; for(int i=1;i&lt;r;i++)&#123; if(a[i]&gt;a[i+1])&#123; flag=0; &#125; &#125; return flag;&#125;void dfs(int k)&#123;//k为盒子的编号，或可以理解为步数 if(k==r+1&amp;&amp;is_rise(a))&#123; for(int i=1;i&lt;=r;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; return; &#125; for(int i=1;i&lt;=n;i++)&#123;//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。 if(vis[i]==0)&#123; a[k]=i,vis[i]=1; dfs(k+1); vis[i]=0;//将牌子拿出来，此时就要把vis归回0 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;r; dfs(1);&#125; 这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。 素数环 eg：输入8 输出4 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[25],vis[25];int n,cnt;int isPrime(int x)&#123; if(x&lt;2)return 0; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)return 0; &#125; return 1;&#125;void dfs(int k)&#123; if(k==n+1 &amp;&amp; isPrime(a[1]+a[n]))&#123;//是否超出边界&amp;&amp;是否头尾相加是素数 cnt++; return; &#125; for(int i=2;i&lt;=n;i++)&#123; if(vis[i]==0 &amp;&amp; isPrime(i+a[k-1]))&#123;//vis用来看有没有用过这个数字 a[k]=i,vis[i]=1;//a用来保存数字 dfs(k+1); vis[i]=0;//当前的这个数字清除，再向下dfs &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; a[1]=1,vis[1]=1; dfs(2); cout&lt;&lt;cnt; &#125; 全排列问题 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[25],b[25]; //a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里void dfs(int k)&#123; //depth first search if(k==n+1)&#123; //k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了 for(int i=1;i&lt;=n;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for(int i=1;i&lt;=n;i++)&#123;//i是指拿在你手上的牌的数字，没用0为了更好理解 if(b[i]==0)&#123;//看看这个牌用过没有，b数组用来看这个牌用过没有用的 a[k]=i,b[i]=1;//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了 dfs(k+1);//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里 b[i]=0;//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推 &#125;&#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(1);&#125; 体积 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt;int a[25],vis[1005];void dfs(int k,int sum)&#123; if(k==n+1)&#123;// cout&lt;&lt;sum&lt;&lt;&quot; &quot;; vis[sum]=1; return; &#125; dfs(k+1,sum+a[k]); dfs(k+1,sum);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; dfs(1,0); for(int i=1;i&lt;=1000;i++)&#123; if(vis[i])cnt++; &#125; cout&lt;&lt;cnt; return 0;&#125; 若把上面代码的注释删除则可以得到： 12331 3 48 4 5 1 7 3 4 0 6 由此可知上面深度搜索遍历的顺序是： 123456781+3+41+31+413+4340 以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。 相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"爬取pixiv日前十图片并下载至本地","slug":"pixiv-crawler","date":"2023-09-11T04:21:25.000Z","updated":"2024-04-29T11:07:14.360Z","comments":true,"path":"2023/09/11/pixiv-crawler/","link":"","permalink":"https://bayeeaa.github.io/2023/09/11/pixiv-crawler/","excerpt":"","text":"爬取pixivic日前十图片实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期： 1.发送请求首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址： 于是我们就可以向这个api发送请求： 1234import requestsurl = &quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;reponse = requests.get(url)print(reponse) #返回&lt;Response [200]&gt; 因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。 2.解析数据返回数据长这个样子： json使用这就是标准的json形式文件，但还不是一个字典(其实很像)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。 我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可： 123response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;]#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png#就是日排行第一的图 但是当你将网站复制进浏览器时你会发现打不开。 url拼接也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接 图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。 3.下载图片至本地目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了： 12345img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot;img = requests.get(img_url)with open(&quot;./top1.jpg&quot;,&quot;wb&quot;) as f: #&quot;wb&quot;是以二进制写入 f.write(img.content) #content是指获取二进制内容 此时你已经可以看到top1的图片下载当前文件夹了。 同理，下载前十的图片只需要加入for循环就可以了，以下省略。 4.下载至指定文件夹这里就需要导入os包： 1234import ospath = &#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27; #这是我的绝对地址if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹，文件夹名字为2023-9-7 path书写这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法： 第二条中的r是用来申明不是转义字符。 这样就可以创建一个文件夹了~ 然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。 5.关于api中日期的变化因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期： 123import datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3) 然后只需要再拼接如url中就可以啦~ 完整代码123456789101112131415161718192021import requestsimport osimport datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3)url = &quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;+str(api_day)+&quot;&amp;mode=day&amp;pageSize=302&quot;response = requests.get(url)date = url[40:50]path = &#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;+date #linux写法if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹for i in range(10): img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][i][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot; img = requests.get(img_url) with open(path+&quot;/top&quot;+str(i+1)+&quot;.jpg&quot;,&quot;wb&quot;) as f: f.write(img.content) print(&quot;正在保存top&quot;+str(i+1)+&quot;中...&quot;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫 --- 以爬取笔趣阁小说为例","slug":"biquge","date":"2023-08-31T07:40:23.000Z","updated":"2024-04-29T11:07:47.514Z","comments":true,"path":"2023/08/31/biquge/","link":"","permalink":"https://bayeeaa.github.io/2023/08/31/biquge/","excerpt":"","text":"爬虫 — 以爬取笔趣阁小说为例1.发送请求123456import requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers) 这是requests请求，若返回response值为200，则表示请求成功 2.获取数据1response = requests.get(url,headers).text 可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析 3.解析数据有以下几种途径：css、xpath、re正则表达 等等 让我们来看看分别用这三种方法怎么去解析到一个章节的标题 css123import parselselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() 这种方法通过css选择器进行选择 xpath123import parselselector = parsel.Selector(response)novel_title = selector.xpath(&quot;//*[@class=&quot;bookname&quot;]/h1/text()&quot;).get() 注意text后面的() re12import renovel_title = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0] 这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串 *注意：以上方法各有利弊，选择合适的方式来解析数据 4.保存数据12with open(&quot;file_name&quot;+&quot;.txt&quot;,mode=&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: #w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入f.write(novel_context) #写入文件 with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径 以上思路已经理清楚了，下面开始实践：爬取一章12345678910111213import parselimport requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers).textselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() #css方法解析数据novel_context_list = selector.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) 注意：join函数的使用： 123456a=[&quot;1&quot;,&quot;2&quot;,&quot;8&quot;,&quot;9&quot;]print(&quot; &quot;.join(a)) #输出1 2 8 9print(&quot;\\n&quot;.join(a)) #输出1(换行)2(换行)8(换行)9b=&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;print(&quot; &quot;.join(a)) #输出a b （注意seq不能是int整形） 爬取各章url12345678910111213import requestsimport reurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] print(novel_url) print(novel_title) 在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的： 我们就可以用re来解析到各个章节的url和title 完整代码123456789101112131415161718192021222324import requestsimport reimport parselurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] novel_response = requests.get(novel_url, headers).text selectors = parsel.Selector(novel_response) novel_context_list = selectors.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) print(&quot;正在保存&quot;+novel_title) novel_title = &quot;*&quot; + novel_title with open(novel_name+&quot;.txt&quot;,mode=&quot;a&quot;) as f: f.write(novel_title) f.write(&quot;\\n&quot;) f.write(novel_context) f.write(&quot;\\n&quot;) f.write(&quot;\\n&quot;) 运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"CSS选择器","slug":"css选择器","date":"2023-08-23T04:35:42.000Z","updated":"2024-04-29T11:08:02.355Z","comments":true,"path":"2023/08/23/css选择器/","link":"","permalink":"https://bayeeaa.github.io/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"引入方式引入方式有以下三种： 1.内嵌式 12345678910111213&lt;!-- 内嵌式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; colour&#123; colour:pink; &#125; &lt;/style&gt;&lt;/head&gt; 2.外联式 12345678910&lt;!-- 外联式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./111.css&quot;&gt; &lt;!-- 111为引入文件名 --&gt;&lt;/head&gt; 3.行内式 1234567&lt;!-- 行内式 --&gt;&lt;body&gt; &lt;div class=&quot;colour&quot;&gt; abcd &lt;/div&gt; &lt;div style=&quot;color: aqua;font-size: large;&quot;&gt;abab&lt;/div&gt;&lt;/body&gt; 选择器一共有4种：标签选择器、类选择器、id选择器、通符选择器 注：一下选择器均是在style标签下的 1.标签123div&#123; color:blue;&#125; 所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div) 2.类选择器123.color-choose&#123; color:blue;&#125; 其html调用方式为： 1&lt;div class=&quot;color-choose&quot;&gt; abab &lt;/div&gt; 3.id选择器123#color&#123; color:blue;&#125; 其html调用方式为： 1&lt;div id=&quot;color&quot;&gt; abab &lt;/div&gt; 注意：id只得调用一次 4.通符选择器12345*&#123; margin:0; padding:0;&#125;&lt;!-- 清除内外边距 --&gt; 对全局内容生效 选择器的选择1.后代 （后面所有代）问题如下 1234&lt;p&gt; abab &lt;/p&gt;&lt;div&gt; &lt;p&gt; 哈哈哈 &lt;/p&gt;&lt;/div&gt; 欲选择div中的p标签，而不是外部的p 以如下方法实现： 12345&lt;style&gt; div p &#123; color:blue; &#125;&lt;/style&gt; 2.子代 （后面一代）问题是要选中div后面的一代 123456&lt;div&gt; &lt;p&gt; dd &lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot;&gt; ddd &lt;/a&gt; &lt;/p&gt;&lt;/div&gt; 以如下方法实现： 123div&gt;p&#123; color:blue;&#125; 3.并集问题：想要让以下这些标签被选到 1234&lt;p&gt; p &lt;/p&gt;&lt;div&gt; div &lt;/div&gt;&lt;span&gt; span &lt;/span&gt;&lt;h1&gt; haha &lt;/h1&gt; 以下面方法实现： 123p,div,span,h1&#123; color:blue;&#125; 4.交集问题：只想要选中下面p中带class&#x3D;”c”的 1234&lt;div class=&quot;c&quot;&gt;abcd&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;a&lt;/p&gt;&lt;div class=&quot;c&quot;&gt;d&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;b&lt;/p&gt; 以下面方法实现： 123p.c&#123; color:blue;&#125; p是标签，c是类名（前面带个.的） 5.伪类问题：想要让鼠标悬停在如下超链接上能够变色 1&lt;a href=&quot;~~~&quot;&gt;传送&lt;/a&gt; 一下方法实现： 1234a:hover&#123; color:red; background-color:yellow;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"}]},{"title":"破壳啦","slug":"page1","date":"2023-08-21T11:25:42.000Z","updated":"2024-04-29T11:07:26.258Z","comments":true,"path":"2023/08/21/page1/","link":"","permalink":"https://bayeeaa.github.io/2023/08/21/page1/","excerpt":"","text":"终于创建好一个博客啦！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://bayeeaa.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"},{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"生活","slug":"生活","permalink":"https://bayeeaa.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}