{"meta":{"title":"ye's blog","subtitle":"","description":"","author":"Ye","url":"https://Bayeeaa.github.io","root":"/"},"pages":[{"title":"about","date":"2023-08-22T07:06:19.000Z","updated":"2023-08-22T07:07:20.142Z","comments":false,"path":"about/index.html","permalink":"https://bayeeaa.github.io/about/index.html","excerpt":"","text":"hello!"}],"posts":[{"title":"c++基础数据结构之栈、队列、链表","slug":"c-基础数据结构之栈、队列","date":"2024-04-18T04:50:41.000Z","updated":"2024-04-18T04:56:05.461Z","comments":true,"path":"2024/04/18/c-基础数据结构之栈、队列/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/","excerpt":"","text":"c++基础数据结构之栈、队列、链表1.单链表(注意结构体写法)题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 https://www.ixigua.com/7241418740699824643 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： (1) “H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 (3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式共一行，将整个链表从头到尾输出。 数据范围1≤M≤100000所有操作保证合法。 输入样例 复制123456789101110H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例 复制16 4 6 5 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;struct node &#123; int num; //节点值 int time; //第几次插入 node* next; //定义下一个节点的位置&#125;;node* head = new node();//创建一个新节点叫headvoid headin(int n,int i)&#123; node* p=new node();//创建一个新节点 p-&gt;num=n;//把值输入节点中 p-&gt;time=i;//这是次数 //下面就是插入模板操作 p-&gt;next=head-&gt;next; head-&gt;next=p;&#125;void de(int t)&#123; node* p, * q;//定义两个节点 p=head-&gt;next;//p为指向head的下一个节点 if(!t)&#123; head-&gt;next=p-&gt;next;//head指的是头，里面没值，所以实际的链表头是p delete(p);//p是实际头节点 &#125; else&#123; while(p)&#123;//找到第t次插入的数 if(p-&gt;time==t)break; p=p-&gt;next; &#125; q=p-&gt;next;//让q在p的前面，辅助删除p后面的节点 p-&gt;next=q-&gt;next; delete(q);//删除q &#125;&#125;void insert(int t,int n,int i)&#123; node* p=head-&gt;next; //让p指针指向head的下一个，然后用p节点找欲插入的值 //下面三行是创建新节点然后给其赋值的操作 node* q=new node(); q-&gt;num=n; q-&gt;time=i; //从链表头开始找 while(p)&#123; if(p-&gt;time == t)break;//找第t次插入的数 p=p-&gt;next; &#125; //把q节点插到第t次插入的数后面 q-&gt;next=p-&gt;next; p-&gt;next=q;&#125;int main()&#123; head-&gt;next=NULL;//开始时链表没有值 int m,i,x,k; char op; i=1; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;op; if(op==&#x27;H&#x27;)&#123; cin&gt;&gt;x; headin(x,i); i++; &#125; if(op==&#x27;D&#x27;)&#123; cin&gt;&gt;k; de(k); &#125; if(op==&#x27;I&#x27;)&#123; cin&gt;&gt;k&gt;&gt;x; insert(k,x,i); i++;//因为题目是记录第几次插入的数，所以要用i计数 &#125; &#125; node* p = head-&gt;next;//让p指向实际头节点 while(p)&#123; cout&lt;&lt; p-&gt;num &lt;&lt; &#x27; &#x27;; p=p-&gt;next; &#125;&#125; 2.简单计算器题目描述读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。 https://www.ixigua.com/7213692123635024436 输入格式每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。 100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2 输出格式对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入样例 复制14 + 2 * 5 - 7 / 11 输出样例 复制113.36 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;stack&lt;double&gt;d_st;stack&lt;char&gt;op_st;int level(char a)&#123; if(a==&#x27;+&#x27;||a==&#x27;-&#x27;)return 1; if(a==&#x27;*&#x27;||a==&#x27;/&#x27;)return 2;&#125;void cal()&#123; char c=op_st.top();op_st.pop(); double a,b; a=d_st.top(); d_st.pop(); b=d_st.top(); d_st.pop(); if(c==&#x27;+&#x27;)d_st.push(b+a); if(c==&#x27;-&#x27;)d_st.push(b-a); if(c==&#x27;*&#x27;)d_st.push(b*a); if(c==&#x27;/&#x27;)d_st.push(b/a);&#125;int main()&#123; string str; double x; getline(cin,str); int len=str.size(); for(int i=0;i&lt;len;i++)&#123; if(str[i]&gt;=&#x27;0&#x27; &amp;&amp; str[i]&lt;=&#x27;9&#x27;)&#123;//如果是数字 x=str[i]-&#x27;0&#x27;; while(str[i+1]&gt;=&#x27;0&#x27; &amp;&amp; str[i+1]&lt;=&#x27;9&#x27;)&#123; x=x*10+str[i+1]-&#x27;0&#x27;; i++; &#125; d_st.push(x);//把字符串数字转化为整型并推入栈 &#125; else if(str[i]==&#x27;+&#x27; || str[i]==&#x27;-&#x27; || str[i]==&#x27;*&#x27; || str[i]==&#x27;/&#x27;)&#123; if(op_st.empty()||level(str[i])&gt;level(op_st.top()))&#123;//只有优先级高于栈顶的情况才能入栈 op_st.push(str[i]); &#125; else if(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123; while(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123;//拿栈顶前两个计算 cal(); &#125; op_st.push(str[i]); &#125; &#125; &#125; while(!op_st.empty())&#123; cal(); &#125; printf(&quot;%.2lf&quot;,d_st.top());&#125; 3.约瑟夫环(队列解法)题目描述有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。 输入格式n和m。 输入样例14 17 输出样例11 3 4 2 题解1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt;qe; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; qe.push(i); &#125; while(!qe.empty())&#123; int x; for(int i=1;i&lt;=m-1;i++)&#123; x=qe.front(); qe.pop();qe.push(x);//把队头放到对尾 &#125; x=qe.front();qe.pop();//数到的数彻底出队 cout&lt;&lt;x&lt;&lt;&quot; &quot;; &#125;&#125; 4.走出迷宫(bfs)题目描述当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。 假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。 视频讲解：https://www.ixigua.com/7166253132702450212 输入格式第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。 接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。 输出格式输出从起点到出口最少需要走的步数。 输入样例12343 3S#T.#.... 输出样例16 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char a[105][105];int vis[105][105];int n,m;struct node&#123; int r,c; int step;&#125;;int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;void bfs(int sr,int sc,int er,int ec)&#123; queue&lt;node&gt;qe;//注意定义方式 node q,t;//t用来记录q的一圈4个方向 q.r=sr,q.c=sc; q.step=0; qe.push(q); vis[q.r][q.c]=1; while(!qe.empty())&#123; q=qe.front(); qe.pop(); if(q.r==er &amp;&amp; q.c==ec)&#123; cout&lt;&lt;q.step; break; &#125; for(int i=0;i&lt;4;i++)&#123; t.r=q.r+dir[i][0]; t.c=q.c+dir[i][1]; if(a[t.r][t.c]==&#x27;.&#x27; &amp;&amp; vis[t.r][t.c]==0 &amp;&amp; t.r&gt;=1&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=1&amp;&amp;t.c&lt;=n)&#123; t.step=q.step+1; vis[t.r][t.c]=1; qe.push(t); &#125; &#125; &#125;&#125;int main()&#123; int sr,sc,er,ec; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]==&#x27;S&#x27;)sr=i,sc=j; if(a[i][j]==&#x27;T&#x27;)er=i,ec=j,a[i][j]=&#x27;.&#x27;; &#125; bfs(sr,sc,er,ec);&#125; 5.出入栈判断题目描述现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。 输入格式输入第一行表示一个整数n, n&lt;&#x3D;100 接下来输入n行，每行表示一个a~z的排列。 输出格式每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。 输入样例 复制1232abcdefghijklmnopqrstuvwxyzzabcdefghijklmnopqrstuvwxy 输出样例 复制12yesno 数据范围与提示5abcdegfhijklnmopqrstuvwxyzabcdegfhijklnmopqrstzyxwvudcbaegfhijklnmopqrstuvwxyzabcdegfhijkwxyzlnmopqrstuvabcdegfhijklnmouvwxyztsrqp yesyesyesnoyes 题解12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; stack &lt;char&gt; st; int n; cin&gt;&gt;n; while(n--)&#123; string s; cin&gt;&gt;s; int len=s.size(),j=0; for(int i=0;i&lt;len;i++)&#123; char ch=i+&#x27;a&#x27;; st.push(ch); while(!st.empty() &amp;&amp; st.top()==s[j])&#123; st.pop(),j++; &#125; &#125; if(j==len)cout&lt;&lt;&quot;yes\\n&quot;; else cout&lt;&lt;&quot;no\\n&quot;; &#125;&#125;","categories":[],"tags":[]},{"title":"JavaScript基本语法","slug":"JavaScript基本语法","date":"2024-04-18T04:48:23.000Z","updated":"2024-04-18T04:58:24.586Z","comments":true,"path":"2024/04/18/JavaScript基本语法/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"JavaScript基础语法介绍JavaScript介绍1.1 JavaScript是什么是一个运行在浏览器上的编程语言。 1.2JavaScript书写位置内部式： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 外部式： 1234&lt;body&gt; &lt;script src=&quot;./my.js&quot;&gt; &lt;/script&gt;&lt;/body&gt; 使用外部时，script标签里面不要写内容，否则会被忽略。 1.3JavaScript输入输出语法输出语法1： 123456&lt;body&gt; &lt;script&gt; document.write(&#x27;hey&#x27;) document.write(&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;) &lt;/script&gt;&lt;/body&gt; 输出语法2： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 输出语法3： 12345&lt;body&gt; &lt;script&gt; console.log(&#x27;haha&#x27;)//控制台输出语法，程序员调试使用 &lt;/script&gt;&lt;/body&gt; 输入语法1： 1prompt(&#x27;请输入&#x27;)//弹出一个对话框 prompt输入类型为字符串。 1.4 字面量比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量 变量2.1 变量是什么白话：用来装数据的盒子。可以用来存放数据。 2.2 变量的基本使用(与c语言定义类似) 1.声明变量1let variable //var存在与老版的JavaScript中 age为变量。 2.变量赋值1variable = 18 variable为变量，18为字面量。 变量不允许多次定义。 小小的变量使用一下： 123456&lt;body&gt; &lt;script&gt; let n=prompt(&#x27;请输入&#x27;) document.write(n) &lt;/script&gt;&lt;/body&gt; 2.3 变量命名规则与规范1. 规则①不能用关键字。 ②只能用下划线、字母、数字、＄组成，且不能用数字开头。 ③字母严格区分大小写。 2.规范①起名要有意义。 ②遵守小驼峰命名法。 数组1.1 声明数组1let arr = [1，2，3] 1.2 数组的基本使用12console.log(arr[0]) //索引console.log(arr.length) //获取长度 常量1.1 基本使用1const G = 9.8 常量不允许重新赋值，声明的时候必须赋值。 数据类型js为弱数据类型语言，只有赋值了才知道是什么数据类型。 基本数据类型number 数字型 string 字符串型 boolean 布尔型 undefined 未定义型 null 空类型 引用数据类型object 对象 1.数字类型数字类型可以由+ - * &#x2F; %各个符号进行运算。 NaN (not a number)：表示计算错误。 NaN是粘性的，任何对NaN的操作都会返回NaN。 2.字符串通过单引号、双引号或反引号包裹的数据都叫字符串。 字符串拼接：1234console.log(&#x27;12&#x27;+&#x27;34&#x27;) //字符串可以用加号拼接let a=&#x27;k&#x27;let b=&#x27;q&#x27;console.log(k+q) 模板字符串：1document.write(`大家好，我叫$&#123;name&#125;,今年$&#123;age&#125;岁`) //用反引号,变量用＄&#123;&#125;包裹 3.布尔型 (bollean)12let n=trueconsole.log(n) 4.未定义类型 (undefined)12let numconsole.log(num) //输出undefined 5.空类型 (null)12let obj=null //表示赋值了一个空的内容console.log(obj) 如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null 6.检测数据类型12typeof num //num为变量typeof(num) 7.类型转换隐式转换+号两边只要有一个是字符串，都会把另外一个转成字符串。 除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。 1234console.log(&#x27;数字&#x27; + 1) //返回&#x27;数字1&#x27;console.log(&#x27;1&#x27; + 1) //返回&#x27;11&#x27;console.log(&#x27;1&#x27; - 1) //返回0console.log(+&#x27;123&#x27;) //返回123 显示转换通过函数来进行数据转换： 12Number(str) //转换为数字类型let num = +prompt(&#x27;输入&#x27;) //输入的可以转换为数字类型 parse系列： 1234parseInt(num) //只保留数字且只保留整数parseFloat(num) //保留数字并保留小数parseInt(12px) //12 parseFloat(12.86px) //12.86 运算一元运算符前置自增12let i=1console.log(++i + 2) //2+2=4 先自加再使用。 后置自增12let i=1console.log(i++ + 2) //1+2=3 此时i已经为2，但是没有参与运算 先使用再自加。 12let i=1console.log(i++ + ++i + i) //1+3+3=7 第二个i时i为2 比较运算符1234567&gt;&lt;&gt;=&lt;=== //左右两边值是否相等=== //左右两边是否类型和值都相等!== //左右两边是否不全等 NaN不等于任何人，包括它自己。 1console.log(NaN === NaN) //false if语句123if (条件) &#123; 满足条件执行的代码&#125; 条件中只有数字0或者空字符会触发false，其余都是true。 三元运算符可以代替if双分支。 1条件 ? 满足条件执行的代码 : 不满足条件执行的代码 例子： 123456if(3&lt;5)&#123; alert(&#x27;真的&#x27;)&#125;else&#123; alert(&#x27;假的&#x27;)&#125; 和 13&lt;5 ? alert(&#x27;真的&#x27;) : alert(&#x27;假的&#x27;) 等价。 还可以作赋值操作： 1let sum = 3 &lt; 5 ? 3 : 5 //sum=3 数字补0例子123let num = prompt(&#x27;请您输入一个数字&#x27;) //类型为stringnum = num &lt; 10 ? 0 + num : num //判断小于10才补0alert(num) 输入9，输出09 输入11，输出11 数组查询12let arr=[1,2,3]console.log(arr[0]) 修改123let arr=[1,2,3]arr[0]=3console.log(arr[0]) //[3,2,3] 增加push() 添加数组末尾 unshift() 添加数组开头 1234let arr=[1,2,3]arr.push(4) //[1,2,3,4]arr.push(4,5) //[1,2,3,4,5]arr.unshift(0) //[0,1,2,3] 删除pop() 弹出最后一个元素 shift() 弹出第一个元素 splice() 切片删除 &#x2F;&#x2F;arr.plice(起始位置，删除几个) 12345678let arr=[1,2,3]arr.pop() //[1,2]console.log(arr.pop()) //3arr.shift() //[2,3]console.log(arr.shift) //1arr.splice(1,1) //[1,3]arr.splice(1) //[1] 删除索引1后面的所有arr.splice(1,2) //[1] 函数123function 函数名() &#123; 函数体&#125; 调用: 1函数名() 例如： 12345function sayhi&#123; console.log(&#x27;hi&#x27;)&#125;sayhi()","categories":[],"tags":[]},{"title":"如何优雅的将秒换算成-时:分:秒？","slug":"秒转换时间","date":"2024-04-18T01:29:59.000Z","updated":"2024-04-18T04:45:48.735Z","comments":true,"path":"2024/04/18/秒转换时间/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/","excerpt":"","text":"如何优雅的将秒换算成-时:分:秒？思路先看一下题目，发现就是一道模拟题，但是又一些细节的。 首先是数据的规模：时间不超过 10^18,所以需要开 long long。 然后首先要忽略掉毫秒。 这里普及一个知识:1s &#x3D; 1000ms 所以需要忽略后面的三位。直接整除 1000 就可以了。 之后就是处理时分秒了： 1.小时由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用24*60*60来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数60*60（也就是3600），就是小时值了。 2.分钟分钟要先对每小时的秒数60*60取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。 3.秒直接对60取余，剩下的就是秒了。 时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。 当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。 要用到两个函数： 一个是setw()函数，这个函数可以限定域宽，宽度就是括号里的数字。 另外一个setfill()函数，这个函数可以设置当实际的宽度不足setw()函数的值时，用某个字符来补足。（setfill()函数最好放在setw()函数前面） 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,h,m,s; cin&gt;&gt;n; n=n/1000; h=n%(24*3600)/3600; m=n%3600/60; s=n%60; cout&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;s;&#125;","categories":[],"tags":[]},{"title":"css背景","slug":"css-bgc","date":"2024-01-20T04:25:09.000Z","updated":"2024-01-20T04:25:56.969Z","comments":true,"path":"2024/01/20/css-bgc/","link":"","permalink":"https://bayeeaa.github.io/2024/01/20/css-bgc/","excerpt":"","text":"CSS背景背景颜色background-color(bgc) 123div &#123; background-color: pink;&#125; 颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制… 背景图片background-image(bgi) 123div &#123; background-image: url(&#x27;图片的路径&#x27;);&#125; ①背景图片中url可以省略引号。 ②背景图片默认是在水平和垂直方向平铺的。 ③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。 背景平铺background-repeat(bgr) 123div&#123; background-repeat:no-repeat;&#125; repeat (默认值)水平和垂直方向都平铺 no-repeat 不平铺 repeat-x 沿着水平方向(x轴)平铺 repeat-y 沿着垂直方向(y轴)平铺 背景位置background-position(bgp) 123div&#123; background-position:&#125; 方位名词水平方向left、center、right 垂直方向top、center、bottom 123div&#123; background-position: right bottom; //水平位置 垂直位置&#125; 数字+px坐标轴①原点(0,0) 盒子左上角 ②x轴 水平向右 ③y轴 垂直向下 操作将图片左上角与坐标点重合即可 123div&#123; background-position: 50px 100px; //水平位置 垂直位置&#125; 背景相关属性连写background: color image repeat position 可以不按顺序写。 123div&#123; background: pink url(./images/1.jpg) no-repeat bottom center ;&#125; 与img的区别①img标签是一个标签，不设置宽高默认会以原尺寸显示。 ②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。","categories":[],"tags":[]},{"title":"递归——深度优先搜索(dfs)","slug":"递归——深度优先搜索(dfs)","date":"2023-11-06T14:26:27.000Z","updated":"2023-11-07T01:33:27.403Z","comments":true,"path":"2023/11/06/递归——深度优先搜索(dfs)/","link":"","permalink":"https://bayeeaa.github.io/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/","excerpt":"","text":"递归——深度优先搜索(dfs)区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索： 递归方法类似于栈，将数据一直递取到底后自下往上出栈。 大致框架如下： 1234567891011121314viod dfs(int k)&#123; if(输出条件)&#123; cout&lt;&lt; &#125; else&#123; for(int i=0;i&lt;n;i++)&#123; if(vis[i]==0)&#123; a[k]=数字,vis[i]=1//标记使用; dfs(k+1);//向下递取 vis[i]=0;//将其拿出，返回原先状态 &#125; &#125; &#125;&#125; 下列题目方式解决一些排列组合问题。 组合输出 –5个数字组合输入3个盒子 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,r;int a[200],vis[200];//a用来记录牌子，vis用来记录牌子的使用情况int is_rise(int b[])&#123;//判断是否是递增数组 int flag=1; for(int i=1;i&lt;r;i++)&#123; if(a[i]&gt;a[i+1])&#123; flag=0; &#125; &#125; return flag;&#125;void dfs(int k)&#123;//k为盒子的编号，或可以理解为步数 if(k==r+1&amp;&amp;is_rise(a))&#123; for(int i=1;i&lt;=r;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; return; &#125; for(int i=1;i&lt;=n;i++)&#123;//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。 if(vis[i]==0)&#123; a[k]=i,vis[i]=1; dfs(k+1); vis[i]=0;//将牌子拿出来，此时就要把vis归回0 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;r; dfs(1);&#125; 这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。 素数环 eg：输入8 输出4 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[25],vis[25];int n,cnt;int isPrime(int x)&#123; if(x&lt;2)return 0; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)return 0; &#125; return 1;&#125;void dfs(int k)&#123; if(k==n+1 &amp;&amp; isPrime(a[1]+a[n]))&#123;//是否超出边界&amp;&amp;是否头尾相加是素数 cnt++; return; &#125; for(int i=2;i&lt;=n;i++)&#123; if(vis[i]==0 &amp;&amp; isPrime(i+a[k-1]))&#123;//vis用来看有没有用过这个数字 a[k]=i,vis[i]=1;//a用来保存数字 dfs(k+1); vis[i]=0;//当前的这个数字清除，再向下dfs &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; a[1]=1,vis[1]=1; dfs(2); cout&lt;&lt;cnt; &#125; 全排列问题 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[25],b[25]; //a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里void dfs(int k)&#123; //depth first search if(k==n+1)&#123; //k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了 for(int i=1;i&lt;=n;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for(int i=1;i&lt;=n;i++)&#123;//i是指拿在你手上的牌的数字，没用0为了更好理解 if(b[i]==0)&#123;//看看这个牌用过没有，b数组用来看这个牌用过没有用的 a[k]=i,b[i]=1;//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了 dfs(k+1);//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里 b[i]=0;//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推 &#125;&#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(1);&#125; 体积 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt;int a[25],vis[1005];void dfs(int k,int sum)&#123; if(k==n+1)&#123;// cout&lt;&lt;sum&lt;&lt;&quot; &quot;; vis[sum]=1; return; &#125; dfs(k+1,sum+a[k]); dfs(k+1,sum);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; dfs(1,0); for(int i=1;i&lt;=1000;i++)&#123; if(vis[i])cnt++; &#125; cout&lt;&lt;cnt; return 0;&#125; 若把上面代码的注释删除则可以得到： 12331 3 48 4 5 1 7 3 4 0 6 由此可知上面深度搜索遍历的顺序是： 123456781+3+41+31+413+4340 以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。 相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。","categories":[],"tags":[]},{"title":"爬取pixiv日前十图片并下载至本地","slug":"pixiv-crawler","date":"2023-09-11T04:21:25.000Z","updated":"2023-11-06T14:56:59.791Z","comments":true,"path":"2023/09/11/pixiv-crawler/","link":"","permalink":"https://bayeeaa.github.io/2023/09/11/pixiv-crawler/","excerpt":"","text":"爬取pixivic日前十图片实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期： 1.发送请求首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址： 于是我们就可以向这个api发送请求： 1234import requestsurl = &quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;reponse = requests.get(url)print(reponse) #返回&lt;Response [200]&gt; 因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。 2.解析数据返回数据长这个样子： json使用这就是标准的json形式文件，但还不是一个字典(其实很想)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。 我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可： 123response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;]#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png#就是日排行第一的图 但是当你将网站复制进浏览器时你会发现打不开。 url拼接也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接 图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。 3.下载图片至本地目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了： 12345img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot;img = requests.get(img_url)with open(&quot;./top1.jpg&quot;,&quot;wb&quot;) as f: #&quot;wb&quot;是以二进制写入 f.write(img.content) #content是指获取二进制内容 此时你已经可以看到top1的图片下载当前文件夹了。 同理，下载前十的图片只需要加入for循环就可以了，以下省略。 4.下载至指定文件夹这里就需要导入os包： 1234import ospath = &#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27; #这是我的绝对地址if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹，文件夹名字为2023-9-7 path书写这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法： 第二条中的r是用来申明不是转义字符。 这样就可以创建一个文件夹了~ 然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。 5.关于api中日期的变化因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期： 123import datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3) 然后只需要再拼接如url中就可以啦~ 完整代码123456789101112131415161718192021import requestsimport osimport datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3)url = &quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;+str(api_day)+&quot;&amp;mode=day&amp;pageSize=302&quot;response = requests.get(url)date = url[40:50]path = &#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;+date #linux写法if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹for i in range(10): img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][i][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot; img = requests.get(img_url) with open(path+&quot;/top&quot;+str(i+1)+&quot;.jpg&quot;,&quot;wb&quot;) as f: f.write(img.content) print(&quot;正在保存top&quot;+str(i+1)+&quot;中...&quot;)","categories":[],"tags":[]},{"title":"爬虫 --- 以爬取笔趣阁小说为例","slug":"biquge","date":"2023-08-31T07:40:23.000Z","updated":"2023-09-10T14:03:51.640Z","comments":true,"path":"2023/08/31/biquge/","link":"","permalink":"https://bayeeaa.github.io/2023/08/31/biquge/","excerpt":"","text":"爬虫 — 以爬取笔趣阁小说为例1.发送请求123456import requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers) 这是requests请求，若返回response值为200，则表示请求成功 2.获取数据1response = requests.get(url,headers).text 可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析 3.解析数据有以下几种途径：css、xpath、re正则表达 等等 让我们来看看分别用这三种方法怎么去解析到一个章节的标题 css123import parselselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() 这种方法通过css选择器进行选择 xpath123import parselselector = parsel.Selector(response)novel_title = selector.xpath(&quot;//*[@class=&quot;bookname&quot;]/h1/text()&quot;).get() 注意text后面的() re12import renovel_title = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0] 这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串 *注意：以上方法各有利弊，选择合适的方式来解析数据 4.保存数据12with open(&quot;file_name&quot;+&quot;.txt&quot;,mode=&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: #w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入f.write(novel_context) #写入文件 with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径 以上思路已经理清楚了，下面开始实践：爬取一章12345678910111213import parselimport requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers).textselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() #css方法解析数据novel_context_list = selector.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) 注意：join函数的使用： 123456a=[&quot;1&quot;,&quot;2&quot;,&quot;8&quot;,&quot;9&quot;]print(&quot; &quot;.join(a)) #输出1 2 8 9print(&quot;\\n&quot;.join(a)) #输出1(换行)2(换行)8(换行)9b=&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;print(&quot; &quot;.join(a)) #输出a b （注意seq不能是int整形） 爬取各章url12345678910111213import requestsimport reurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] print(novel_url) print(novel_title) 在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的： 我们就可以用re来解析到各个章节的url和title 完整代码123456789101112131415161718192021222324import requestsimport reimport parselurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] novel_response = requests.get(novel_url, headers).text selectors = parsel.Selector(novel_response) novel_context_list = selectors.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) print(&quot;正在保存&quot;+novel_title) novel_title = &quot;*&quot; + novel_title with open(novel_name+&quot;.txt&quot;,mode=&quot;a&quot;) as f: f.write(novel_title) f.write(&quot;\\n&quot;) f.write(novel_context) f.write(&quot;\\n&quot;) f.write(&quot;\\n&quot;) 运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~","categories":[],"tags":[]},{"title":"CSS选择器","slug":"css选择器","date":"2023-08-23T04:35:42.000Z","updated":"2023-08-24T07:48:46.105Z","comments":true,"path":"2023/08/23/css选择器/","link":"","permalink":"https://bayeeaa.github.io/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"引入方式引入方式有以下三种： 1.内嵌式 12345678910111213&lt;!-- 内嵌式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; colour&#123; colour:pink; &#125; &lt;/style&gt;&lt;/head&gt; 2.外联式 12345678910&lt;!-- 外联式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./111.css&quot;&gt; &lt;!-- 111为引入文件名 --&gt;&lt;/head&gt; 3.行内式 1234567&lt;!-- 行内式 --&gt;&lt;body&gt; &lt;div class=&quot;colour&quot;&gt; abcd &lt;/div&gt; &lt;div style=&quot;color: aqua;font-size: large;&quot;&gt;abab&lt;/div&gt;&lt;/body&gt; 选择器一共有4种：标签选择器、类选择器、id选择器、通符选择器 注：一下选择器均是在style标签下的 1.标签123div&#123; color:blue;&#125; 所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div) 2.类选择器123.color-choose&#123; color:blue;&#125; 其html调用方式为： 1&lt;div class=&quot;color-choose&quot;&gt; abab &lt;/div&gt; 3.id选择器123#color&#123; color:blue;&#125; 其html调用方式为： 1&lt;div id=&quot;color&quot;&gt; abab &lt;/div&gt; 注意：id只得调用一次 4.通符选择器12345*&#123; margin:0; padding:0;&#125;&lt;!-- 清除内外边距 --&gt; 对全局内容生效 选择器的选择1.后代 （后面所有代）问题如下 1234&lt;p&gt; abab &lt;/p&gt;&lt;div&gt; &lt;p&gt; 哈哈哈 &lt;/p&gt;&lt;/div&gt; 欲选择div中的p标签，而不是外部的p 以如下方法实现： 12345&lt;style&gt; div p &#123; color:blue; &#125;&lt;/style&gt; 2.子代 （后面一代）问题是要选中div后面的一代 123456&lt;div&gt; &lt;p&gt; dd &lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot;&gt; ddd &lt;/a&gt; &lt;/p&gt;&lt;/div&gt; 以如下方法实现： 123div&gt;p&#123; color:blue;&#125; 3.并集问题：想要让以下这些标签被选到 1234&lt;p&gt; p &lt;/p&gt;&lt;div&gt; div &lt;/div&gt;&lt;span&gt; span &lt;/span&gt;&lt;h1&gt; haha &lt;/h1&gt; 以下面方法实现： 123p,div,span,h1&#123; color:blue;&#125; 4.交集问题：只想要选中下面p中带class&#x3D;”c”的 1234&lt;div class=&quot;c&quot;&gt;abcd&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;a&lt;/p&gt;&lt;div class=&quot;c&quot;&gt;d&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;b&lt;/p&gt; 以下面方法实现： 123p.c&#123; color:blue;&#125; p是标签，c是类名（前面带个.的） 5.伪类问题：想要让鼠标悬停在如下超链接上能够变色 1&lt;a href=&quot;~~~&quot;&gt;传送&lt;/a&gt; 一下方法实现： 1234a:hover&#123; color:red; background-color:yellow;&#125;","categories":[],"tags":[]},{"title":"破壳啦","slug":"page1","date":"2023-08-21T11:25:42.000Z","updated":"2023-08-22T13:45:57.473Z","comments":true,"path":"2023/08/21/page1/","link":"","permalink":"https://bayeeaa.github.io/2023/08/21/page1/","excerpt":"","text":"终于创建好一个博客啦！","categories":[],"tags":[]}],"categories":[],"tags":[]}