{"meta":{"title":"ye's blog","subtitle":"","description":"","author":"Ye","url":"https://Bayeeaa.github.io","root":"/"},"pages":[{"title":"about","date":"2023-08-22T07:06:19.000Z","updated":"2023-08-22T07:07:20.142Z","comments":false,"path":"about/index.html","permalink":"https://bayeeaa.github.io/about/index.html","excerpt":"","text":"hello!"}],"posts":[{"title":"在CEF中通过内置协议加载本地html文件","slug":"在CEF中通过内置协议加载本地html文件","date":"2025-02-08T08:52:55.000Z","updated":"2025-02-08T08:53:43.167Z","comments":true,"path":"2025/02/08/在CEF中通过内置协议加载本地html文件/","link":"","permalink":"https://bayeeaa.github.io/2025/02/08/%E5%9C%A8CEF%E4%B8%AD%E9%80%9A%E8%BF%87%E5%86%85%E7%BD%AE%E5%8D%8F%E8%AE%AE%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0html%E6%96%87%E4%BB%B6/","excerpt":"","text":"在CEF中通过内置协议加载本地html文件在通常情况下我们加载一个html文件，是通过File协议来加载的： 1file:///D:/project/cef/html/index.html 但是这个方法有种种弊端。 File协议弊端1. 安全限制file:// 协议与 HTTP 协议相比，存在更多的安全限制。在浏览器中，file:// 协议访问本地文件时，浏览器会严格限制访问权限，以避免潜在的安全漏洞。这些限制包括： 跨域问题：file:// 协议加载的本地页面可能无法正常执行跨域请求。比如，AJAX 请求、WebSocket 连接等都可能受阻，因为本地文件的跨域访问限制。 混合内容：如果本地页面中引用了网络上的资源，或者本地文件需要请求外部资源，这种混合内容可能会被浏览器拒绝加载，尤其是在严格的内容安全策略下。 2. 浏览器兼容性和一致性即使是 Chromium 内核（CEF 基于 Chromium）也不推荐直接使用 file:// 协议，原因之一是，file:// 协议的行为在不同平台或不同版本的浏览器中可能会有所不同。例如，某些操作系统和浏览器会对本地文件有不同的权限控制或路径解析方式，导致在不同的环境下，加载本地文件的效果不一致。 3. JavaScript 和文件访问权限CEF 中的 JavaScript 执行环境与浏览器的执行环境类似，因此，file:// 协议加载的本地页面可能会遭遇一些权限问题。例如，JavaScript 可能无法像 HTTP 协议一样访问外部资源，或者可能受到浏览器的文件访问权限限制。特别是在 Web 安全性方面，浏览器通常会限制 file:// 页面对本地文件系统的读写操作，防止潜在的恶意脚本访问系统文件。 4. 调试和开发体验不佳使用 file:// 协议时，调试体验通常比通过 HTTP 协议加载页面差。例如，无法像在开发服务器中那样使用浏览器开发工具的调试功能；而且可能遇到一些开发工具或框架的功能无法正常使用，特别是当涉及到热重载、热更新或调试日志时，file:// 协议通常没有 HTTP 环境下那样便捷的支持。 5. 性能问题file:// 协议加载的页面性能可能会受到操作系统文件系统的影响，尤其是在复杂的页面中，加载静态资源（如 JS、CSS 文件）时，可能会有更多的延迟或资源加载问题。通过 HTTP 协议加载页面，通常会有更高的性能优化，因为现代浏览器和 HTTP 协议都有很多优化机制（如缓存、连接池、并发请求等），这在本地文件加载时并不总是能充分利用。 通过本地Web服务解决为了避免这些问题，CEF和大多数现代开发环境都推荐通过启动一个本地 Web 服务器来加载本地页面。使用像HTTP协议访问本地文件系统的好处包括： 可以避免 file:// 协议的权限和安全限制。 可以确保更好的跨平台兼容性和一致性。 可以充分利用浏览器的 HTTP 缓存、请求优化和调试工具。 通常，可以通过启动一个简单的本地服务器（如 http-server、live-server、nginx 或 Apache）来为本地页面提供 HTTP 服务，这样就能通过 http://localhost 或其他本地IP地址来访问你的页面。 注册内置协议处理工厂首先我们可以使用上篇中App中的OnContextInitialized方法 123456789void App::OnContextInitialized() &#123; CEF_REQUIRE_UI_THREAD(); //下面两行代码为新增代码 CefRegisterSchemeHandlerFactory(&quot;https&quot;, &quot;bayeeaa&quot;, new HttpSchemeFactory()); std::string url = &quot;https://bayeeaa/index.html?a=123&quot;; CefBrowserSettings settings; CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(nullptr, url, settings, nullptr, nullptr, nullptr); CefWindow::CreateTopLevelWindow(new WindowDelegate(browser_view));&#125; 可以看出我们在浏览器主线程初始化成功后，调用了这个 CEF 提供的 API ：CefRegisterSchemeHandlerFactory。这个方法为应用注册一个 HttpSchemeFactory 对象，注册成功则返回 true ，失败则返回 false 。我们观察CefRegisterSchemeHandlerFactory中的三个参数，第一个为协议，第二个为域名，域名不一定要.com和.cn结尾，第三个是自定义的协议工厂。 注册成功后我们就可以进行执行操作了。 接管并处理请求HttpSchemeFactory 类的工作很简单，当浏览器以指定的自定义协议加载页面时，它负责接管并处理请求。我们先来看一下这个类的头文件代码： 123456789101112131415161718192021222324252627282930313233#pragma once#include &quot;include/cef_app.h&quot;#include &quot;include/cef_resource_handler.h&quot;#include &quot;include/cef_request.h&quot;class HttpSchemeFactory : public CefSchemeHandlerFactory &#123;public: HttpSchemeFactory() = default; // 删除拷贝函数，防止拷贝实例 HttpSchemeFactory(const HttpSchemeFactory&amp;) = delete; HttpSchemeFactory&amp; operator=(const HttpSchemeFactory&amp;) = delete; // 创建处理器的方法 CefRefPtr&lt;CefResourceHandler&gt; Create(CefRefPtr&lt;CefBrowser&gt; browser, CefRefPtr&lt;CefFrame&gt; frame, const CefString&amp; scheme_name, CefRefPtr&lt;CefRequest&gt; request) override;private: IMPLEMENT_REFCOUNTING(HttpSchemeFactory);&#125;;// CefSchemeHandlerFactory::Create 的实现CefRefPtr&lt;CefResourceHandler&gt; HttpSchemeFactory::Create(CefRefPtr&lt;CefBrowser&gt; browser,CefRefPtr&lt;CefFrame&gt; frame,const CefString&amp; scheme_name,CefRefPtr&lt;CefRequest&gt; request) &#123; // 在此根据请求 URL 以及其他信息创建一个自定义的 CefResourceHandler。 // 你可以根据 request 的内容来选择不同的行为，比如读取本地文件、返回静态内容等。 // 示例: 返回一个简单的字符串作为 HTTP 响应 CefRefPtr&lt;CefResourceHandler&gt; handler = new MyHttpResourceHandler(); // 这里你可以返回自定义的处理器 return handler;&#125; 处理请求： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyHttpResourceHandler : public CefResourceHandler &#123;public: MyHttpResourceHandler() : offset_(0), is_done_(false) &#123;&#125; bool ProcessRequest(CefRefPtr&lt;CefRequest&gt; request, CefRefPtr&lt;CefCallback&gt; callback) override &#123; // 假设返回一个简单的 HTML 内容 std::string html_content = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from custom scheme!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;; response_stream_ = CefStreamReader::CreateForData(html_content.data(), html_content.size()); // 设置响应头 CefRefPtr&lt;CefResponse&gt; response = CefResponse::Create(); response-&gt;SetMimeType(&quot;text/html&quot;); response-&gt;SetStatus(200); response-&gt;SetStatusText(&quot;OK&quot;); callback-&gt;Continue(); return true; &#125; bool GetResponseHeaders(CefRefPtr&lt;CefResponse&gt; response, int&amp; response_length, CefString&amp; redirect_url) override &#123; // 需要返回响应长度 response_length = response_stream_-&gt;GetSize(); return true; &#125; bool ReadResponse(void* data_out, int bytes_to_read, int&amp; bytes_read, CefRefPtr&lt;CefCallback&gt; callback) override &#123; // 读取响应数据 int bytes_left = response_stream_-&gt;GetSize() - offset_; if (bytes_left &gt; 0) &#123; int bytes_to_copy = std::min(bytes_left, bytes_to_read); response_stream_-&gt;Read(data_out, offset_, bytes_to_copy); offset_ += bytes_to_copy; bytes_read = bytes_to_copy; return true; &#125; bytes_read = 0; return false; &#125; IMPLEMENT_REFCOUNTING(MyHttpResourceHandler);private: int offset_; bool is_done_; CefRefPtr&lt;CefStreamReader&gt; response_stream_;&#125;;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://bayeeaa.github.io/tags/C/"}]},{"title":"CEF框架的基本认识","slug":"CEF基本认识","date":"2025-01-26T05:49:58.000Z","updated":"2025-01-26T05:52:41.276Z","comments":true,"path":"2025/01/26/CEF基本认识/","link":"","permalink":"https://bayeeaa.github.io/2025/01/26/CEF%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/","excerpt":"","text":"CEF框架的基本认识CEF（Chromium Embedded Framework） 是一个基于Google Chromium的Web browser控件（桌面开发），旨在将 Chromium 浏览器的功能嵌入到其他应用程序中。它为开发者提供了一个轻量级的方式来集成 Web 内容浏览、HTML5 支持、JavaScript 执行等功能，从而使得开发者可以在桌面应用程序中嵌入网页浏览器或构建基于 Web 的应用程序。我们熟知的钉钉、学习通、网易云、微信等都是借助于CEF框架编写的。为了对CEF框架作最基本的了解，我们先自己写一个CEF框架Demo。 运行官方CEF的示例项目我们主要进行3步准备。 CEF库以及Wrapper源码CEF库下载地址 下载完后是一个压缩文件。注意解压需要用压缩软件（如Bandizip等），使用原生Windows解压时间过长。 cmake：该目录下存放了配置和构建以Windows作为编译环境的cmake配置文件，具体内容可以自行查看。 Debug和Release：这两个文件夹中，打开会看到已经编译好的CEF核心库文件 include：libcef本身提供的头文件以及wrapper会使用到的头文件。 libcef_dll：存放了libcef_dll_wrapper源码。 Resources：CEF作为内核的浏览器运行时需要用到的资源文件。 tests：存放了利用libcef、以及wrapper作为库来编写的浏览器Demo。其中，cefsimple编译出来的是一个简单的浏览器，而cefclient编译出来的是一个展示了cef许多API功能的exe。 使用 CMake 工具来编译 CEFcmake下载地址 打开cmake-gui.exe程序，在Where is the source code栏中选择源码所在目录，在下方的Where to build the binaries栏目中我们可以自定义任意位置，但是为了方便管理，我们选择在源码所在目录下增加一个build文件夹。 Configure&gt;Generate。cmake于是为我们生成了7个解决方案，存在于cef.sln文件中。 使用VS编译我们点击CMake中的Open Project（就是打开cef.sln），然后我们对simple或者client文件进行编译。 同时我们可以在simple_app.cc（或者client_app.cc）中修改url值来改变访问的地址。 然后我们就可以在上面的文件中打开exe文件，将弹出所选url的页面。 基本原理认识现在我们可以通过搭建一个全新的CEF工程来完成对这个程序更加深刻的理解。我们在Visual Studio中创建一个全新的C++项目，然后开始从0编写代码。 配置工程 “常规-&gt;C++语言标准”设置为：ISO C++17 标准 ( /std:c++17 )，这个配置可以使我们在工程中使用现代 C++ 的语言特性。 “C&#x2F;C++ -&gt;常规-&gt;附加包含目录”设置为： D:\\Project\\cef-projects\\cef_binary_132.3.1+g144febe+chromium-132.0.6834.83_windows64 ，这个路径是你下载的 CEF 框架所在的路径。注意：在使用 CEF 框架前你必须已经成功编译了 CEF 的示例项目。 “C&#x2F;C++ -&gt;常规-&gt;预处理器定义”设置为如下内容： 1234567891011121314151617WIN32_WINDOWS__STDC_CONSTANT_MACROS__STDC_FORMAT_MACROS_WIN32UNICODE_UNICODEWINVER=0x0601_WIN32_WINNT=0x601NOMINMAXWIN32_LEAN_AND_MEAN_HAS_EXCEPTIONS=0PSAPI_VERSION=1CEF_USE_SANDBOXCEF_USE_ATL_HAS_ITERATOR_DEBUGGING=0_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS 这些预处理器定义大部分都是 Windows 平台和 CEF 框架要求的预处理器定义，最后一项是为了屏蔽 CEF 框架中低版本 C++ 警告的预处理器。 “C&#x2F;C++ -&gt;代码生成-&gt;运行库”设置为：多线程调试 (/ MTd )，这是为了适配 Chromium 的调试方式而设置的。 “链接器-&gt;输入-&gt;附加依赖项”设置为如下内容： 12345678910111213141516D:\\Project\\cef-projects\\cef_binary_132.3.1+g144febe+chromium-132.0.6834.83_windows64\\build\\libcef_dll_wrapper\\Debug\\libcef_dll_wrapper.libD:\\Project\\cef-projects\\cef_binary_132.3.1+g144febe+chromium-132.0.6834.83_windows64\\Debug\\libcef.libD:\\Project\\cef-projects\\cef_binary_132.3.1+g144febe+chromium-132.0.6834.83_windows64\\Debug\\cef_sandbox.libcomctl32.libgdi32.librpcrt4.libshlwapi.libws2_32.libAdvapi32.libdbghelp.libDelayimp.libOleAut32.libPowrProf.libPropsys.libpsapi.libShcore.lib 这是在编译、链接我们的程序时，使用 CEF 和 Windows 库的配置，其中 D:\\Project\\cef-projects\\cef_binary_132.3.1+g144febe+chromium-132.0.6834.83_windows64 是你下载的 CEF 框架所在的路径。 “链接器-&gt;系统-&gt;子系统”设置为：窗口 ( /SUBSYSTEM:WINDOWS )，VisualStudio 创建空白项目时，默认是控制台项目，这里我们把它调整为窗口项目。 “清单工具-&gt;输入和输出-&gt;附加清单文件”设置为：$(ProjectDir)ceftest.manifest，这是为了让我们的工程生成的可执行程序兼容不同版本的 Windows 操作系统。设置好此配置之后，需要在工程的根目录下（与 main.cpp 在同一个目录）创建一个名为 ceftest.manifest 的文件，代码如下（此处的文件名你也可以按照自己的想法命名，不过注意配置里的文件名要和实际的文件名一致哦）： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; &lt;compatibility xmlns=&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&gt; &lt;application&gt; &lt;!--The ID below indicates application support for Windows 8.1 --&gt; &lt;supportedOS Id=&quot;&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;&quot;/&gt; &lt;!-- 10.0 --&gt; &lt;supportedOS Id=&quot;&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;&quot;/&gt; &lt;!-- 适用于 Windows 11 --&gt; &lt;supportedOS Id=&quot;&#123;A25EFA83-AFF6-4F06-9AC4-84E92AFC6F4B&#125;&quot;/&gt; &lt;/application&gt; &lt;/compatibility&gt;&lt;/assembly&gt; 至此，这个全新的 C++ 工程就配置成功了，但现在还无法使用它，接下来我们就介绍如何为新工程准备资源。 资源准备 把上面的资源复制到D:\\Project\\cef-projects\\ceftest\\x64\\Debug中，因为只有这样这个新工程才能正确调用 CEF 框架提供的API。 入口程序我们目标创建一个应用程序，打开就是我的博客首页。首先在解决方案中创建一个main.cpp文件作为主入口文件，后续再创建App.cpp等文件： 123456789101112131415161718#include &lt;windows.h&gt;#include &quot;App.h&quot;//整个应用的入口函数int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, _In_ int nCmdShow) &#123; //CefEnableHighDPISupport(); 这个是启用高分屏支持的方法，现已不用手动调入 CefMainArgs main_args(hInstance); CefSettings settings; int exit_code = CefExecuteProcess(main_args, nullptr, nullptr); if (exit_code &gt;= 0) &#123; return exit_code; &#125; CefRefPtr&lt;App&gt; app(new App()); CefInitialize(main_args, settings, app.get(), nullptr); CefRunMessageLoop(); CefShutdown(); return 0;&#125; 下面我们来分别讲讲各段代码的用处： wWinMain这是 Windows 应用程序使用的标准入口点，尤其适用于基于 Windows API 的图形用户界面（GUI）应用程序。 声明部分： **int**： 这个方法返回一个 int 类型的数字，操作系统会直接抛弃这个值。但如果有外部应用唤起你这个应用，那么这个返回值对于它来说可能是有意义的，一般返回 0 表示应用程序正常退出，返回其他值表示应用程序因异常而退出。 **APIENTRY**： APIENTRY 是一个宏，通常在 Windows 编程中用于指定调用约定（calling convention）。调用约定定义了函数参数如何传递、返回值如何返回以及函数如何清理堆栈等。APIENTRY 实际上是 __stdcall，表示使用 Windows API 的标准调用约定。 对于 Windows GUI 程序，这个约定用于确保正确的堆栈清理和传递参数。 **wWinMain**： wWinMain 是 Windows 程序的入口点，通常用于 宽字符集（Unicode） 程序。如果你在程序中使用的是宽字符（如 wchar_t 类型），而不是传统的单字节字符（如 char），就会使用 wWinMain。如果是使用单字节字符集，则使用 WinMain。 参数解析： 参数前有 In 修饰符表示该参数是必填的输入参数，有 In_opt 修饰符的意思是该参数是可选的输入参数。 **_In_ HINSTANCE hInstance**： hInstance 是当前应用程序的实例句柄。它是一个指向该应用程序的内存位置的标识符，在 Windows 中，实例句柄用于标识一个应用程序的运行实例。它通常在程序启动时由操作系统提供，后续可以用来访问程序的资源（如窗口、图标等）。 **_In_opt_ HINSTANCE hPrevInstance**： hPrevInstance 是上一个实例的句柄。没有实际意义，是老版本 Windows 系统的历史遗留产物 **_In_ LPTSTR lpCmdLine**： lpCmdLine 是指向命令行参数的指针。它包含传递给程序的命令行字符串（不包括程序名）。如果程序有命令行参数，它们将被传递给 lpCmdLine，你可以在程序中解析它们。例如，lpCmdLine 中可能包含用户指定的路径或其他配置参数。 LPTSTR 是一个指针，指向宽字符集的字符串（wchar_t*）。如果你使用的是宽字符集（Unicode），则此参数是一个宽字符字符串；如果使用的是单字节字符集（ASCII），则它是 char* 类型的字符串。 **_In_ int nCmdShow**： nCmdShow是一个整数值，指定如何显示应用程序的主窗口。这个参数的值由操作系统传递，通常是控制窗口的可见性或状态。例如，nCmdShow 可以指示窗口是最小化、最大化还是普通显示。常见的值包括： SW_SHOW：正常显示窗口 SW_MINIMIZE：最小化窗口 SW_MAXIMIZE：最大化窗口 SW_HIDE：隐藏窗口 应用程序初始化CefMainArgs是 CEF 对应用程序实例句柄的包装类，用于多进程启动。这里我们使用 hInstance 实例化了这个类的对象，名为：main_args 。 CefSettings是 CEF 的配置对象，类似日志级别、调试端口等都是通过这个对象设置的，这里我们就全部使用默认值，后面涉及到具体的配置项之后再详细讲解。 CefExecuteProcess负责启动进程假如我们已经写完了这个程序，我们在启动这个CEF的时候会发现有好几个进程： 这些进程中除了主进程是由用户启动的外，其他子进程都是 CEF 框架通过 CefExecuteProcess 方法启动的。这是为什么呢？这是因为主进程启动后，执行到CefExecuteProcess时，此方法会立即返回 -1 。接下去主进程就会进入 CEF 的消息循环，在适当的时候主进程会以特殊的命令行参数多次启动你的可执行文件，这样就创建了多个子进程。子进程启动后也会执行到这个 CefExecuteProcess 方法，但子进程执行此方法会被阻塞（不会继续执行后面的逻辑），当子进程执行完它们的任务后，这个方法将返回一个大于等于 0 的值。也就是说子进程在第10行代码处就退出执行了，子进程不会执行 12~18 行代码。 CefRefPtr类中的智能指针接下来主进程会创建一个 App 对象，这个对象的指针被封装到一个CefRefPtr类型里了。CefRefPtr用于管理 CEF 中对象的生命周期，它是 CEF 的引用计数智能指针，类似于 C++11 中的 std::shared_ptr，但是具有特定的设计，用于与 CEF 的引用计数机制配合使用。 在 CEF 中，大多数对象都通过引用计数来管理其生命周期。这意味着当一个对象被多个地方引用时，只有当最后一个引用被销毁时，资源才会被释放。这有助于避免内存泄漏和悬挂指针的问题。CefRefPtr 通过自动管理对象的引用计数，帮助开发者避免手动管理内存的复杂性。 CefInitialize方法对CEF框架初始化及消息循环接下来主进程会执行CefInitialize方法，这个方法负责初始化 CEF 的浏览器进程处理类（注意：后文我们提到的浏览器进程与前文提到的主进程属于同一个进程）。这个方法的第一个参数仍然是我们前面创建的 CefMainArgs 对象，第二个参数是 CefSettings 对象，第三个参数就是 App 对象的指针，这里是通过 CefRefPtr 智能指针的 get 方法获取的。第四个参数与沙箱有关，这里我们依然置空。 CefRunMessageLoop负责开启 CEF 消息循环，这个方法会阻塞后面代码的执行，一直到应用程序的某个地方调用了 CefQuitMessageLoop 方法之后，这个方法才会退出执行。（CefQuitMessageLoop 方法会发射应用程序退出的消息，CefRunMessageLoop 方法会收到这个消息，收到这个消息后就退出方法了。） CefShutdown方法会结束主进程，释放资源。最后应用程序退出。 浏览器进程入口操作系统调用完程序的入口函数后，CEF 框架就通过其自身的消息循环机制接管了接下来的执行工作。在之前的主入口main中我们有App对象，并且把这个对象传递给了 CEF 的CefInitialize方法，CEF 框架收到这个对象之后，会把浏览器进程的一些逻辑交给 App 对象执行，也就是说 App 对象就是我们浏览器进程的入口程序。 我们首先来看看App.h文件： 1234567891011#pragma once#include &quot;include/cef_app.h&quot;class App : public CefApp, public CefBrowserProcessHandler&#123;public: App() = default; CefRefPtr&lt;CefBrowserProcessHandler&gt; GetBrowserProcessHandler() override &#123; return this; &#125; void OnContextInitialized() override;private: IMPLEMENT_REFCOUNTING(App);&#125;; #pragma once 是一个编译指令，告诉编译器本头文件只会被包含一次。这样可以避免多次包含同一个头文件导致的重复定义问题。让我们来逐行分析一下这段代码： class App : public CefApp, public CefBrowserProcessHandler: 这行定义了一个名为 App 的类，并且它从 CefApp 和 CefBrowserProcessHandler 这两个基类继承。 CefApp 是 CEF 应用程序的基类，它提供了对 CEF 应用程序生命周期的管理。 CefBrowserProcessHandler 是 CEF 中处理浏览器进程的类，它提供了浏览器进程相关的回调函数。 因为 App 同时继承了这两个类，意味着它既是 CEF 应用程序的一个实例（CefApp），又能处理浏览器进程的事件（CefBrowserProcessHandler）。 App() &#x3D; default: 这是 App 类的构造函数定义。= default; 表示编译器会自动生成默认构造函数，这意味着没有任何自定义的初始化操作。如果需要添加构造函数的初始化行为，可以手动定义它。 CefRefPtr&lt; CefBrowserProcessHandler &gt; GetBrowserProcessHandler() override { return this; }: 这个函数是 CefApp 类中的纯虚函数 GetBrowserProcessHandler 的重写（override）。 该函数返回一个 CefRefPtr&lt;CefBrowserProcessHandler&gt;，也就是返回 this 指针（this 是当前类 App 的指针）。 CefRefPtr 是 CEF 中的智能指针，用于管理对象的生命周期，确保对象不会在使用期间被销毁。 由于 App 同时继承了 CefBrowserProcessHandler，所以返回 this 指针是合法的，表示 App 也充当了浏览器进程的处理器。 void OnContextInitialized() override: OnContextInitialized 是 CEF 中 CefBrowserProcessHandler 类的一个回调函数。当 CEF 完成初始化时，这个函数会被调用。 在该函数内，通常会执行一些初始化代码，比如创建浏览器窗口、加载网页等。 这个函数只是声明，在代码中可能会有相应的定义来实现实际的初始化逻辑。 IMPLEMENT_REFCOUNTING(App): IMPLEMENT_REFCOUNTING 是 CEF 提供的宏，用来实现对象的引用计数功能。 CEF 使用引用计数来管理对象的生命周期。IMPLEMENT_REFCOUNTING(App) 会在类 App 中自动生成必要的代码，使得类 App 支持引用计数。 引用计数机制可以确保对象在不再需要时被自动销毁，避免内存泄漏。 这段代码使得 App 类对象可以通过 CEF 的引用计数系统来进行正确的内存管理。 总而言之这段代码定义了一个名为 App 的类，它继承自 CefApp 和 CefBrowserProcessHandler类，并且实现了 CefBrowserProcessHandler中的回调函数 OnContextInitialized。这个类主要用于处理 CEF 浏览器进程的初始化和生命周期管理。通过 CefRefPtr 管理对象的引用计数，确保内存管理的安全性。 窗口创建逻辑我们在OnContextInitialized方法中创建了第一个窗口，让我们看看App.cpp文件内的文件： 1234567891011121314#include &quot;App.h&quot;#include &quot;include/cef_browser.h&quot;#include &quot;include/views/cef_browser_view.h&quot;#include &quot;include/views/cef_window.h&quot;#include &quot;include/wrapper/cef_helpers.h&quot;#include &quot;WindowDelegate.h&quot;//CEF主进程上下文环境初始化成功void App::OnContextInitialized() &#123; //表示调用App内的成员函数 CEF_REQUIRE_UI_THREAD(); auto url = &quot;https://www.bayeeaa.top&quot;; CefBrowserSettings settings; CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(nullptr, url, settings, nullptr, nullptr, nullptr); CefWindow::CreateTopLevelWindow(new WindowDelegate(browser_view));&#125; CEF_REQUIRE_UI_THREAD()：这是 CEF 的一个宏，确保后续的代码在 UI 线程中执行。UI 操作必须在主线程（UI 线程）上完成。 auto url = &quot;https://www.bayeeaa.top&quot;;：定义了一个 URL 字符串，指定浏览器将要加载的网页地址。 CefBrowserSettings settings;：创建一个 CefBrowserSettings 对象，用于配置浏览器实例的设置。 CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(nullptr, url, settings, nullptr, nullptr, nullptr);：这行代码创建一个浏览器视图（CefBrowserView），并设置它的 URL、浏览器设置等。 nullptr 表示没有指定的参数，比如没有提供父窗口、没有指定特定的浏览器实例等。 CefWindow::CreateTopLevelWindow(new WindowDelegate(browser_view));：这行代码创建了一个顶级窗口，并将 WindowDelegate（一个窗口代理类的实例）与 browser_view 绑定。 WindowDelegate 类通常负责处理窗口的事件（如窗口大小调整、关闭等）。 窗口代理对象窗口代理对象（WindowDelegate）通常是指一个负责管理和处理窗口事件的类。这些事件包括窗口的创建、大小调整、关闭、鼠标和键盘输入等。WindowDelegate 不是 CEF 的核心组件之一，但它通常作为一个自定义类出现在 CEF 的应用程序中，用来简化与窗口相关的操作和事件处理。当浏览器进程的主线程初始化成功后，App 对象的 OnContextInitialized 方法会被执行，在这个方法的最后，我们通过CreateTopLevelWindow 方法为 CEF 框架提供了一个窗口代理对象。 CEF 框架会把与窗口创建有关的逻辑交给这个对象来执行。 所以，在 CEF 中，窗口本身并不直接处理用户交互或者窗口系统事件。相反，它依赖于代理对象来执行这些任务。通过创建一个 WindowDelegate 对象，可以自定义和实现窗口的行为，处理和响应窗口的生命周期事件。 WindowDelegate.h： 12345678910111213141516#pragma once #include &quot;include/views/cef_window.h&quot; #include &quot;include/views/cef_browser_view.h&quot;class WindowDelegate : public CefWindowDelegate&#123;public: explicit WindowDelegate(CefRefPtr&lt;CefBrowserView&gt; browser_view) : browser_view_(browser_view) &#123;&#125;; void OnWindowCreated(CefRefPtr&lt;CefWindow&gt; window) override; void OnWindowDestroyed(CefRefPtr&lt;CefWindow&gt; window) override; CefRect GetInitialBounds(CefRefPtr&lt;CefWindow&gt; window) override; WindowDelegate(const WindowDelegate&amp;) = delete; WindowDelegate&amp; operator=(const WindowDelegate&amp;) = delete;private: CefRefPtr&lt;CefBrowserView&gt; browser_view_; IMPLEMENT_REFCOUNTING(WindowDelegate);&#125;; WindowDelegate 类继承自 CefWindowDelegate ，它的构造函数接收一个 CefBrowserView 类型的智能指针，并把这个智能指针存放到 browser_view_ 私有变量中，以备后续使用。 与 App 类一样，它也使用了 IMPLEMENT_REFCOUNTING 宏，除此之外，它还删除了拷贝和赋值操作（注意头文件中的两个 “…&#x3D; delete” 语句，这部分内容我们将在下一节课进行详细讲解）。 这个类实现了父类的三个方法，CEF 框架会在适当的时机调用这三个方法，一般我们可以把它理解为窗口生命周期内的事件，它们分别是：设置窗口位置和大小事件、窗口创建成功事件、窗口销毁成功事件。 WindowDelegate.cpp： 1234567891011121314151617181920212223242526#include &quot;WindowDelegate.h&quot;#include &quot;include/cef_app.h&quot;#include &quot;include/views/cef_display.h&quot;//窗口创建成功void WindowDelegate::OnWindowCreated(CefRefPtr&lt;CefWindow&gt; window) &#123; window-&gt;AddChildView(browser_view_); window-&gt;Show(); browser_view_-&gt;RequestFocus(); window-&gt;SetTitle(L&quot;这是我的窗口标题&quot;); //window-&gt;CenterWindow(CefSize(800, 600));&#125;//窗口销毁成功void WindowDelegate::OnWindowDestroyed(CefRefPtr&lt;CefWindow&gt; window) &#123; browser_view_ = nullptr; CefQuitMessageLoop();&#125;//设置窗口位置和大小CefRect WindowDelegate::GetInitialBounds(CefRefPtr&lt;CefWindow&gt; window) &#123; CefRefPtr&lt;CefDisplay&gt; display = CefDisplay::GetPrimaryDisplay(); CefRect rect = display-&gt;GetBounds(); rect.x = (rect.width - 800) / 2; rect.y = (rect.height - 600) / 2; rect.width = 800; rect.height = 600; return rect;&#125; 设置窗口位置和大小 当 App 类 CreateTopLevelWindow 方法被执行后，CEF 框架将创建一个系统窗口，创建这个窗口之前，CEF 框架会调用GetInitialBounds方法，在这个方法中我们做了如下几个工作。 设定窗口的尺寸为宽 800 像素，高 600 像素。 通过CefDisplay 类的静态方法GetPrimaryDisplay 获取到了用户的主屏幕信息。 根据主屏幕信息及设定的窗口尺寸计算出窗口位于屏幕正中间时窗口的坐标。 通过 CefRect 结构把窗口的坐标及尺寸返回给 CEF 框架。 我们可以在窗口创建成功之后再通过窗口对象的 CenterWindow 方法来把窗口设置到屏幕正中间（同时也可以设置窗口尺寸），但这显然不如在窗口创建之初就明确窗口的位置和尺寸更高效。如果开发者不通过 GetInitialBounds 方法设置窗口的尺寸，还可以通过重写基类的 GetPreferredSize方法来设置窗口尺寸。 CEF 的示例项目就是这么做的，但我认为还是在GetInitialBounds 方法中完成这项工作比较好。 窗口创建成功事件 当 App 类 CreateTopLevelWindow 方法被执行后，CEF 框架将创建一个系统窗口，当这个窗口成功创建完成后， OnWindowCreated 被调用，我们在这个方法里把 App 类里创建的 BrowserView 对象添加到了这个窗口中（ window-&gt;AddChildView ），然后让这个窗口显示出来（ window-&gt;Show ），最后用户焦点被聚焦在 BrowserView 上（ browser_view_-&gt;RequestFocus ），最后一行注释掉的代码就是把窗口移动到主屏幕中央的代码。 窗口销毁成功事件 当窗口被销毁后（可能是用户点击了窗口的关闭按钮，也可能是代码逻辑触发了窗口关闭的方法），OnWindowDestroyed 方法被执行，此处我们把 browser_view_ 指针置空。接着我们执行了 CefQuitMessageLoop 方法，这个方法会在 CEF 的消息循环中插入一个退出消息，CEF 框架收到这个消息后，会退出消息循环，清理资源，退出应用。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://bayeeaa.github.io/tags/C/"}]},{"title":"pandas数据分析和plot画布的使用","slug":"pandas数据分析和plot画布的使用","date":"2024-11-23T04:29:07.000Z","updated":"2024-12-06T03:18:50.422Z","comments":true,"path":"2024/11/23/pandas数据分析和plot画布的使用/","link":"","permalink":"https://bayeeaa.github.io/2024/11/23/pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8Cplot%E7%94%BB%E5%B8%83%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"pandas数据分析和plot画布的使用在我们实际生活中充满着大量的数据，那么这些数据需要怎么去筛选呢？python中的pandas给了我们非常强大的批量管理功能，同时plot画布也可以便于我们将数据可视化。 pandaspandas中包括Series和DataFramepandas 是 Python 中一个非常流行的数据分析库，它提供了高效、灵活的数据结构和工具，尤其是 DataFrame 和 Series 两种数据结构，广泛用于数据清洗、处理、分析和建模。 pandas :是一个 Python 的库（包），它的名字源自“panel data”的缩写。pandas 提供了高效的数据结构和数据操作工具，特别是处理表格数据（类似数据库表或 Excel 表格）和时间序列数据。它能够让用户轻松地加载、清理、处理、变换、分析和可视化数据。 1import pandas as pd Series：是 pandas 中的一种数据结构，类似于一维数组（numpy.ndarray），但它具备更多功能。每个 Series 由一组数据和一个与之相关的索引组成，因此它不仅仅是一个简单的列表，还可以通过标签来访问元素。Series 是 pandas 中最基础的数据类型。 一维数据结构。 包含数据（可以是任何类型，如数字、字符串、日期等）和索引。 索引为数据提供了标签，可以通过标签进行定位和访问。 示例： 1234# 创建一个 Series 对象s = pd.Series([10, 20, 30, 40], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])print(s) 输出： 1234b 20c 30d 40dtype: int64 在这个例子中，s 是一个 Series，它包含四个数据点和相应的索引标签。 Series 的内部结构： 数据：[10, 20, 30, 40] 索引：[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] DataFrame：是 pandas 中最强大和常用的数据结构，它是一个二维的表格结构，类似于数据库中的表、Excel 表格或 SQL 查询的结果集。DataFrame 可以被看作是多个 Series 的组合，每个 Series 对应一个列，因此每个列都可以有自己的数据类型。 特点： 二维数据结构（表格形式）。 每列是一个 Series，每行也有索引。 行和列都有标签，可以通过行标签和列标签进行数据访问。 示例： 123456789101112import pandas as pd# 创建一个 DataFrame 对象data = &#123; &#x27;A&#x27;: [1, 2, 3], &#x27;B&#x27;: [4, 5, 6], &#x27;C&#x27;: [7, 8, 9]&#125;df = pd.DataFrame(data)print(df) 输出： 1234 A B C0 1 4 71 2 5 82 3 6 9 在这个例子中，df 是一个 DataFrame，它包含三列：A、B 和 C，每列的数据是一个 Series。 pandas、Series 和 DataFrame 之间的关系 pandas 是一个库，提供了操作和分析数据的功能。 pandas 包含了 Series 和 DataFrame 这两种核心的数据结构。 Series 是 pandas 中的一维数据结构，它可以看作是 DataFrame 的一列。 Series 适用于一维数据的存储和操作，它有一个一维的数组结构和一个与之相关的索引（标签）。 DataFrame 是 pandas 中的二维数据结构，由多个 Series 组成。 每个 DataFrame 由多个列（Series）组成，行和列都可以有标签（索引和列名）。 数据结构的层级关系： pandas 是整个库。 Series 是 pandas 提供的基本数据结构之一，表示一维数据。 DataFrame 是 pandas 中的二维数据结构，由多个 Series 组成。 以上我们搞清楚了pandas、Series、DataFrame之间的关系，接下来我们看看如何使用他们。 读取将csv文件读取成dataframe对象： 12import pandas as pddf_citygdp = pd.read_csv(&#x27;city.csv&#x27;, index_col=0, header=0) index_col&#x3D;0表示将第一列作为行索引，header&#x3D;0表示将第一行作为列索引。 同样的，如果是excel文件： 12import pandas as pddf_zpcjd = pd.read_excel(&#x27;综评成绩单.xlsx&#x27;, index_col=[1, 2]) index_col&#x3D;[0,1]表示将第二和第三列作为行索引。 注意： csv文件：是纯文本文件，每一行代表一条记录，记录中的字段由逗号或其他分隔符（如制表符、分号等）分隔。 xlsx文件：是 Excel 的标准文件格式，基于 XML（可扩展标记语言）。它使用压缩的二进制格式存储数据，并可以包含多个工作表（Sheet）。 或者直接手动创建： 12data = &#123;&#x27;A&#x27;: [1, 2, 3, 4, 5], &#x27;B&#x27;: [10, 20, 30, 40, 50]&#125;df = pd.DataFrame(data) 输出： 123456 A B0 1 101 2 202 3 303 4 404 5 50 筛选列筛选假如：我们要筛选出”20经贸类4”的作业、实验、出勤、期末情况。 首先我们如果我们按字典的输入方式，输入： 1df_zpcjd[&#x27;班级&#x27;] 输出： 1234567891011121314151617181920212223242526学号 姓名 180110840516 梁家豪 18会计2190110920132 石杨 19经贸1200110920423 李润 20财会类3200110920426 林小康 20财会类3200110810629 吾佳悦 20财税类6200110920415 胡绮 20金融类2200110920401 陈思慧 20经贸类4200110920402 陈特 20经贸类4200110920404 陈雨廷 20经贸类4200110920405 陈雨薇 20经贸类4200110920406 戴佳妮 20经贸类4200110920407 丁子厚 20经贸类4200110920408 董睿滢 20经贸类4200110920409 董欣桦 20经贸类4200110920410 符嘉瑞 20经贸类4200110920411 傅敬轩 20经贸类4200110920412 巩静雯 20经贸类4200110920413 洪旭辉 20经贸类4200110920414 侯家馨 20经贸类4200110920416 黄伟伟 20经贸类4200110920417 黄卓佳 20经贸类4200110920418 姜梦柯 20经贸类4200110920419 荆国隆 20经贸类4200110920420 赖砚儿 20经贸类4... 可以看到输出了一整列只有班级的值，因此我们只用直接将“班级“进行比较，无需再用for循环，就可以直接输出所有”20经贸类4“班级的信息： 12df_20_jm4 = df_zpcjd[df_zpcjd[&#x27;班级&#x27;] == &#x27;20经贸类4&#x27;]print(df_20_jm4) 输出为： 12345678910111213141516171819202122232425 班级 作业 实验 出勤 期末学号 姓名 200110920401 陈思慧 20经贸类4 90 95 95 84200110920402 陈特 20经贸类4 65 65 65 72200110920404 陈雨廷 20经贸类4 90 85 85 44200110920405 陈雨薇 20经贸类4 90 95 95 83200110920406 戴佳妮 20经贸类4 90 90 90 76200110920407 丁子厚 20经贸类4 85 90 90 57200110920408 董睿滢 20经贸类4 97 90 90 51200110920409 董欣桦 20经贸类4 70 80 80 66200110920410 符嘉瑞 20经贸类4 90 90 90 68200110920411 傅敬轩 20经贸类4 70 80 80 72200110920412 巩静雯 20经贸类4 97 90 90 76200110920413 洪旭辉 20经贸类4 90 95 95 85200110920414 侯家馨 20经贸类4 92 85 85 48200110920416 黄伟伟 20经贸类4 95 90 90 73200110920417 黄卓佳 20经贸类4 95 90 90 75200110920418 姜梦柯 20经贸类4 96 90 90 78200110920419 荆国隆 20经贸类4 96 90 90 55200110920420 赖砚儿 20经贸类4 96 95 95 84200110920421 李鲍华 20经贸类4 95 90 90 57200110920422 李慧婷 20经贸类4 90 90 90 67200110920424 李奕璁 20经贸类4 96 95 95 81200110920425 李雨萍 20经贸类4 93 90 90 77... 由次可以看到，进行直接的比较就可以筛选出想要的值。 最后再将想要的值筛选出所需列即可（如果由多个列，直接用列表即可）。 完整如下： 123df_20_jm4 = df_zpcjd[df_zpcjd[&#x27;班级&#x27;] == &#x27;20经贸类4&#x27;] df_selected = df_20_jm4[[&#x27;作业&#x27;, &#x27;实验&#x27;, &#x27;出勤&#x27;, &#x27;期末&#x27;]]print(df_selected) 行筛选这里我们就可以讲到loc方法，loc方法可以帮我们精准定位我们需要的信息。 1df.loc[行索引, 列索引] 比如我想要筛选出“陈思慧”这一行，我们就可以直接输入： 1df_zpcjd.loc[(200110920401, &#x27;陈思慧&#x27;)] #由于是多索引，我们要把索引值完整的加上，即包括学号 输出： 123456班级 20经贸类4作业 90实验 95出勤 95期末 84Name: (200110920401, 陈思慧), dtype: object 筛选期末成绩小于40或者综合成绩小于60的： 1df_bukao=df_zpcjd[(df_zpcjd[&quot;期末&quot;]&lt;40) | (df_zpcjd[&quot;综合成绩&quot;]&lt;60)] 注意或是”|”还有两项之间要用括号分隔。 清洗行删除删除行时，通常使用 drop() 方法并指定 axis=0（行的方向），可以通过行标签来删除。 1df = df.drop(&#x27;行标签&#x27;, axis=0) 列删除1df = df.drop(&#x27;列名&#x27;, axis=1) 删除重复列1df.loc[:, df_citygdp.nunique() &gt; 1] 这里的用了loc中的nunique方法。这个方法会返回每一列中唯一值的数量。结果是一个包含每列唯一值数量的 Series。 1df.dropna(axis=1) 这个dropna方法可以删除所有包含NaN的列(或行) Series保存保存一个新系列，一行一列，只用Series即可 1234567891011121314max_score = df_zpcjd[&#x27;综合成绩&#x27;].max() # 最大值min_score = df_zpcjd[&#x27;综合成绩&#x27;].min() # 最小值mean_score = df_zpcjd[&#x27;综合成绩&#x27;].mean() # 平均值std_score = df_zpcjd[&#x27;综合成绩&#x27;].std() # 标准差var_score = df_zpcjd[&#x27;综合成绩&#x27;].var() # 方差sr_cjtj = pd.Series(&#123; &#x27;最大值&#x27;: max_score, &#x27;最小值&#x27;: min_score, &#x27;平均值&#x27;: mean_score, &#x27;标准差&#x27;: std_score, &#x27;方差&#x27;: var_score&#125;)print(sr_cjtj) 输出： 123456最大值 95.650000最小值 38.400000平均值 75.136170标准差 11.516603方差 132.632142dtype: float64 时间计算时间计算需要用到pandas自带的to_datetime方法： 12df_order[&#x27;use_start_time&#x27;] = pd.to_datetime(df_order[&#x27;use_start_time&#x27;], errors=&#x27;coerce&#x27;)df_order[&#x27;lock_time&#x27;] = pd.to_datetime(df_order[&#x27;lock_time&#x27;], errors=&#x27;coerce&#x27;) 设置 errors=&#39;coerce&#39;，如果无法转换为日期时间，则将该值设置为 NaT（Not a Time）。 如果需要计算时间差值： 1df_order[&#x27;meal_duration&#x27;] = (df_order[&#x27;lock_time&#x27;] - df_order[&#x27;use_start_time&#x27;]).dt.total_seconds()/60 注意这里两个时间相减返回的是一个timedelta对象，因此可以用dt中的total_seconds方法返回差了几秒。然而如果你使用： 1df_order[&#x27;use_start_time&#x27;].dt.total_seconds() 则报错，因为df_order[‘use_start_time’]为datetime对象。 如果你要提取出日期，则这么写： 1df_order[&#x27;use_start_date&#x27;] = df_order[&#x27;use_start_time&#x27;].dt.date 这个dt是datetime，用的是dt中的date方法。 groupby按组分别计算，比如我需要计算每天的平均使用时间(题目是用餐时间)，就可以以日期为组，计算出的时间差为值计算平均值： 12#df.groupby(&#x27;组名&#x27;)[&#x27;值&#x27;]daily_avg_meal_time = df_order.groupby(&#x27;use_start_date&#x27;)[&#x27;meal_duration&#x27;].mean() 输出： 1234567891011121314use_start_date2016-08-01 10.4738102016-08-02 11.5638892016-08-03 13.1166672016-08-04 13.4653852016-08-05 1109.6500002016-08-06 9.1413152016-08-07 9.0546882016-08-08 10.7510422016-08-09 9.5555562016-08-10 12.1714292016-08-11 10.8522222016-08-12 693.8754392016-08-13 10.120707 plot画布首先我们要导入文件： 123import matplotlib.pyplot as pltplt.rcParams[&#x27;font.sans-serif&#x27;] = &#x27;SimHei&#x27; plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False #中文输入 我们约定俗成简写成plt。 下面两行是为了能够有中文输入，因为原本这里是不支持中文的。 我们要创建要一个画布，我们主要要有一下部件： 函数类型 函数数据 标题 x轴标签、y轴标签 x轴坐标数据、y轴坐标数据 这几个都是独立开来的，所以我们只需要的是叠加，就能完成画布制作。 折线图 123456789p1 = plt.figure(figsize=(8,20)) #父画布p1.add_subplot(3,1,1) #三分之一的画布占用，下面的plt都属指这个subplot，而且都是并行执行的。plt.plot(range(20),ar_shuju[-3:-23:-1,-2],color=&#x27;r&#x27;) #plot(x轴数据，y轴数据，线条颜色)plt.plot(range(20),ar_shuju[-3:-23:-1,-1],color=&#x27;y&#x27;) #plot是折线图plt.title(&#x27;1996-2015人口变化趋势&#x27;) #标题plt.xlabel(&#x27;年份&#x27;) #x轴标签plt.ylabel(&#x27;人口（万人）&#x27;) #y轴标签plt.xticks(range(20),ar_shuju[-3:-23:-1,0],rotation=45) #x轴数据名称(个数，数据，倾斜度)plt.legend([&#x27;城镇人口&#x27;,&#x27;乡村人口&#x27;]) #线的名称 这个例子中range(20)表示x轴的数据，ar_shuju[-3:-23:-1,-2]表示y轴数据。 饼状图 1234p1.add_subplot(3,1,3)explodel = [0.01,0.01]plt.pie(ar_shuju[0,4:6],explode=explodel,labels=[&#x27;城镇人口&#x27;,&#x27;乡村人口&#x27;],autopct=&#x27;%5.2f%%&#x27;)plt.title(&#x27;2015年末城乡人口比例图&#x27;) 条状图 1plt.bar([x轴数据...],[y轴数据...]) 道理类似。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://bayeeaa.github.io/tags/Python/"}]},{"title":"电影镜头语言的运用和表达技巧","slug":"电影镜头语言的运用和表达技巧","date":"2024-10-26T15:43:41.000Z","updated":"2024-10-26T16:13:52.408Z","comments":true,"path":"2024/10/26/电影镜头语言的运用和表达技巧/","link":"","permalink":"https://bayeeaa.github.io/2024/10/26/%E7%94%B5%E5%BD%B1%E9%95%9C%E5%A4%B4%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%94%A8%E5%92%8C%E8%A1%A8%E8%BE%BE%E6%8A%80%E5%B7%A7/","excerpt":"","text":"电影镜头语言的运用和表达技巧 我们都知道电影之所以区别与文学，就是电影能够通过镜头的变化来表达除了情节之外的内容。一部电影拥有一波三折的情节，也更少不了镜头语言带来的情感支撑。 电影的镜头很多，包括:仰拍、俯拍、平视、长焦、中焦、长镜头、蒙太奇、斯坦尼康长镜头等等。那么也许我们会好奇电影是如何通过这些来表达一些隐藏的情感呢？ 在摄像机刚刚发明出来的时候，人类第一次能够在一块屏幕上看到运动的图画，它们由一帧一帧的图片组成，可以拍摄一个运动的火车或一个一个人。 但是光这样拍出来有什么好看？我们现实中也有火车啊，为什么不去直接看活的火车呢？然后导演们就开始想办法让影片变得有意思，比如剪剪胶片然后再拼接起来？于是剪辑的手法就开始风靡了起来，通过不断的发展，它开始成为了一种视听语言，于是我们赋予它一个名字——蒙太奇。 蒙太奇蒙太奇在法语是”剪接”的意思，但到了俄国，它被发展成一种电影中镜头组合的理论。导演们发现，如果将一些特殊的片段减去其中的内容，不但不会影响情节的推进，而且能激发观众的想象，从而使电影有更强的可读性。 《老男孩》中，“曾经”与“现在”同时出现，增强了“现在”的我回忆其“曾经”的事的感觉。 《沉默的羔羊》中，史达林和克劳福德同时到达不同的可疑凶手住宅，但是导演将两边的时间线剪在了一起，而最终史达林胜出。更加展现了两边的博弈较量。 运动镜头从上面两个例子不难看出，蒙太奇的应用使得一部电影更加的活泼，也更加的耐人寻味。然而单单有蒙太奇的剪辑可不够，我们知道我们所看到的电影，实际上就是一部摄像机所“看”到的，我们的视角都是由镜头给到的。而摄影机又可以是非常灵活的，比如两个人对话，我们可以是第三个看他们对话的人，也可以是其中对话的人，可以主观，也可以客观。这就设计到了镜头的运动问题，镜头可以表示人的主观情感，也以客观的视角记录整个事件。 推镜 《2001太空漫游》中，镜头快速向哈尔的眼睛推进，强化了哈尔对人监视的压迫感，令人不寒而栗。 手持镜 《辛德勒的名单》中，纳粹军晚上对克拉科夫区犹太人进行二次清算，此时采用手持镜头跟随军队的跑动，伴随着镜头的抖动使纳粹军更有恐怖感。 在电影的发展中，运动的镜头出现了很多种，包括摇臂、手持、轨道、斯坦尼康等等。但是想要运用好各个镜头的使用，以至于不让观众绝对莫名其妙或者是过于过渡的使用让人觉得炫技，就要深度的结合情节与观众此时可能的情感，使得故事推进自然，又不让观众视觉疲劳。 斯坦尼康长镜头 比如《闪灵》这部电影中第一次运用了斯坦尼康长镜头。也是第一次电影中，将摄影机架设的如此低，又如此平滑的跟随角色运动相当长的一段镜头。摄影机时刻跟随着丹尼运动，此时角色静止，走廊运动。这时走廊被赋予了生命，不禁增加了这时的怪诞离奇之感。 镜头排布当然不止运动的镜头能够表示主观感受，普通的静止镜头也能通过特殊的排布展现情感。比如俯视，仰视，平视镜头，又比如镜头按比例分割，镜头拼接，对焦，泛焦，失焦等等。那么在电影中实际是怎么表现的呢？ 仰视 我们看到在《小丑》中，当小丑完成了最后的杀戮，最后在人群中缓缓站起，此时采用的是仰视的镜头，同时配合上背景的虚化，对主角亚瑟的对焦，体现了此时亚瑟在底层人民心中的形象。一个精神失常，只为让世界陷入紊乱的恶魔就此诞生。然而仰视不仅仅可以表示一种崇拜之感，还有有强烈的压迫。比如《老男孩》中这段几乎是垂直的仰视，同时让人物失焦，彻底看不清人的脸，大大加强了人物的压迫力，以及被拉住的人的恐惧。 抛开上面的仰视，在俯视的镜头下又会有怎么样子的表现呢？同样是《老男孩》，下面是一个俯视的镜头。 俯视 图片中的角色即将要掉入河中，而有人却拉住她的手不让她掉下。此时是一个俯视的镜头，代表了拉人者的视角。可以看出角色另一只手已经放下，背后是大片的河水，绝望之感油然而生。 对焦不仅仅是拍摄角度可以创造出人物情绪，同样焦点的排布也可以创造出独特影视观感。具体可以看下图的李宇镇与吴大秀对峙的画面。 李宇镇采用广角怼脸拍摄，同时背后的吴大秀采用平视，全身拍摄。我们可以看到这组画面很奇怪，怎么一个画面有两个焦点？实际上这个画面是分开来拍摄然后拼接起来的，这样就能让两个焦点同时保持在这两个角色身上，更好的表现了两人的对峙情况，同时也完整展现了李宇镇的表情。 由此我们简单的介绍了仰视、俯视、平视、对焦等拍摄技巧。我们可以看到，这些镜头的设置，往往需要和背景所结合在一起，因为电影实际上就是在拍摄这些人，在什么地方，发生了什么事。因此，环境所带来的效果也不可或缺。甚至我们在拍摄电影的时候，可以有意识的把环境合理的当作道具来展现，不仅不会破坏观感，更能丰富内在情感。 与环境交互 比如在《小姐》中，导演通过这个门框将小姐写的信遮挡了起来，同时又将二人割裂开来，不仅给观众设下了悬念，让观众猜里面写的是什么，同时又由于是二人的初次见面，象征着内心的隔阂与陌生。同样环境的运用可以更加深入，比如看《霸王别姬》这段。 这是程蝶衣和段小楼在唱戏前一起化妆的情景，可以看到镜子一圆一方，象征蝶衣柔，小楼刚。而此时菊仙小姐已经在外等候小楼，二人可以说就此结下隔阂。此时两人都是镜子中看到的彼此，都并不是真正的“彼此”，二人已无法坦诚彼此，也为后文二人的恩怨埋下伏笔。蝶衣依旧无法接受师哥爱上别的女人的事实。 总结电影发展至今日已出现诸多不仅仅包括上述几个案例的使用。当然想要拍好一部电影更加重要的还是情节的推动，演员表现的抓捕，以及配乐的循序渐进等等。无论是运动镜头，还是静止镜头，重要的是一步一步把基础打好，过分的追求镜头雕琢反而会适得其反。因此合理运用镜头，也是学会拍电影的一部分。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://bayeeaa.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"CORS跨源资源共享","slug":"CORS跨源资源共享","date":"2024-10-20T10:21:24.000Z","updated":"2024-10-20T10:53:33.285Z","comments":true,"path":"2024/10/20/CORS跨源资源共享/","link":"","permalink":"https://bayeeaa.github.io/2024/10/20/CORS%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/","excerpt":"","text":"CORS跨源资源共享当我通过axios向目标url发送请求时候出现下面报错： Javascript代码如下： 123456789101112131415axios(&#123; url : &quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot;, headers : &#123; &quot;User-Agent&quot;: &quot;123&quot;, &quot;Cookie&quot;: &quot;123&quot; &#125;, data : &#123; &quot;xnm&quot;: &quot;2023&quot;, &quot;xqm&quot;: &quot;3&quot;, &quot;queryModel.showCount&quot;: &quot;15&quot; &#125;, method:&#x27;GET&#x27;,&#125;).then(result=&gt;&#123; console.log(result);&#125;) 可以看到我的http请求被拒绝了。而在Status中我们可以看到CORS error这是什么？ 什么是CORS?CORS（跨源资源共享）是一种机制，允许服务器指示浏览器允许来自不同源的请求。这通常用于保护资源，确保只有特定网站可以访问 API。那么为什么这里出现了CORS的错误呢？ 由于不同源首先要有CORS这个出现(而你用request请求就不会)就是因为我们是不同源。比如 12http://123.com:8080http://321.com:8080 这里就是host不一样(或者你端口不一样，http和https不一样)，这就是不同源，也就是说网站不能直接共享另一个网站的数据，除非另一个网站有其他配置。那么何为同源？比如 12http://123.com:8080http://123.com:8080/abab 那么它就和是同源的。因此，我现在的网站文件要么就是本地服务器源，要么就是file源，总之不和目标源一样。 为什么python的request请求就可以？由上一篇文章知道，我们的python是可以正常获取的。这是因为python不在浏览器中运行，它属于后端程序，不会触发preflight检测。 何为preflight如果你要通过这个网站得到目标网站的数据，首先网站不直接发送http请求，而是发送一个http option请求，然后目标网站的服务器会检查这个http option请求。这个过程就叫preflight。 预检查流程如果目标的服务器有配置这个来处理预检的 OPTIONS 请求，那么目标服务器就会发送一个CORS头请求，这个头请求包括： Access-Control-Allow-Origin：指定允许的源。如果该值与请求源匹配，浏览器会继续执行实际请求。 Access-Control-Allow-Methods：列出允许的方法（如 GET、POST）。 Access-Control-Allow-Headers：列出允许的自定义请求头。 可以看到目标服务器是可以指定允许的源，允许的方法还有允许的请求头。 然后你的浏览器接收到了这个CORS之后，会自己检查，如果符合的，就不会发送你的http请求（这也是在保护你的数据，总不能什么都不检查就把你的cookie什么发过去吧）。当然如果你的http请求都满足CORS的头请求，那么就会正常发送。 这里再看下我的请求： 再结合第一张图的404，可以看出并不是我的请求不满足CORS头请求，而是目标服务器根本没做接收option请求的配置。 另一种思路如果我们浏览器无法直接请求，那么我是不是可以通过先通过python请求并获取目标服务器数据，然后再将获取的数据部署到本地服务器，然后再让axios去请求本地服务器的数据呢？ 配置Flask我们这里直接使用Flask框架来简单的将json数据传入本地服务器，端口就写5000好了。 main文件代码如下： 12345678910111213141516171819202122232425from GetScoreData import send_to_serverfrom flask import Flask, jsonifyapp = Flask(__name__)@app.route(&#x27;/data&#x27;, methods=[&#x27;GET&#x27;])def get_data(): url = &quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html？doType=query&amp;gnmkdm=N305005&quot; headers = &#123; &quot;User-Agent&quot;: &quot;&quot;, &quot;Cookie&quot;: &quot;&quot; &#125; body = &#123; &quot;xnm&quot;: &quot;2023&quot;, &quot;xqm&quot;: &quot;3&quot;, &quot;queryModel.showCount&quot;: &quot;15&quot; &#125; data = send_to_server(url, headers, body) print(data) return jsonify(data)if __name__ == &quot;__main__&quot;: app.run(port=5000) 发送axios请求在JavaScript文件中发送请求： 123456axios(&#123; url:&#x27;http://127.0.0.1:5000/data&#x27;, method:&#x27;GET&#x27;,&#125;).then(result=&gt;&#123; console.log(result);&#125;) 但是这样可能还是有问题： 可以看到跟上文所说的一样，端口不一样也会触发preflight预检测，因此我们有两个思路： 更改端口号使其一致 配置CORS 如果配置CORS也非常方便，只需下载flask_cors库并在主文件中写下： 12from flask_cors import CORSCORS(app) # 允许所有来源访问 即可允许访问。 同样你也可以将端口改成5050，这样也可以成功访问数据。","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"一键爬取个人绩点并计算平均绩点的脚本","slug":"一键爬取个人绩点并计算平均绩点的脚本","date":"2024-10-19T03:37:36.000Z","updated":"2024-10-19T03:42:59.288Z","comments":true,"path":"2024/10/19/一键爬取个人绩点并计算平均绩点的脚本/","link":"","permalink":"https://bayeeaa.github.io/2024/10/19/%E4%B8%80%E9%94%AE%E7%88%AC%E5%8F%96%E4%B8%AA%E4%BA%BA%E7%BB%A9%E7%82%B9%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E7%BB%A9%E7%82%B9%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"","text":"一键爬取个人绩点并计算平均绩点的脚本不知各位有没有用过下图的教务管理系统： 虽然吧，你看着这个系统做的还不错，信息量非常足。但是其实我们学生并不关心什么课程代码，学年，学期这些信息，而且有个非常重要的点！它居然没有帮我们算平均绩点！这就导致每次学期结束，学校要统计综测的时候，都要用手指一个一个对着绩点按计算器，然后班长都要我们手动填表格，并让班长一个一个算出来分数，非常的让人蛋疼。 于是乎我就想弄一个脚本来帮我们直接刨析出各学期的绩点，并计算平均绩点、总绩点还有全年总平均绩点。 使用Fiddler进行代理实现网络抓包思路思路非常简单，通过Fiddler工具抓取每一次查询时接收的响应体，并找到响应体json文件中的信息，然后通过FiddlerScript(为JScript.NET语言)将响应体以txt文件形式保存到本地，然后通过python脚本解析txt文件使其可视化更强。 找到包及其绩点所在位置点击”查询“按钮，我们在Fiddler中时刻关注此时跳出的包，经过查找，在url为： 1https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005 的包中有含有jd(绩点)信息，因此我们来捕捉这个包。 配置FiddlerScript将json文件下载到本地打开FiddlerScript，找到OnBeforeResponse，然后输入下面JScript.NET代码： 1234if (oSession.uriContains(&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx&quot;)) &#123; oSession.utilDecodeResponse(); var fileName = &quot;C:\\\\Users\\\\yyn19\\\\Desktop\\\\college_score.txt&quot;; oSession.SaveResponseBody(fileName); oSession.uriContains：它检查当前会话（oSession）的url是否包含字符串&quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx&quot; oSession.utilDecodeResponse()：用于将响应体（如果它是经过编码的，比如gzip压缩）解码为人类可读的形式。因为在网络传输中，为了节省带宽，数据通常会被压缩。 我将其下载到了桌面，当然你要下载到别处也可以。 用python脚本读取单纯的用肉眼读十分的费力，这时候我们再借助一下python来解析json文件。在下面的path中填入你保存文件的位置，经过刨析，就可以得到各门成绩绩点和当前学期的平均绩点。 123456789101112path = &quot;C:\\\\Users\\\\yyn19\\\\Desktop\\\\college_score.txt&quot;sum_score = 0with open(path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: content = file.read() data = json.loads(content)for i in range(len(data[&#x27;items&#x27;])): print(data[&#x27;items&#x27;][i][&#x27;jd&#x27;]) sum_score += float(data[&#x27;items&#x27;][i][&#x27;jd&#x27;]) print(sum_score/float(len(data[&#x27;items&#x27;]))) 缺点 每一次运行脚本都需要手动点开各个学期的查询才能算出该学期的绩点平均值 需要Fiddler工具辅助 每一次都需要登录 于是我就想到用python自带的request方法来进行发送网络请求。 使用request库进行请求思路我们都知道一个http请求由以下几个部分组成： ‌请求行‌：包含请求方法（如GET、POST等）、URL地址和HTTP版本。例如，GET /index.html HTTP/1.1。 ‌请求头‌：包含了一系列键值对，用于传递附加信息，如客户端可接受的MIME类型、字符集、编码方式等。常见的请求头包括Accept、Accept-Charset、Content-Length等‌。 ‌请求体‌：包含要提交给服务器的数据。对于GET请求，请求体为空；对于POST请求，请求体包含提交的数据‌。 因此，我们只需要通过浏览器自带的抓包工具，找到url等一系列请求头和请求体(有时不需要)就可以发出http请求从而拿到数据。 发送请求首先我们先写入请求头： 12345url = &quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot;headers = &#123; &quot;User-Agent&quot;: &quot;你自己的User-Agent&quot;, &quot;Cookie&quot;: &quot;你自己的cookie&quot;&#125; GET请求可以吗？然后我们直接使用GET方法发送请求： 1234567import requestsurl = &quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot;headers = &#123; &quot;User-Agent&quot;: &quot;你自己的User-Agent&quot;, &quot;Cookie&quot;: &quot;你自己的cookie&quot;&#125;response = requests.get(url,headers) 这时候我们发现： 竟然得到的是这个网页的前端jquery文件，很显然这不是我们需要的答案。因此我们要选用POST请求。 选用POST请求由前面我们知道POST请求包含了请求体，因此更能发送完善的请求来针对性的得到数据，这里我们就要再设置一个body来加入请求： 12345body = &#123; &quot;xnm&quot;: &quot;2023&quot;, &quot;xqm&quot;: &quot;3&quot;, &quot;queryModel.showCount&quot;: &quot;15&quot;&#125; 当然这里的值会随着学期和学年改变，之后完整代码用双重for循环来遍历。 然后调用request中的session，发出POST方法，并将str转化成json文件。 123session = requests.Session()response = session.post(url, headers=headers, data=body).textresponse_json = json.loads(response) 然后我们就得到了很长一串数据，然后不断的完善修饰数据即可。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import jsonimport requestsdef send_to_server(url, headers, body): session = requests.Session() response = session.post(url, headers=headers, data=body).text response_json = json.loads(response) return response_jsondef print_data(response, sum_score): length = len(response[&#x27;items&#x27;]) for t in range(length): subject_score = str(round(float(response[&#x27;items&#x27;][t][&#x27;jd&#x27;]), 1)) subject = response[&#x27;items&#x27;][t][&#x27;kcmc&#x27;] print(subject + &quot;：&quot; +subject_score) sum_score += float(response[&#x27;items&#x27;][t][&#x27;jd&#x27;]) avg_score = round(round(sum_score, 3) / float(len(response[&#x27;items&#x27;])), 2) avg_xq_score = str(round(round(sum_score, 3) / float(len(response[&#x27;items&#x27;])), 2)) sum_xq_score = str(round(sum_score, 2)) print(&quot;该学期总绩点为&quot; + sum_xq_score + &quot;，平均绩点为&quot; + avg_xq_score) print(&quot;----------------------------&quot;) return avg_scoreclass GetScore(): def __init__(self): self.url = &quot;https://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxXsgrcj.html?doType=query&amp;gnmkdm=N305005&quot; self.headers = &#123; &quot;User-Agent&quot;: &quot;你自己的User-Agent&quot;, &quot;Cookie&quot;: &quot;你自己的cookie&quot; &#125; self.xq_num = [&quot;3&quot;, &quot;12&quot;, &quot;16&quot;] self.xn_num = [&quot;2023&quot;, &quot;2024&quot;, &quot;2025&quot;, &quot;2026&quot;] self.body = &#123; &quot;xnm&quot;: &quot;2023&quot;, &quot;xqm&quot;: &quot;3&quot;, &quot;queryModel.showCount&quot;: &quot;15&quot; &#125; def analysis_xq(self, length, i, j): if length == 0: return 0 elif self.xq_num[j] == &quot;3&quot;: print(self.xn_num[i] + &quot;第一学年&quot;) elif self.xq_num[j] == &quot;12&quot;: print(self.xn_num[i] + &quot;第二学年&quot;) elif self.xq_num[j] == &quot;16&quot;: print(self.xn_num[i] + &quot;第三学年&quot;) def get_data(self): all_avg_score = all_len = sum_score = 0 for i in range(len(self.xn_num)): for j in range(len(self.xq_num)): self.body[&quot;xnm&quot;] = self.xn_num[i] self.body[&quot;xqm&quot;] = self.xq_num[j] response = send_to_server(self.url, self.headers, self.body) length = len(response[&#x27;items&#x27;]) if self.analysis_xq(length, i, j) == 0: break else: all_len += 1 all_avg_score += print_data(response, sum_score) all_avg_score_str = str(round(all_avg_score / all_len, 2)) print(&quot;全年总平均绩点为：&quot; + all_avg_score_str)if __name__ == &quot;__main__&quot;: score = GetScore() score.get_data() 效果展示","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2024-10-17T09:06:19.000Z","updated":"2024-10-17T09:07:28.476Z","comments":true,"path":"2024/10/17/Java多线程/","link":"","permalink":"https://bayeeaa.github.io/2024/10/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"Java多线程线程线程是计算机程序中执行的最小单位，是进程内的一个执行路径。简单来说，一个进程可以包含多个线程，它们共享进程的资源，比如内存和文件句柄，但每个线程有自己独立的栈和程序计数器。 线程的特点： 轻量级：线程的创建和销毁比进程更快，资源占用更少。 共享资源：同一进程中的线程可以共享数据和资源，方便数据传递。 并发执行：多个线程可以并发执行，充分利用多核处理器，提高程序的效率。 独立性：虽然线程共享资源，但一个线程的崩溃不会直接影响到其他线程。 编写程序的两种方式通过继承Thread类 构造方法 Thread(): 创建一个新线程。 Thread(Runnable target): 创建一个新线程并指定要执行的目标。 Thread(String name): 创建一个新线程并指定线程名称。 Thread(Runnable target, String name): 创建一个新线程，指定目标和线程名称。 启动与运行 void start(): 启动线程，调用 run() 方法。 void run(): 线程执行的代码，通常由 Runnable 接口实现。 线程状态管理 void join(): 等待线程结束。 void join(long millis): 等待指定时间或直到线程结束。 void interrupt(): 中断线程。 boolean isAlive(): 检查线程是否仍在运行。 线程信息 String getName(): 获取线程名称。 int getPriority(): 获取线程优先级。 void setPriority(int newPriority): 设置线程优先级。 Thread.State getState(): 获取线程当前状态。 线程调度 static void sleep(long millis): 使当前线程睡眠指定时间。 static void yield(): 暂停当前线程，让其他线程有机会执行。 ​ 6. 线程组 ThreadGroup getThreadGroup(): 获取线程所属的线程组。 使用实例： 1234567891011121314151617181920public class thread_test extends Thread&#123; public thread_test(String name)&#123; //构造函数 super(name); //调用Tread的构造方法，把name传递给父类 System.out.println(name+&quot;创建成功&quot;); &#125; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName()); Thread.yield(); &#125; &#125; public static void main(String[] args) &#123; thread_test t1 = new thread_test(&quot;1&quot;); thread_test t2 = new thread_test(&quot;2&quot;); t1.start(); t2.start(); &#125;&#125; 第一次运行： 123456789101创建成功2创建成功111222Process finished with exit code 0 第二次运行： 123456789101创建成功2创建成功122211Process finished with exit code 0 可以看到两次运行的结果是不同的，这是因为两个线程是同时进行的，不分快慢。 通过Runnable接口方法如果一个类已经继承了其他类，由于Java是单继承的，所以不能再继承Thread类，需要通过实现Runnable接口来建立线程类。 定义线程类载体，并编写run()方法12345class test implements Runnable &#123; public void run()&#123; //具体内容 &#125;&#125; 建立线程载体对象1test obj = new test(); 利用线程载体对象建立线程1Thread t = new Thread(); 启动线程1t.start(); 实例12345678910111213141516171819202122public class thread_test implements Runnable&#123; String name; public thread_test(String name)&#123; this.name = name; System.out.println(name+&quot;创建成功&quot;); &#125; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(name); //这个name是这个类里的name Thread.yield(); &#125; &#125; public static void main(String[] args) &#123; thread_test r1 = new thread_test(&quot;1&quot;); thread_test r2 = new thread_test(&quot;2&quot;); Thread t1 = new Thread(r1); //需要再使用Thread类来启动线程 Thread t2 = new Thread(r2); t1.start(); t2.start(); &#125;&#125; Thread构造方法 默认构造方法 1Thread thread = new Thread(); 创建一个新的线程实例，但没有指定任务。 指定Runnable对象 1Thread thread = new Thread(Runnable target); 通过实现Runnable接口的对象创建线程。 示例： 12Runnable myRunnable = new MyRunnable();Thread thread = new Thread(myRunnable); 指定Runnable对象和线程名称 1Thread thread = new Thread(Runnable target, String name); 创建一个线程，并为它指定一个名称。 示例： 1Thread thread = new Thread(myRunnable, &quot;MyThread&quot;); 指定线程名称和线程组 1Thread thread = new Thread(ThreadGroup group, Runnable target, String name); 创建一个线程，并将其加入到指定的线程组。 指定线程组、Runnable对象和线程名称 1Thread thread = new Thread(ThreadGroup group, Runnable target, String name, long stackSize); 创建一个线程，指定线程组、Runnable任务、名称以及栈大小。 指定优先级 虽然构造方法中不直接设置优先级，但可以在创建线程后使用setPriority(int priority)方法： 1thread.setPriority(Thread.MAX_PRIORITY); 生命周期线程创建后并不会执行，需要调用start方法才能启动线程，启动了之后也不一定马上运行。线程从创建到结束是有一个过程的，这个过程就称为线程的生命周期。 这里我们可以看到和进程的生命周期类似，但是 主要区别 资源：进程有独立的内存空间，线程共享同一进程的资源。 管理：进程的创建和管理开销相对较大，线程则相对轻量。 调度：线程调度通常比进程调度更频繁。 优先级优先级是线程获得CPU调度的优先度。优先级高的线程排在线程队列的前端，优先获得处理机的控制权，可以在短时间内进入运行状态。在Java中，线程的优先级是一个整型值，用于表示线程的相对重要性。线程优先级的设置可以影响线程调度的顺序，但并不保证。优先级的范围通常是从1到10，Java提供了以下常量来表示优先级： Thread.MIN_PRIORITY（1） Thread.NORM_PRIORITY（5） Thread.MAX_PRIORITY（10） 设置线程优先级你可以通过 setPriority(int newPriority) 方法来设置线程的优先级，例如： 12Thread thread = new Thread();thread.setPriority(Thread.MAX_PRIORITY); 获取线程优先级使用 getPriority() 方法可以获取线程的优先级： 1int priority = thread.getPriority(); 实例12345678910111213141516171819public class PriporityDemo extends Thread&#123; public void run()&#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; 第 &quot;+(i+1)+&quot;次运行&quot;); Thread.yield(); //让出cpu控制权 &#125; &#125; public static void main(String[] args) &#123; PriporityDemo t1 = new PriporityDemo(); PriporityDemo t2 = new PriporityDemo(); PriporityDemo t3 = new PriporityDemo(); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.NORM_PRIORITY); t3.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); t3.start(); &#125;&#125; 输出123456789101112131415Thread-0 第 1次运行Thread-0 第 2次运行Thread-0 第 3次运行Thread-0 第 4次运行Thread-1 第 1次运行Thread-1 第 2次运行Thread-1 第 3次运行Thread-1 第 4次运行Thread-2 第 1次运行Thread-0 第 5次运行Thread-1 第 5次运行Thread-2 第 2次运行Thread-2 第 3次运行Thread-2 第 4次运行Thread-2 第 5次运行 可以看到，虽然并不是严格的按等级来运行排序，但是大致可以看出，优先级越高的获得CPU的次数越多。 线程的调度线程调度是操作系统或Java虚拟机（JVM）负责管理和安排线程执行的过程。它决定了哪些线程可以运行以及它们运行的顺序。通常我们的计算机只有一个CPU，线程只有得到CPU时间片才可以执行命令。调度模式其实有两种：分时调度模式和抢占调度模式。而Java的线程调度机制是基于抢占式调度的，下面是一些关键概念： 调度算法 Java的线程调度依赖于底层操作系统的调度算法，常见的调度算法包括： 时间片轮转：每个线程被分配一个时间片，时间片用完后，操作系统会切换到下一个线程。 优先级调度：根据线程的优先级来决定调度顺序，优先级高的线程有更高的机会获得CPU时间。 公平调度：确保所有线程都有机会运行，避免某些线程长时间等待。 线程状态 线程的状态影响调度的方式，主要状态包括： 新建状态（New）：线程被创建，但尚未启动。 就绪状态（Runnable）：线程已准备好运行，等待操作系统分配CPU。 运行状态（Running）：线程正在执行。 阻塞状态（Blocked）：线程因等待某种资源而暂停。 等待状态（Waiting）：线程等待其他线程的通知或特定条件。 死亡状态（Terminated）：线程已完成执行。 优先级的影响 如前所述，线程的优先级可能会影响调度，但具体效果依赖于JVM和操作系统的实现。在许多系统中，高优先级线程会在就绪队列中获得优先权，但并不保证一定先执行。 Thread.sleep() 和 yield() Thread.sleep(milliseconds)：使当前线程暂停指定时间，允许其他线程运行。 Thread.yield()：提示调度器当前线程愿意让出CPU，允许其他同优先级的线程执行。 使用线程池 在实际应用中，使用线程池（如 ExecutorService）可以更有效地管理线程调度，减少线程创建和销毁的开销。 加锁及死锁加锁线程加锁是用于控制对共享资源的访问，以防止线程间的竞争条件和数据不一致。Java提供了多种方式来实现加锁，最常见的是使用 synchronized 关键字和 Lock 接口。以下是主要概念： 1. synchronized (同步)关键字 实例方法加锁：锁定对象的实例，确保同一时间只有一个线程能执行该方法。 123public synchronized void method() &#123; // 线程安全的代码&#125; 静态方法加锁：锁定类的对象，确保同一时间只有一个线程能执行该方法。 123public static synchronized void staticMethod() &#123; // 线程安全的代码&#125; 代码块加锁：可以更灵活地锁定特定的对象。 12345public void method() &#123; synchronized (this) &#123; // 线程安全的代码 &#125;&#125; 2. Lock (上锁)接口Lock 接口提供了比 synchronized 更灵活的锁机制。常用的实现是 ReentrantLock。 获取锁： 1234567Lock lock = new ReentrantLock();lock.lock(); // 获取锁try &#123; // 线程安全的代码&#125; finally &#123; lock.unlock(); // 确保释放锁&#125; 公平与非公平锁：可以创建公平锁，确保按请求顺序获取锁，或非公平锁，可能会导致某些线程饿死。 线程死锁是指两个或多个线程在执行过程中，因为争夺资源而造成一种互相等待的状态，导致它们无法继续执行。死锁是一种严重的并发问题，可能导致程序停滞不前。 死锁发生死锁通常需要满足以下四个条件： 互斥条件：至少有一个资源必须处于非共享状态，即一个资源只能被一个线程占用。 保持与等待：一个线程至少持有一个资源，并等待获取其他资源。 不剥夺条件：已经获得的资源在使用完之前不能被强行剥夺。 环路等待：存在一组线程，每个线程持有至少一个资源并等待另一个线程持有的资源，从而形成环路。 示例以下是一个简单的死锁示例： 1234567891011121314151617181920212223242526272829303132333435public class DeadlockExample &#123; private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; synchronized (lock1) &#123; System.out.println(&quot;Thread 1: Holding lock 1...&quot;); try &#123; Thread.sleep(100); // 模拟处理 &#125; catch (InterruptedException e) &#123;&#125; System.out.println(&quot;Thread 1: Waiting for lock 2...&quot;); synchronized (lock2) &#123; System.out.println(&quot;Thread 1: Acquired lock 2!&quot;); &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; synchronized (lock2) &#123; System.out.println(&quot;Thread 2: Holding lock 2...&quot;); try &#123; Thread.sleep(100); // 模拟处理 &#125; catch (InterruptedException e) &#123;&#125; System.out.println(&quot;Thread 2: Waiting for lock 1...&quot;); synchronized (lock1) &#123; System.out.println(&quot;Thread 2: Acquired lock 1!&quot;); &#125; &#125; &#125;); thread1.start(); thread2.start(); &#125;&#125; 输出1234Thread 1: Holding lock 1...Thread 2: Holding lock 2...Thread 2: Waiting for lock 1...Thread 1: Waiting for lock 2... 可以看到Thread1获得了lock1的锁，休眠了100ms。此时Thread2获得了lock2的锁，然后休眠100ms。Thread1休眠结束后需要lock2的锁而Thread2休眠结束后需要lock1的锁，但是各自需要的锁都被对方锁把持着，这就陷入了僵局。 死锁检测与预防 避免死锁： 资源有序分配：对资源进行排序，确保线程按固定顺序获取资源。 使用尝试锁：使用 tryLock() 方法尝试获取锁，如果失败，则可以选择不等待。 减少持锁时间：尽量减少持有锁的时间，避免长时间占用资源。 检测死锁： Java提供的 ThreadMXBean 可以用于检测死锁，可以查看当前线程状态并检测死锁情况。 12345678910111213141516171819import java.lang.management.ManagementFactory;import java.lang.management.ThreadInfo;import java.lang.management.ThreadMXBean;public class DeadlockDetector &#123; public static void main(String[] args) &#123; ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); long[] deadlockedThreads = threadMXBean.findDeadlockedThreads(); if (deadlockedThreads != null) &#123; for (long threadId : deadlockedThreads) &#123; ThreadInfo threadInfo = threadMXBean.getThreadInfo(threadId); System.out.println(&quot;Deadlocked thread: &quot; + threadInfo.getThreadName()); &#125; &#125; else &#123; System.out.println(&quot;No deadlocks detected.&quot;); &#125; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"进程与线程(理论篇)","slug":"进程与线程-理论篇","date":"2024-10-02T06:37:35.000Z","updated":"2024-10-02T06:40:48.387Z","comments":true,"path":"2024/10/02/进程与线程-理论篇/","link":"","permalink":"https://bayeeaa.github.io/2024/10/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%90%86%E8%AE%BA%E7%AF%87/","excerpt":"","text":"进程与线程(理论篇)多道程序设计多道程序设计(multi-programming)是操作系统所采用的最基本、最重要的技术，其根本目的是提高整个计算机系统的效率。 1吞吐量 = 作业道数/全部处理时间 这里的吞吐可以用来衡量系统效率。 单道程序设计的问题所谓单道程序设计，就是一次只允许一个程序进入系统的程序设计方法。显而易见，这样就有一个严重的缺点：资源利用率低。 设备资源利用率低：计算机系统有许多外围设备，在单道程序中，一次只能使用外围设备中的一个子集，而未被使用的设备会被浪费。 内存资源利用率低：随着硬件技术的提升，内存容量不断扩大，如果单道程序使用这么大的内存，其内存浪费空间是惊人的。 处理器资源利用率低：单道程序设计的方式导致CPU在I&#x2F;O操作和其他阻塞期间的空闲，影响了整体资源利用率。 单道程序设计还有个缺点是不能表达程序内在并行性。比如Windows中使用Word文档时，在打字时需要有下面操作：①在缓冲区交互式地编辑用户输入；②对缓冲区内用户输入内容进行语法检查；③将缓冲区的内容定时保存到磁盘上。显然如果操作一频繁，这三道程序是无法安排执行顺序的，它们其内在就是并行的。 多道程序设计的提出多道程序设计的提出源于对计算资源利用率的提升需求，尤其是在20世纪60年代初期，计算机处理速度迅速提高，而I&#x2F;O设备的速度相对较慢。为了解决单道程序设计中的低资源利用率和高等待时间问题，研究人员和工程师们开发了多道程序设计。 这种设计允许多个程序同时驻留在内存中，使得CPU可以在一个程序等待I&#x2F;O操作时，切换到另一个程序继续执行，从而充分利用处理器时间。通过这种方式，多道程序设计实现了更高的并行性和资源利用率，减少了空闲时间，并提高了系统的整体效率。最终，这种设计成为现代操作系统的基础，推动了计算机技术的发展。 相应与单道程序设计，它对以下方面都有所提升： 设备资源利用率提高 内存资源利用率提高 处理器资源利用率提高 多道程序设计的问题多道程序设计改善了系统资源的使用情况，从而增加了吞吐量，提高系统效率。但是也带来了新的问题：资源竞争。 内存管理复杂性：随着多个程序同时驻留在内存中，内存分配和管理变得复杂。需要有效地管理内存，以防止内存泄漏、碎片化等问题。 上下文切换开销：频繁地在多个程序之间切换会消耗CPU时间和系统资源，尤其是在上下文切换（保存和恢复程序状态）频繁的情况下，这可能导致性能下降。 资源竞争：多个程序同时请求同一资源（如I&#x2F;O设备、CPU时间等），可能导致竞争和冲突，进而影响系统的稳定性和性能。 调度算法复杂性：为了公平和高效地分配CPU时间，需要设计复杂的调度算法。这些算法需要考虑优先级、响应时间、周转时间等多种因素，增加了系统设计的复杂性。 错误和故障传播：一个程序的错误可能会影响到整个系统的稳定性，特别是在多道程序设计中，程序之间的相互影响和依赖关系可能导致更严重的问题。 调试和测试难度：在多道程序环境中，调试和测试变得更加困难，因为多个程序的交互可能导致难以重现的错误。 进程的引入由上述我们知道，在多道程序系统中运行的程序是一个时断时续的一个状态，其运作规律：一个程序获得处理器资源后向前推进，当它未得到某种资源时就暂停下来。 1推进→暂停→推进→暂停→... 当程序暂停时，需要将其现场的信息作为断点保护起来，以便以后再次推进时能够恢复上次暂停时的现场信息并从断点处开始继续执行。这样，在多道程序设计系统中运行的程序只需要一个保存断点现场信息的区域，而这个区域并不是程序的组成部分，因此就需要一个能够更准确地描述多道程序系统中执行程序的术语，这就是进程(process)。 状态及状态转换进程的状态： 运行态：进程占有处理器资源，正在运行。 就绪态：进程本身具备运行条件，但是由于处理器的数量少于可运行进程的数量，暂未投入运行 阻塞态：也称等待态、挂起态、睡眠态。进程本身不具备运行条件，即使分给其处理器也不能运行。进程正在等待一个事情发生，如等待某一资源被释放，等待与该进程相关的数据传输完成信号等。 状态转换关系如下图： 控制块进程控制块（Process Control Block, PCB）是操作系统用于管理进程的重要数据结构。它包含了一个进程在执行期间所需的所有信息，主要包括以下内容： 进程标识符：每个进程的唯一ID，帮助系统区分不同进程。 进程状态：指示进程当前的状态，如运行、就绪、阻塞等。 程序计数器：记录进程下一条将要执行的指令的地址。 CPU寄存器：保存进程执行时的寄存器状态，以便在上下文切换时恢复。 内存管理信息：包括进程的地址空间、页表等信息，帮助操作系统管理内存。 调度信息：与进程调度相关的优先级、调度队列指针等信息。 I&#x2F;O状态信息：记录进程所需的I&#x2F;O设备及其状态，帮助管理I&#x2F;O操作 组成与上下文进程由两个部分组成，即进程控制块和程序，其中程序包括代码和数据等。 程序代码：进程所执行的指令，通常存储在内存中。 进程数据：用于存储程序运行时的数据，包括全局变量、局部变量和堆数据等。 进程控制块（PCB）：前面提到的用于管理进程的结构，包含进程的状态、标识符、寄存器信息等。 堆栈：用于存放函数调用时的局部变量和返回地址，支持程序的递归和函数调用。 关于上下文，上下文是指进程在执行时的状态信息，主要包括： CPU寄存器：当前寄存器的值，保存进程执行时的状态。 程序计数器：指向进程下一条要执行的指令。 内存映射：当前进程使用的内存空间信息。 在上下文切换时，操作系统会保存当前进程的上下文（如寄存器和程序计数器），然后加载下一个进程的上下文，从而实现多进程的切换与执行。这使得多个进程能够在同一CPU上并发运行。 队列进程的队列是操作系统中用于管理和调度进程的重要数据结构，通常由多种不同类型的队列组成。以下是常见的进程队列及其功能： 就绪队列： 包含所有准备好运行但尚未被CPU执行的进程。 操作系统调度程序从此队列中选择进程进行调度。 阻塞队列（或等待队列）： 包含正在等待某些事件（如I&#x2F;O操作完成、信号等）的进程。 当事件发生时，相关进程会从阻塞队列中移除并进入就绪队列。 运行队列： 这个概念通常指的是当前正在使用CPU的进程。 在多处理器系统中，可能存在多个运行队列，每个CPU都有自己的运行队列。 新建队列： 包含刚创建但尚未进入就绪状态的进程。 这些进程正在初始化和分配资源。 终止队列： 包含已完成执行的进程，等待操作系统回收资源。 这些进程将被移除，相关的PCB也会被释放。 优先级队列： 在某些调度算法中，进程根据优先级被放入不同的队列。 高优先级进程会比低优先级进程更早被调度。 创建 创建过程 系统调用：进程创建通常通过系统调用实现。在Unix&#x2F;Linux系统中，常用的系统调用是fork()。在Windows系统中，常用的调用是CreateProcess()。 复制资源：在使用fork()时，操作系统会创建一个新的进程控制块（PCB）并复制父进程的资源，包括内存空间、打开的文件描述符、信号处理等。 返回值：fork()返回值有两种情况： 在父进程中返回子进程的进程ID。 在子进程中返回0。 初始化新进程 独立的资源：虽然子进程复制了父进程的资源，但它们是独立的。对子进程的修改不会影响父进程，反之亦然。 执行新程序：子进程可以使用exec()系列系统调用来加载并执行一个新的程序，这个过程将替换当前进程的映像。 进程树 进程间关系：进程以树形结构组织，父进程可以创建多个子进程，每个子进程也可以创建自己的子进程，形成进程树。 进程ID：每个进程都有一个唯一的进程ID（PID），它用于标识和管理进程。 进程的终止 子进程的终止：子进程可以通过调用exit()系统调用结束自己，操作系统会清理其资源，并将其状态信息保留在父进程中，以便父进程可以读取（通过wait()系统调用）。 孤儿和僵尸进程： 孤儿进程：如果父进程先于子进程终止，子进程会成为孤儿进程，操作系统会将其父进程改为init进程（PID为1）。 僵尸进程：如果子进程结束，但父进程未调用wait()来收集其状态信息，子进程会变成僵尸进程，保留在系统中以等待父进程处理。 进程与程序的区别程序 定义：程序是一个静态的代码集合，它是由计算机语言编写的指令的集合，通常以文件的形式存储在磁盘上。程序本身并不执行，它只是一组指令和数据的描述。 作用：程序的作用是定义计算机执行特定任务的步骤和逻辑。程序可以是任何形式的应用，例如文本编辑器、浏览器、游戏等。 进程 定义：进程是程序在执行时的一个动态实例，它是程序运行时的状态，包括程序代码、程序计数器、寄存器内容、变量、堆栈、内存分配等。每个进程都有其自己的地址空间和系统资源。 作用：进程是操作系统管理和调度的基本单位。它代表了程序在计算机上运行时的状态，使得多个程序可以同时运行而不相互干扰。 主要区别 状态： 程序是静态的，而进程是动态的。 存在形式： 程序存在于存储介质上（如硬盘），而进程在内存中运行。 资源管理： 程序本身不需要资源，进程则需要CPU、内存等资源来执行。 调度与执行： 程序在需要时被加载成进程，而进程可以被调度执行、挂起或终止。 线程与轻进程早期的操作系统是基于进程的，一个进程中只包含一个执行流，进程是处理器调度的基本单位。当处理器由一个进程切换到另一个进程时，整个上下文都要发生变化，系统开销比较大，相关进程耦合度差。 在许多应用中，一些执行流之间具有内在逻辑关系，设计相同的代码或数据。如果将这些执行流放在同一进程的框架下，则这些执行流之间的切换便不涉及地址空间的变化，这就是线程思想的由来。 线程线程是计算机程序中的一个基本执行单元，它是进程中的一个独立运行的子任务。线程在同一进程内共享内存空间和资源，但拥有自己的执行上下文。以下是线程的一些关键概念： 轻量级进程：线程常被称为轻量级进程，因为它们比进程更轻便，创建和销毁的开销较小。 并发性：线程允许程序同时执行多个任务，这样可以提高程序的响应性和资源利用率。例如，用户界面可以在一个线程中运行，而后台任务（如数据处理）可以在另一个线程中进行。 共享资源：同一进程中的线程可以共享全局变量和堆内存，便于数据交换，但也需要小心处理以避免数据竞争和不一致性。 线程状态：线程的生命周期包括多个状态，如新建、就绪、运行、阻塞和终止，操作系统根据这些状态调度线程的执行。 同步和互斥：由于多个线程可能会同时访问共享资源，因此需要使用同步机制（如锁、信号量等）来防止数据不一致和竞争条件。 调度：操作系统通过线程调度算法决定哪个线程获得 CPU 的使用权，以实现高效的多任务处理。 优先级：线程可以设置优先级，以影响它们获得 CPU 时间的顺序。 线程的结构线程的结构主要包含以下几个核心部分： 线程标识符（Thread ID）： 每个线程都有一个唯一的标识符，用于区分不同的线程。 程序计数器（Program Counter, PC）： 记录线程当前执行的指令地址。每个线程都有自己的程序计数器，以独立追踪执行位置。 堆栈（Stack）： 每个线程拥有自己的堆栈，用于存储局部变量、方法调用的参数、返回地址等信息。堆栈在函数调用和返回时动态变化。 线程状态（Thread State）： 线程可以处于不同状态，如新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Terminated）。这些状态反映了线程的生命周期。 优先级（Priority）： 每个线程可以设置优先级，影响其被调度执行的顺序。操作系统使用优先级来管理线程竞争 CPU 时间。 共享资源： 同一进程内的线程共享全局变量和堆内存，这使得线程之间可以高效通信，但也需要注意同步问题。 同步机制： 为了避免数据竞争和确保数据一致性，线程间需要使用同步机制，如互斥锁、读写锁和信号量等。 线程本地存储（Thread Local Storage, TLS）： 一些数据可以为每个线程单独存储，避免线程间的干扰和数据共享。 注意图中的“逻辑寄存器”，这是想强调在单CPU系统中，硬件寄存器只有一套，可以理解为每个进程有一组虚拟的寄存器。 控制块线程控制块（Thread Control Block, TCB）是操作系统用于管理线程的重要数据结构。它包含了关于线程的关键信息，具体包括： 线程标识符（Thread ID）：唯一标识该线程。 线程状态：记录线程的当前状态（如就绪、运行、阻塞等）。 程序计数器（Program Counter, PC）：指向当前执行的指令地址。 堆栈指针：指向该线程的堆栈顶部，用于管理线程的局部变量和函数调用。 优先级：线程的优先级信息，用于调度。 上下文信息：包括寄存器内容、调度信息等，确保线程切换时能够正确恢复状态。 共享资源信息：描述该线程访问的共享资源，以管理同步和互斥。 调度信息：与调度算法相关的数据，用于管理线程的执行顺序。 实现线程有两种实现方式：在目态实现的用户级别线程，在管态实现的核心级别线程。 用户级线程（User-Level Threads, ULT） 管理方式：线程的创建和管理在用户空间进行，操作系统不直接感知这些线程。 优点：上下文切换开销较小，因为切换只涉及用户态的操作；线程的创建和销毁速度快。 缺点：操作系统无法调度用户级线程，如果一个线程进入阻塞状态，整个进程都会被阻塞；无法充分利用多核处理器，因为操作系统只看到进程，不了解内部线程。 内核级线程（Kernel-Level Threads, KLT） 管理方式：线程的创建、管理和调度由操作系统内核完成，每个线程都有自己的内核控制块。 优点：操作系统能够识别和调度每个线程，可以在多个核心上并行执行，提高性能；如果一个线程阻塞，其他线程仍可继续运行。 缺点：上下文切换开销较大，因为涉及内核态和用户态之间的切换；创建和销毁线程的成本也较高。 混合线程（Hybrid Threads） 管理方式：结合用户级线程和内核级线程的优势，通常采用多线程模型，如轻量级进程（LWP）。 优点：用户级线程的管理提供了灵活性和快速切换，而内核级线程的调度能力使得可以有效利用多核处理器。 实现：用户级线程在用户空间管理，而内核可以调度多个用户级线程至内核级线程，达到更好的性能和资源利用。 应用 并行处理 在计算密集型任务中，线程可以同时执行多个计算任务，提高整体处理速度。例如，在科学计算、图像处理和数据分析等领域，线程可以分担复杂的计算任务。 响应性提升 在用户界面（UI）应用中，使用线程可以保持界面的响应性。例如，长时间运行的任务可以在后台线程中执行，使得主线程可以继续处理用户输入。 服务器应用 在网络服务器（如Web服务器、数据库服务器）中，线程通常用于处理多个客户端请求。每个请求可以分配一个线程，使得服务器能够并发处理多个连接，提高吞吐量和响应速度。 实时系统 在实时应用中，线程可以根据优先级调度，确保高优先级任务及时响应。这在嵌入式系统、工业控制和金融交易系统中尤为重要。 数据处理 在大数据处理和流处理应用中，线程可以用于并行读取、处理和存储数据。例如，MapReduce框架利用多线程来并行处理大量数据。 游戏开发 在游戏开发中，线程用于管理多个并发任务，如渲染、物理计算和输入处理，提升游戏的性能和流畅度。 多媒体应用 在视频和音频处理应用中，线程可以并行处理音视频流，确保播放和处理的实时性。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bayeeaa.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统概述","slug":"操作系统概述","date":"2024-09-24T09:02:27.000Z","updated":"2024-09-27T01:52:56.315Z","comments":true,"path":"2024/09/24/操作系统概述/","link":"","permalink":"https://bayeeaa.github.io/2024/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"操作系统概述操作系统(operation system,OS)是一个最基本也是最重要的系统软件。从虚拟机的角度来看，软件是分层次的。系统软件位于底层，应用软件位于最高层。 当我们打开资源监视器可以发现一个计算机在工作的时候不仅包括正在运行的软件，还包括许多下层系统进程在工作，我们软件的运行离不开这些进程的工作。 作用有以下两个重要作用： 管理系统中的各种资源：在计算机系统中同时有多个程序在执行。这些程序在执行过程中会要用到系统中的各种资源。比如当程序1和程序2都要用到同一个地址的打印机进行输出，这就产生了冲突，这就需要一个“资源仲裁者“来负责在各个程序之间的调度，从而提高资源运行效率。 为用户提供友好的界面：我们知道早期的计算机是没有图形界面的，如果要操作就非常的繁琐，如果需要编写一个c语言程序是相当困难的。有了操作系统之后，我们只需要在终端上输入几行代码就可以完成运行。随着商业化发展，操作系统提供了图形用户界面(graphic user interface, GUI)，使得计算机的操作更加简单，方便。 特性操作系统也是一个程序，其主要有4个特性： 并发性(concurrency) 共享性(sharing) 异步性(asynchronous) 虚拟性(virtuality) 并发性所谓并发就是计算机系统中同时存在多个程序。具体可以体现在下面3个方面： 用户程序与用户程序之间并发执行； 用户程序与操作系统之间并发执行； 操作系统与操作系统之间并发执行。 并发与并行的区别程序并行要求微观上的同时，就是在同一个时刻有多个程序同时向前推进。 程序并发则是只需要在宏观上多个程序都在向前推进。 显然，要实现程序并行必须要有多个处理器，但是在单处理器环境中可以实现程序并发。这是由于并发执行的程序时按照某种次序交替地获得处理器并运行的。由于处理器的速度很快，因此从微观上看，这些程序都是在向前推进的。这些程序仿佛都有属于自己的处理器，即虚处理器。 共享性所谓资源共享，其实就是操作系统与多个用户程序公用系统中的各种资源，这种共享是在操作系统下控制实现的。对于一个给定的计算机系统来说，它的资源配置情况是相对固定的，而程序对于资源的需求则是变化的。操作系统要掌握系统中当前资源的使用情况并据此决定各个程序进入系统的次序以及使用资源的次序。 异步性在操作系统之上，宏观上同时运行的程序有多个，这些程序是交替执行的。异步的反义词即同步，一个程序的执行并不是一直都顺利的，有时候会发生中断并切换到另一端操作系统程序。 虚拟性利用某种技术把一个物理实体变为若干个逻辑实体。例如：为在单处理器系统中同时运行多个程序，操作系统把一个实体的CPU改造成多个虚拟的CPU，每个用户仿佛拥有一个属于自己的CPU。 分类 多道批处理操作系统：多道批处理系统允许多个作业（程序）同时存储在内存中，并通过操作系统的管理，交替在CPU上执行。这提高了CPU的利用率和系统吞吐量。 分时操作系统：分时系统允许多个用户通过各自的终端同时访问计算机系统，每个用户感觉像是独占系统资源。系统通过时间片轮转等方式公平地分配CPU时间给各个用户。 实时操作系统：实时操作系统（RTOS）设计用于处理对时间要求极为严格的任务。它确保关键操作能够在给定的时间限制内完成，常用于航空航天、工业控制等领域。 通用操作系统：通用操作系统是一种没有明确特定应用领域的操作系统，如Windows、Linux等，它们支持广泛的应用程序和多样化的用户群体。 单用户操作系统：单用户操作系统一次只允许一个用户访问系统资源。这种系统通常用于个人计算机，如早期的DOS系统。 网络操作系统：网络操作系统（NOS）负责管理网络上的硬件和软件资源，提供网络通信、资源共享和分布式处理等服务。 分布式操作系统：分布式操作系统管理分布在不同计算机上的资源，这些计算机通过网络相互连接，形成一个逻辑上统一的系统。 多处理操作系统：多处理操作系统能够管理多个CPU（或处理器核心），通过并行或并发执行提高系统的处理能力 集群操作系统：集群操作系统将多个计算节点（服务器）连接成一个集群，通过集群管理软件来协调节点间的资源和工作负载，以提供高可用性和可扩展性。 云计算操作系统：云计算操作系统是专为云计算环境设计的，它管理虚拟资源（如虚拟机、存储、网络），提供弹性计算、按需付费等特性。 嵌入式操作系统：嵌入式操作系统是专为嵌入式系统设计的，这些系统通常具有特定的硬件和实时要求，如智能家居设备、手机等。 多媒体操作系统：多媒体操作系统支持多媒体数据的处理、存储和传输，如音频、视频和图像的实时处理。 智能卡操作系统：智能卡操作系统是运行在智能卡（如IC卡、SIM卡）上的微型操作系统，管理卡上的资源，提供安全的数据存储和访问控制。 硬件环境包括：定时装置、堆与栈、寄存器、特权指令与非特权指令、处理器状态及状态转换、地址映射机构、存储保护装置、中断装置、通道与DMA控制器。 -以下进行选择性说明。 堆与栈栈（Stack） ‌设计目的‌：栈主要用于存储局部变量和方法调用的上下文信息（如参数、返回地址等）。它遵循后进先出（LIFO, Last In First Out）的原则。 ‌管理方式‌：栈由操作系统自动管理，包括内存的分配和释放。每当一个函数被调用时，它的参数、局部变量和返回地址等信息就会被压入栈中；当函数返回时，这些信息会从栈中弹出。这种自动管理机制简化了内存管理，但也限制了栈的使用方式。 ‌存储特性‌：栈的大小在程序运行时通常是固定的，或者有一个最大限制（这取决于操作系统和程序的设计）。因此，栈上能够存储的数据量是有限的。如果尝试在栈上分配过多的数据，将会导致栈溢出（Stack Overflow）错误。 ‌使用方式‌：程序员通常不需要（也无法）直接控制栈内存的分配和释放，这是由编译器和操作系统自动完成的。 堆（Heap） ‌设计目的‌：堆主要用于存储程序运行期间动态分配的内存。与栈不同，堆上的内存分配和释放是由程序员控制的，这提供了更大的灵活性。 ‌管理方式‌：堆的管理更加复杂，需要程序员手动管理内存的分配和释放（尽管有些现代语言如Java、C#等提供了垃圾回收机制来自动管理堆内存）。程序员可以通过调用特定的库函数（如C语言中的malloc和free，C++中的new和delete）来在堆上分配和释放内存。 ‌存储特性‌：堆的大小通常比栈大得多，并且可以在程序运行时动态地增长和缩小（取决于操作系统的内存管理策略和可用内存）。然而，这也意呀着堆上的内存管理更加复杂，容易出现内存泄漏等问题。 ‌使用方式‌：程序员需要负责在堆上分配和释放内存，这增加了程序的复杂性但也提供了更大的灵活性。堆上的内存可以用于存储各种类型的数据结构，如链表、树、图等。 寄存器程序切换时，一般需要把寄存器的当前值保存起来，再次运行前再恢复。 程序状态字(program status word, PSW)： 状态字（Status Word）是计算机科学中常用于表示程序、设备或系统当前状态的一种数据结构或变量。它通常包含了一系列的标志位（Flag bits），每个标志位用来表示不同的状态或条件是否被满足。通过检查这些标志位，程序可以了解系统或设备的当前状况，并据此做出相应的处理。 状态字的设计可以根据不同的应用场景而有所不同，但一般来说，它们都会包含以下几种类型的信息： ‌错误码‌：用来指示操作是否成功执行，如果失败，则可能包含具体的错误代码或类型。 ‌操作模式‌：指示设备或系统当前处于何种操作模式（如读模式、写模式、待机模式等）。 ‌硬件状态‌：反映硬件组件（如内存、磁盘、传感器等）的当前状态（如满、空、就绪、错误等）。 ‌权限级别‌：在安全敏感的应用中，可能包含用户或进程的权限级别信息。 ‌特殊条件‌：如中断是否被启用、特定资源是否被锁定等。 示例 假设我们有一个简单的状态字，用于表示一个数据处理模块的状态，这个状态字是一个8位的字节，设计如下： 位0（最低位）：0 表示没有错误，1 表示发生错误。 位1：0 表示模块处于空闲状态，1 表示模块正在处理数据。 位2-3（共2位）：用于表示模块当前的工作模式（假设有4种模式）。 位4-7（共4位）：保留，将来可能用于其他目的或特定条件。 在这个例子中，如果我们想检查模块是否处于空闲状态并且没有错误，我们可以读取状态字，并检查位0和位1是否为00。 编码示例（伪代码）： 123456789101112pseudofunction check_status(status_word): if (status_word &amp; 0x01) == 0 and (status_word &amp; 0x02) == 0: return True # 空闲且无错误 else: return False# 假设 status_word 是从某处获取的status_word = 0x00 # 假设的示例值if check_status(status_word): print(&quot;模块处于空闲状态且没有错误。&quot;)else: print(&quot;模块不在空闲状态或存在错误。&quot;) 注意：上面的示例使用的是位操作（位与&amp;）来检查特定位的值。0x01是二进制0000 0001，0x02是二进制0000 0010，它们分别用于检查状态字的最低两位。 处理器状态及状态转换处理器状态： 为构造一个可靠的系统，硬件至少要区分两种状态：管态和目态。它由一位触发器标识，通常属于程序状态字的一部分，即由程序状态字中的一位标识。 目态（Object Mode） ‌定义‌：目态，也称为用户态或常态，是用户程序执行时CPU所处的状态。 ‌特点‌： ‌指令限制‌：在目态下，程序只能执行非特权指令，即那些不会直接影响到系统硬件或安全性的指令。这包括大部分的计算和数据处理指令，但不包括如I&#x2F;O操作、内存保护寄存器访问、中断控制等特权指令。 ‌资源访问限制‌：用户程序不能直接使用系统资源，也不能改变CPU的工作状态。它们通常只能访问自己被分配的内存空间，而不能访问其他用户程序或操作系统的内存。 ‌安全性‌：这种限制机制有助于保护系统免受恶意用户程序的破坏，确保系统的稳定性和安全性。 管态（Supervisor Mode） ‌定义‌：管态，也称为特权态、系统态或核心态，是CPU在执行操作系统内核程序或进行低级硬件操作时所处的状态。 ‌特点‌： ‌指令全集执行‌：在管态下，CPU可以执行指令系统的全集，包括特权指令和非特权指令。这使得操作系统能够执行必要的硬件管理任务，如设备驱动、内存管理、进程调度等。 ‌资源访问无限制‌：操作系统在管态下可以访问计算机的任何资源，包括所有内存空间、硬件设备以及系统级的配置信息。这种无限制的资源访问权限使得操作系统能够有效地管理整个系统。 ‌系统稳定性与安全性‌：虽然管态下的权限非常广泛，但操作系统的设计和实现需要确保这些权限的合理使用，以避免系统崩溃或安全漏洞。 状态转换： 目态→管态：目态程序无法直接控制处理器状态的转换(修改处理器状态是个特权命令)，故需要中断。中断之后处理器状态字就处于管态。 管态→目态：可以通过修改程序状态字(置PSW)来实现 操作系统的界面形式 交互终端命令 图形用户界面 触屏用户界面 作业控制语言 运行机理操作系统是中断驱动的，这么说，当考虑一个系统并发执行P1和P2两个程序时，若：”在t1时刻P1程序执行，在t2时刻P2程序执行，t1&lt;t2“，那么在t1-t2之间一定发生过中断，即中断时程序切换的必要条件。 实际上，P1本人并不能直接把CPU使用权交给P2，这过程需要操作系统。而操作系统取代P1成为处理器持有者的唯一途径是中断。 中断将引出新的程序状态字并导致系统由目态转到管态(即进入操作系统)(目态，也称为用户态或常态，是用户程序执行时CPU所处的状态;管态，也称为特权态、系统态或核心态，是CPU在执行操作系统内核程序或进行低级硬件操作时所处的状态)。 当系统中断之后，通过CPU的调度再决定执行P1或P2。 系统举例Linux系统： 源代码开放，免费；系统稳定、可靠；速度快，效率高；内核模块化程度高，允许第三方配置文件系统及设备管理程序；功能完善；具有网络支持优势；标准化程度高。 Windows 10系统： Windows10是基于NT技术构建的面向个人计算机平台的操作系统，本质上属于单用户系统，但可以组网并提供网络服务。 具有多任务(包括多线程、多进程)管理功能，支持对称多处理，操作系统进程可以在任何可获得的处理器上运行，同一进程中的多个线程可以在不同处理器上同时运行。 支持客户-服务器计算模式，一台PC或工作站与一个主系统合作完成特定的服务程序。 提供友好图形化界面","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bayeeaa.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Java Web入门","slug":"Java-Web入门","date":"2024-09-22T03:13:29.000Z","updated":"2024-09-22T03:15:13.058Z","comments":true,"path":"2024/09/22/Java-Web入门/","link":"","permalink":"https://bayeeaa.github.io/2024/09/22/Java-Web%E5%85%A5%E9%97%A8/","excerpt":"","text":"Java Web入门在这里我们可以学习Java程序与另一台机器上的程序对话。Java好处之一就是：通过网络发送和接收数据都是I&#x2F;O，只是I&#x2F;O链末尾的连接稍有不同。我们可以建立一个client类和一个server类来模拟服务器与客户端的数据传递。 传输协议TCP（传输控制协议）和UDP（用户数据报协议）是两种常用的传输层协议，它们在计算机网络中负责在主机之间传输数据。它们各自有不同的特性和适用场景。以下是对它们的详细介绍： TCP（传输控制协议） 连接导向: TCP是一个面向连接的协议，这意味着在实际数据传输之前，必须在通信的两端建立一个连接。这个连接确保数据的可靠传输。 可靠性: TCP提供可靠的数据传输，确保数据包的顺序、完整性和无丢失。在数据传输过程中，TCP会进行错误检测、重传丢失的数据包、以及保证数据包的顺序正确。 流量控制: TCP通过流量控制机制来避免发送方过快地发送数据，从而防止接收方处理不及。 拥塞控制: TCP还具备拥塞控制功能，能够动态调整数据传输的速率，以应对网络中的拥塞情况。 数据传输: TCP将数据分段，并在接收端重新组装成完整的数据流。每个数据包都有序号，以便接收端可以按顺序重新组装数据。 使用场景: 由于其可靠性，TCP适用于需要保证数据传输完整性和顺序的应用，如网页浏览（HTTP&#x2F;HTTPS）、电子邮件（SMTP）、文件传输（FTP）等。 UDP（用户数据报协议） 无连接: UDP是一个无连接的协议，这意味着在数据传输之前不需要建立连接。每个数据包（称为数据报）独立发送，不保证数据的到达顺序或完整性。 不可靠: UDP不提供数据包丢失的重传、顺序保证或错误校验。数据可能会丢失、重复或乱序到达。 低开销: 由于UDP没有连接建立和管理的开销，相比TCP，UDP的开销更小，传输效率更高。 数据传输: UDP将数据分割成数据报，每个数据报独立发送，接收端不进行重新组装，接收应用需要自行处理数据的顺序和完整性。 使用场景: UDP适用于那些对数据传输速度要求高而对可靠性要求低的应用，如实时视频流、在线游戏、语音通话（VoIP）等。在这些场景中，数据传输的速度和时效性比数据的完整性更为重要。 所以一般情况下，我们使用TCP协议传输较多。 关于数据传输，我们可以参考下图的TCP三次握手，当我们完成了三次握手，就说明客户端已经和服务器建立了连接，可以进行数据传输了。 通俗的理解： 客户端：听得到吗？ ——&gt; 服务器 （连接） 客户端 ——&gt; 服务器：听得到，你听的到我吗？ （接收） 客户端：可以听到，我们可以说话了 ——&gt; 服务器 （发送） Web实现思路连接要建立连接，我们需要知道这个服务器的IP地址和TCP端口号。当我们发送信息时Java会将二进制数据传入“网络栈”中，并向外发送请求。 我们大致的连接思路如下： 12InetSocketAddress serverAddress = new InetSocketAddress(&quot;192.164.1.103&quot;,5000);SocketChannel socketChannel = SocketChannel.open(serverAddress); 通过InetSocketAddress我们记录了所要地址的ip和端口，然后我们通过SocketChannel进行连接。注意在SocketChannel后面是SocketChannel.open(serverAddress)，说明我们并没有使用构造器来创建，而是调用了一个open()方法。这会创建一个新的SocketChannel，并把它连接到一个提供的地址。 注意：一般情况下TCP端口号在0-1023是用作公认服务的，当自己在创建服务器的时候应当尽量避免这些端口。我们使用的端口可以在1024-65535之间随便选择。 接收用BufferedReader读取BufferedReader通过使用缓冲区来减少对底层输入流的频繁访问，从而提高读取效率。它通常会将多个字符读取到内存中，然后逐个读取，从而减少I&#x2F;O操作的开销. 建立与服务器的连接(就是重复上一步)： 12SocketAddress serverAddr = new InetSocketAddress(&quot;127.0.0.1&quot;,5000);SocketChannel socketChannel = SocketChannel.open(serverAddr); 从这个连接创建或获取一个Reader： 1Reader reader = Channels.newReader(socketChannel,StandardCharsets.UTF_8); 这个Reader是字符流和字节流交流的桥梁，比如来自Channel的流就是字节流，链流顶端的BufferedReader就是字符流。我们在文件传输最底层是由字节流传递的，而最后由我们客户端接收显示就是要由字符流形成。也就是我们用reader将字节变成了字符。 创建一个BufferedReader并读取： 12BufferedReader bufferedReader = new BufferedReader(reader);String message = bufferedReader.readLine(); 我们用我们上一步的reader，我们知道reader此时已经是字符，我们只需再将其通过BufferedReader构造器，变成缓冲的字符，然后我们就可以再客户端读取数据了。 发送用PrintWriter写至网络同样的线创建一个连接： 12SocketAddress serverAddr = new InetSocketAddress(&quot;127.0.0.1&quot;,5000);SocketChannel socketChannel = SocketChannel.open(serverAddr); 从连接创建或获得一个Writer： 1Writer writer = Channels.newWriter(socketChannel,StandardCharsets.UTF_8); Writer也同Reader一样，在字符流和字节流中间充当桥梁。 创建一个PrinterWriter并打印一些内容： 123PrintWriter printWriter = new PrintWriter(writer);writer.println(&quot;message to send&quot;);writer.println(&quot;another message&quot;); PrintWriter接收字符，然后串链到Writer，最后Writer转换字符流为字节流传递给服务器。 另一种连接方式Socket连接： 12345678910Socket chatSocket = new Socket(&quot;127.0.0.1&quot;,5000);InputStreamReader in = new InputStreamReader(chatSocket.getInputStream());BufferedReader bufferedReader = new BufferedReader(in);String message = bufferedReader.readLine();PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());writer.println(&quot;message to send&quot;);writer.println(&quot;another message&quot;); 当然我们已经有了Channel来进行连接了，为什么还要用Socket来连接呢？ 基本概念 Socket：是Java中用于进行网络通信的传统方式。它代表一个端点，通过TCP或UDP协议在网络中进行数据传输。 Channel：是Java NIO（New Input&#x2F;Output）中的一个概念，代表一个连接的打开的通道，支持非阻塞I&#x2F;O操作，能够进行更高效的文件和网络操作。 阻塞与非阻塞 Socket：通常是阻塞的，这意味着当你进行读写操作时，调用会一直等待，直到操作完成。 Channel：支持非阻塞模式，允许你在没有数据可用时继续执行其他操作。可以通过Selector管理多个Channel，从而在单个线程中处理多个连接。 I&#x2F;O模型 Socket：使用传统的字节流或字符流进行数据的读取和写入。 Channel：使用Buffer进行数据的传输，可以通过ByteBuffer和CharBuffer等直接操作内存，提高性能。 API设计 Socket：使用较简单，适合小型或简单的网络应用。比如，通过Socket和ServerSocket类进行创建和管理连接。 Channel：提供更灵活的API，如SocketChannel、ServerSocketChannel等，适合高性能应用，尤其是需要处理大量并发连接的场景。 适用场景 Socket：适合小型应用或较为简单的网络通信需求。 Channel：适合高性能的网络应用，尤其是在处理大量连接或需要非阻塞I&#x2F;O的场景。 Socket适合传统、简单的网络编程，而Channel则是为了更高效的非阻塞I&#x2F;O设计的，特别是在需要处理高并发和高性能时。 两个实例服务器向客户端发送字符串客户端： 123456789101112131415161718192021222324252627282930package com.bayeeaa.demo1.web.Advice;import java.io.BufferedReader;import java.io.IOException;import java.io.Reader;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.Channels;import java.nio.channels.SocketChannel;import java.nio.charset.StandardCharsets;public class DaliyAdviceClient &#123; public void go() &#123; InetSocketAddress serverAddress = new InetSocketAddress(&quot;127.0.0.1&quot;,5000); //获取地址和端口 try(SocketChannel socketChannel = SocketChannel.open(serverAddress))&#123; //尝试连接,返回字节流，赋值于socketChannel Reader channelReader = Channels.newReader(socketChannel, StandardCharsets.UTF_8); //channelReader读入传输数据，转为字符流 BufferedReader reader = new BufferedReader(channelReader); //BufferedReader可以显著提高读取性能,它通过在内存中维护一个缓冲区来减少对底层数据源的访问频率 String advice = reader.readLine(); //读取行 System.out.println(&quot;Today you should &quot; + advice); reader.close(); //关闭输入流 &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; new DaliyAdviceClient().go(); &#125;&#125; 服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.bayeeaa.demo1.web.Advice;import java.io.IOException;import java.io.PrintWriter;import java.net.InetSocketAddress;import java.nio.channels.Channel;import java.nio.channels.Channels;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Random;public class DaliyAdviceServer &#123; final private String[] adviceList = &#123; //随机一个建议 &quot;Happy&quot;, &quot;Good&quot;, &quot;Be yourself&quot;, &quot;relax&quot;, &quot;paly computer games&quot; &#125;; private final Random random = new Random(); private String getAdvice() &#123; int nextAdvice = random.nextInt(adviceList.length); return adviceList[nextAdvice]; &#125; public void go()&#123; try(ServerSocketChannel serverChannel = ServerSocketChannel.open()) &#123; serverChannel.bind(new InetSocketAddress(5000)); while(serverChannel.isOpen())&#123; SocketChannel clientChannel = serverChannel.accept(); PrintWriter writer = new PrintWriter(Channels.newOutputStream(clientChannel)); String advice = getAdvice(); writer.println(advice); writer.close(); System.out.println(advice); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; new DaliyAdviceServer().go(); &#125;&#125; 客户端向服务器发送字符串信息客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.bayeeaa.demo1.web.simplechat;import javax.swing.*;import java.awt.*;import java.io.IOException;import java.io.PrintWriter;import java.net.InetSocketAddress;import java.nio.channels.Channels;import java.nio.channels.SocketChannel;import java.nio.charset.StandardCharsets;public class SimpleChatClientA &#123; private JTextField outgoing; private PrintWriter writer; public void go() &#123; setUpNetworking(); outgoing = new JTextField(20); //这里是在搞GUI JButton sendButton = new JButton(&quot;Send&quot;); sendButton.addActionListener(e -&gt; sendMessage()); JPanel mainPanel = new JPanel(); mainPanel.add(outgoing); mainPanel.add(sendButton); JFrame frame = new JFrame(&quot;Simple Chat Client&quot;); frame.getContentPane().add(BorderLayout.CENTER,mainPanel); frame.setSize(400,100); frame.setVisible(true); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public void setUpNetworking() &#123; InetSocketAddress serverAddress = new InetSocketAddress(&quot;127.0.0.1&quot;,5000); try &#123; SocketChannel socketChannel = SocketChannel.open(serverAddress); //socketChannel为网络通道 writer = new PrintWriter(Channels.newWriter(socketChannel, StandardCharsets.UTF_8)); //PrintWriter 是一个字符流类，用于将字符数据写入输出流 //Channels.newWriter(socketChannel, StandardCharsets.UTF_8) 创建了一个 WritableByteChannel 的字符流，这样可以将字符数据写入到与 socketChannel 关联的网络通道中。socketChannel 是一个与远程服务器连接的 SocketChannel。 System.out.println(&quot;Network established&quot;); writer.println(&quot;nihao&quot;);//这里测试，是将&quot;nihao&quot;输入到了服务器 &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private void sendMessage() &#123; writer.println(outgoing.getText()); writer.flush(); //强制将所有缓存的输出数据写入到底层输出流中 outgoing.setText(&quot;&quot;); //setText 是一个方法，用于设置文本组件中显示的文本内容.这里是清空 outgoing 组件中的文本 outgoing.requestFocus(); //requestFocus() 方法会将焦点设置到 outgoing 组件，使得用户可以立即开始在该组件中输入文本 &#125; public static void main(String[] args) &#123; new SimpleChatClientA().go(); &#125;&#125; 服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.bayeeaa.demo1.web.simplechat;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.net.InetSocketAddress;import java.nio.channels.Channels;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class SimpleChatServer &#123; private final List&lt;PrintWriter&gt; clientWriters = new ArrayList&lt;&gt;(); private void tellEveryone(String message) &#123; for(PrintWriter writer : clientWriters)&#123; writer.println(message); writer.flush(); &#125; &#125; public class ClientHanlder implements Runnable&#123; BufferedReader reader; SocketChannel socket; public ClientHanlder(SocketChannel clientSocket)&#123; socket = clientSocket; reader = new BufferedReader(Channels.newReader(socket, StandardCharsets.UTF_8)); &#125; @Override public void run() &#123; String message; try &#123; while((message = reader.readLine()) != null)&#123; System.out.println(&quot;read &quot; + message); tellEveryone(message); &#125; &#125;catch (IOException ex)&#123; ex.printStackTrace(); &#125; &#125; &#125; public void go() &#123; ExecutorService treadPool = Executors.newCachedThreadPool(); try &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(5000)); while (serverSocketChannel.isOpen()) &#123; SocketChannel clientSocket = serverSocketChannel.accept(); PrintWriter writer = new PrintWriter(Channels.newWriter(clientSocket, StandardCharsets.UTF_8)); clientWriters.add(writer); treadPool.submit(new ClientHanlder(clientSocket)); System.out.println(&quot;got a connection&quot;); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; new SimpleChatServer().go(); &#125;&#125; 这里使用了简单的GUI使操作可视化，只需在跳出的窗口中输入字符串就可以发送到服务器，并在其终端查看内容。 可以看到”nihao”和我刚刚输入的”123”是同时打出的，说明这个”nihao”是加入了缓冲中，然后点击”send”时最后释放。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"通过Github Pages上线Vite app静态项目","slug":"通过Github-Pages上线Vite-app静态项目","date":"2024-09-16T07:14:48.000Z","updated":"2024-09-16T07:16:41.550Z","comments":true,"path":"2024/09/16/通过Github-Pages上线Vite-app静态项目/","link":"","permalink":"https://bayeeaa.github.io/2024/09/16/%E9%80%9A%E8%BF%87Github-Pages%E4%B8%8A%E7%BA%BFVite-app%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"通过Github Pages上线Vite app静态项目我们都知道通过github pages是能够免费上线一个静态项目的。但你是否有疑惑，为什么我的vue项目在本地npm run dev的时候是能够查看的，为什么我部署到github上并通过github pages却是空白的？经过尝试我发现vite所构建的项目是相当于是操作文件，而不是对外发布(public)的文件，因此我们需要进行额外的操作。 项目配置在vite.config.ts文件中输入： 1base:&#x27;/仓库名/&#x27; 然后在终端输入： 1npm run build 注意要build的话就需要将所有的飘红的bug都解决掉，否则报错。 然后要是build成功，就会发现多出一个dist隐藏文件，这个dist文件就是我们需要对外部署的文件。 git操作然后我们就需要将这个文件单独出一个分支，我们约定俗成给这个分支叫做”gh-pages”，并将dis导入进这个分支。 操作如下： 123git add dist -fgit commit -m &quot;adding dist&quot; git subtree push --prefix dist origin gh-pages git add dist -f ：注意-f是强制添加(force)的意思，因为这个是隐藏文件，git会默认将其忽略掉，因此需要强制添加到缓冲区。 git commit -m “adding dist” ：确认上传，并写入原因。 git subtree push –prefix dist origin gh-pages ：我们一个一个分析:”git subtree”用于管理项目中的子目录作为独立的 Git 树结构进行操作；”push –prefix dist”推入子文件dist(dist在整个项目中是子文件)；”origin gh-pages “是目标地，origin是仓库，gh-pages是分支 上线pages当你完成了上述git操作之后就可以在github pages里面操作了： 然后你就可以点击上面”Your site is live at https:&#x2F;&#x2F;**”，就可以访问了。 静态项目更新当我们发现错误需要更新的时候，我们要知道在原vite项目和dist文件中都需要更改。首先需要在原来的vite项目中更改，然后上传至仓库。接着再重复上述的git命令上传至gh-pages里面： 1234npm run buildgit add dist -fgit commit -m &quot;adding dist&quot; git subtree push --prefix dist origin gh-pages 然后就可以完成网站更新了。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"},{"name":"Git","slug":"Git","permalink":"https://bayeeaa.github.io/tags/Git/"}]},{"title":"Java IO流","slug":"Java-IO流","date":"2024-09-03T06:27:16.000Z","updated":"2024-09-16T07:33:57.314Z","comments":true,"path":"2024/09/03/Java-IO流/","link":"","permalink":"https://bayeeaa.github.io/2024/09/03/Java-IO%E6%B5%81/","excerpt":"","text":"Java I&#x2F;O流I&#x2F;O流即input和output产生的流。Java程序是通过“流”的形式进行数据输入和输出。 流流是一种抽象的概念，可以理解为输入&#x2F;输出的途径。I&#x2F;O部分内容是很庞大的，包括有标准的输入&#x2F;输出、文件操作、网络上的数据流、字符串流、对象流等。当程序需要读取数据时，就会开启一个通向数据源的流，这个数据源可以是文件、内存或网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。 流的概念Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类表示： InputStream OutputStream Reader Writer 输入流和输出流流可分为两类：输入流和输出流。用户可以从输入流中读取信息，但不能写它。相反，对于输出流，只能往其中写，而不能读它。 输入流输入流的信息源可以位于文件、内存或网络套接字(Socket)等地方，信息源可以是对象、字符、图像、声音等。 输出流与输入流类似，程序页能通过打开一个输出流并顺序地写入数据来将信息送至目的端。 字节流与字符流的区别1. 数据处理方式 字节流：处理原始的字节数据。它适用于所有类型的数据，包括图像、音频、视频等，因为这些数据并不依赖于特定的字符编码。常见的字节流类包括 InputStream 和 OutputStream 及其子类，例如 FileInputStream 和 FileOutputStream。 字符流：处理字符数据，并且能够自动处理字符编码和解码。字符流是基于字节流的封装，能将字节流转换成字符流，处理时考虑了字符编码（如 UTF-8、ISO-8859-1 等）。常见的字符流类包括 Reader 和 Writer 及其子类，例如 FileReader 和 FileWriter。 2. 适用场景 字节流：适合于二进制数据的读写，如图像、音频文件等，因为它们的数据通常不需要字符编码转换。例如，当你需要处理一个图片文件时，使用字节流是比较合适的选择。 字符流：适合于文本数据的读写，尤其是当你需要处理不同字符编码时。字符流可以直接处理字符、字符串，并且会根据指定的字符集进行编码和解码。例如，当你读取或写入文本文件时，使用字符流更为方便。 3. 处理单位 字节流：以字节为单位进行读写，操作的是原始的二进制数据。 字符流：以字符为单位进行读写，操作的是文本数据，并会进行字符编码的转换 字节流在前面我们知道I&#x2F;O类中所有对字节流处理的类，都继承与InputStream类和OutputStream类。 InputStream类InputStream 是 Java 中用于读取字节流的抽象类。它是所有字节输入流类的超类，提供了基本的输入流操作方法。InputStream 类的设计使得你可以从各种数据源（如文件、网络、内存等）读取字节数据。以下是关于 InputStream 类的一些关键点： int read() 读取下一个字节的数据。 如果流末尾已到达，返回 -1。 示例： 1int data = inputStream.read(); int read(byte[] b) 从输入流中读取数据到字节数组中。 返回实际读取的字节数，如果流末尾已到达，返回 -1。 示例： 12byte[] buffer = new byte[1024];int bytesRead = inputStream.read(buffer); int read(byte[] b, int off, int len) 从输入流中读取数据到字节数组中的指定位置。 参数 off 指定写入数据的起始位置，len 指定最大读取字节数。 返回实际读取的字节数，如果流末尾已到达，返回 -1。 示例： 12byte[] buffer = new byte[1024];int bytesRead = inputStream.read(buffer, 0, buffer.length); void close() 关闭输入流并释放与之关联的系统资源。 示例： 1inputStream.close(); long skip(long n) 跳过并丢弃输入流中的 n 个字节。 返回实际跳过的字节数。 示例： 1long skipped = inputStream.skip(100); available() 返回流中当前可读的字节数，但不一定能保证实际读取的字节数。 示例： 1int availableBytes = inputStream.available(); 常见子类： FileInputStream：从文件中读取字节流。 ByteArrayInputStream：从内存中的字节数组中读取字节流。 BufferedInputStream：提供缓冲功能的输入流，能提高读取效率。 DataInputStream：提供读取 Java 原始数据类型的输入流。 示例： 以下是一个简单的使用 FileInputStream 类读取文件内容的示例： 12345678910111213141516import java.io.FileInputStream;import java.io.IOException;public class FileReadExample &#123; public static void main(String[] args) &#123; try (FileInputStream fis = new FileInputStream(&quot;example.txt&quot;)) &#123; int content; while ((content = fis.read()) != -1) &#123; // 打印读取的字节（转换为字符） System.out.print((char) content); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： InputStream 是一个抽象类，不能直接实例化。通常，你会使用其具体子类来进行实际的字节读取操作。 操作完成后，一定要关闭流，以释放系统资源。这通常通过 try-with-resources 语句来自动完成。 OutputStream类OutputStream 是 Java 中用于写入字节流的抽象类。它是所有字节输出流类的超类，提供了基本的输出流操作方法。OutputStream 类的设计使得你可以将字节数据写入各种数据目标，如文件、网络连接、内存等。以下是 OutputStream 类的一些关键点： void write(int b) 将指定的字节写入输出流。 参数 b 是要写入的字节（实际上是一个 int 值，但只使用低 8 位）。 示例： 1outputStream.write(65); // 写入字节 &#x27;A&#x27; void write(byte[] b) 将字节数组中的所有字节写入输出流。 示例： 12byte[] data = &quot;Hello&quot;.getBytes();outputStream.write(data); void write(byte[] b, int off, int len) 将字节数组中的一部分写入输出流。 参数 off 是字节数组中的起始偏移量，len 是要写入的字节数。 示例： 12byte[] data = &quot;Hello World&quot;.getBytes();outputStream.write(data, 0, 5); // 写入 &quot;Hello&quot; void flush() 刷新输出流，确保所有缓冲的字节都被写入到目标地。 示例： 1outputStream.flush(); void close() 关闭输出流并释放与之关联的系统资源。 示例： 1outputStream.close(); 常见子类： FileOutputStream：将字节写入文件。 ByteArrayOutputStream：将字节写入内存中的字节数组。 BufferedOutputStream：提供缓冲功能的输出流，能提高写入效率。 DataOutputStream：提供写入 Java 原始数据类型的输出流。 示例： 以下是一个简单的使用 FileOutputStream 类写入文件的示例： 12345678910111213import java.io.FileOutputStream;import java.io.IOException;public class FileWriteExample &#123; public static void main(String[] args) &#123; try (FileOutputStream fos = new FileOutputStream(&quot;example.txt&quot;)) &#123; String content = &quot;Hello, World!&quot;; fos.write(content.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意: 关闭流：使用完 OutputStream 后一定要关闭流，以释放系统资源。通常使用 try-with-resources 语句来自动关闭流。 缓冲：如果你需要提高写入效率，可以使用 BufferedOutputStream 进行缓冲操作。 写入数据：在写入数据时，可以选择将字节数组、单个字节或字节数组的部分写入流。确保正确处理偏移量和长度，以避免写入不必要的数据或产生异常。 OutputStream 提供了处理字节数据的基本操作，了解其使用方法可以帮助你在处理文件、网络和其他数据目标时有效地输出字节数据。 字符流InputStream和OutputStream在早期的Java版本中就已经存在了，它们是基于字节流的，而基于字符流的Reader和Writer是后来加入作为补充的。 Rreader类Reader 类是 Java 中用于处理字符流的抽象类。它是所有字符输入流类的超类，提供了基本的字符读取操作方法。与 InputStream 类不同，Reader 处理的是字符而不是原始字节，因此它会根据指定的字符编码进行字符转换。 其主要操作方法有下述几种，因与IO类类似，故其不在赘述。 int read() int read(char[] cbuf) int read(char[] cbuf, int off, int len) long skip(long n) boolean ready() void close() 常见子类: FileReader：从文件中读取字符流。 BufferedReader：提供缓冲功能的字符流，能提高读取效率，并且提供了 readLine() 方法以便逐行读取文本。 CharArrayReader：从内存中的字符数组中读取字符流。 StringReader：从内存中的字符串读取字符流。 示例: 以下是一个简单的使用 FileReader 类读取文件内容的示例： 123456789101112131415import java.io.FileReader;import java.io.IOException;public class FileReadExample &#123; public static void main(String[] args) &#123; try (FileReader fr = new FileReader(&quot;example.txt&quot;)) &#123; int character; while ((character = fr.read()) != -1) &#123; System.out.print((char) character); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用 BufferedReader 逐行读取文本的示例： 12345678910111213141516import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderExample &#123; public static void main(String[] args) &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;example.txt&quot;))) &#123; String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： 字符编码：Reader 类会处理字符编码问题，因此在读取文件时，确保文件编码与你的 Reader 配置一致。 关闭流：使用完 Reader 后，一定要关闭流以释放系统资源。通常使用 try-with-resources 语句来自动关闭流。 缓冲：为了提高读取效率，可以使用 BufferedReader 类，它提供了缓冲功能，并且能更高效地读取数据。 Writer类Writer 类是 Java 中用于处理字符流的抽象类。它是所有字符输出流类的超类，提供了基本的字符输出操作方法。与 OutputStream 类不同，Writer 处理的是字符数据，而不是原始的字节数据，因此它会根据指定的字符编码进行字符转换。 void write(int c) 将指定的字符写入输出流。 参数 c 是要写入的字符（实际是一个 int 值，但只使用低 16 位）。 示例： 1writer.write(&#x27;A&#x27;); // 写入字符 &#x27;A&#x27; void write(char[] cbuf) 将字符数组中的所有字符写入输出流。 示例： 12char[] data = &quot;Hello&quot;.toCharArray();writer.write(data); void write(char[] cbuf, int off, int len) 将字符数组中的一部分写入输出流。 参数 off 是字符数组中的起始偏移量，len 是要写入的字符数。 示例： 12char[] data = &quot;Hello World&quot;.toCharArray();writer.write(data, 0, 5); // 写入 &quot;Hello&quot; void write(String str) 将字符串中的所有字符写入输出流。 示例： 1writer.write(&quot;Hello, World!&quot;); void write(String str, int off, int len) 将字符串的指定部分写入输出流。 参数 off 是字符串中的起始位置，len 是要写入的字符数。 示例： 1writer.write(&quot;Hello, World!&quot;, 0, 5); // 写入 &quot;Hello&quot; void flush() 刷新输出流，确保所有缓冲的字符都被写入到目标地。 示例： 1writer.flush(); void close() 关闭输出流并释放与之关联的系统资源。 示例： 1writer.close(); 常见子类: FileWriter：将字符写入文件。 BufferedWriter：提供缓冲功能的字符流，能提高写入效率。 CharArrayWriter：将字符写入内存中的字符数组。 PrintWriter：提供了更多格式化功能的字符输出流，支持打印各种数据类型。 示例: 以下是一个简单的使用 FileWriter 类写入文件的示例： 123456789101112import java.io.FileWriter;import java.io.IOException;public class FileWriteExample &#123; public static void main(String[] args) &#123; try (FileWriter fw = new FileWriter(&quot;example.txt&quot;)) &#123; fw.write(&quot;Hello, World!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用 BufferedWriter 提高写入效率的示例： 123456789101112131415import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class BufferedWriterExample &#123; public static void main(String[] args) &#123; try (BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;example.txt&quot;))) &#123; bw.write(&quot;Hello, World!&quot;); bw.newLine(); // 添加新行 bw.write(&quot;This is a new line.&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： 字符编码：Writer 类会处理字符编码问题，因此在写入文件时，确保文件编码与你的 Writer 配置一致。如果需要特定的编码格式，可以使用 OutputStreamWriter 类来指定编码。 关闭流：使用完 Writer 后，一定要关闭流以释放系统资源。通常使用 try-with-resources 语句来自动关闭流。 缓冲：为了提高写入效率，可以使用 BufferedWriter 类，它提供了缓冲功能，并能更高效地写入数据。 实现用户输入Java提供了java.util.Scanner类，可以直接接收控制台命令行的输入。 使用System.in获取用户输入Java提供了System.in、System.out及System.err类。 System.out是一个已经预先处理过的、被包装成PrintStream的对象。 System.err和System.out一样，也是一个PrintStream。 但System.in就不是了，它是一个未经处理的InputStream。 System.in输入示例： 12345678910import java.io.IOException;public class System_test &#123; public static void main(String[] args) throws IOException &#123; char a; System.out.println(&quot;请输入一个字符：&quot;); a=(char)System.in.read(); System.out.println(&quot;输入的是&quot; + a); &#125;&#125; 使用Scanner类获取用户输入java.util.Scanner类是JDK新增的一个类，可使用该类创建一个命令行读取数据的对象，而不必再进行流的转换。使用方法如下： 1Scannner sc = new Scanner(System.in); 然后我们就可以对sc进行调用操作，比如： 1String n = sc.nextLine(); 这里我们注意了，可以有多种调用方式： next()：字符串 nextInt()：整型 nextDouble()：浮点型 nextLine()：字符串，但可以读入空格 在绝对路径创建文件夹，并创建一个临时txt文件 FileCreateAndDir.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.bayeeaa.demo1.IO_test;import java.io.File;import java.io.IOException;public class FileCreateAndDir &#123; //文件创建和目录 public static boolean createDir(String destDirName)&#123; //创建目录 File dir = new File(destDirName); if(dir.exists())&#123; System.out.println(&quot;目标目录存在！&quot;); return false; &#125; if(!destDirName.endsWith(File.separator))&#123; //结尾是否以&quot;/&quot;结束 destDirName = destDirName + File.separator; &#125; if(dir.mkdir())&#123; //这里创建目录，并返回true System.out.println(&quot;目录成功创建！&quot;); return true; &#125; else&#123; System.out.println(&quot;创建失败！&quot;); return false; &#125; &#125; public static boolean createFile(String filePath)&#123; File file = new File(filePath); if(file.exists())&#123; System.out.println(&quot;目标文件已存在！&quot;); return false; &#125; if(filePath.endsWith(File.separator))&#123; System.out.println(&quot;目标文件不能是文件！&quot;); return false; &#125; if(!file.getParentFile().exists())&#123; System.out.println(&quot;目标文件文件夹不存在，正在创建它！&quot;); if(!file.getParentFile().mkdir())&#123; System.out.println(&quot;创建目标文件失败！&quot;); return false; &#125; &#125; try &#123; if(file.createNewFile())&#123; System.out.println(&quot;文件创建成功！&quot; + filePath); return true; &#125; else&#123; System.out.println(&quot;文件创建失败！&quot;); return false; &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; test： 1234567891011121314package com.bayeeaa.demo1.IO_test;import java.io.*;public class test &#123; public static void main(String[] args) &#123; String dirPath = &quot;C:\\\\Users\\\\yyn19\\\\Desktop\\\\demoTest&quot;; FileCreateAndDir.createDir(dirPath); // 创建目录 String filePath = dirPath + File.separator + &quot;myfile.txt&quot;; // 文件路径,并给出文件名 FileCreateAndDir.createFile(filePath); // 创建文件 &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"Java集合框架","slug":"Java集合框架","date":"2024-08-29T08:28:12.000Z","updated":"2024-09-16T07:27:09.462Z","comments":true,"path":"2024/08/29/Java集合框架/","link":"","permalink":"https://bayeeaa.github.io/2024/08/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Java集合框架集合有时又称容方法，简单地说就是个对象，能将具有相同性质的多个元素汇聚成一个整体。 集合框架(Collections Framework)是用来表现和操纵集合的一个统一的体系结构。 Collection接口Collection接口时Java集合框架的最顶层接口，它位于java.util包中，是Set接口和List接口(后面会讲)的父接口。 转换构造法Collection接口实现都有一个带有集合参数的构造方法。也就是说，在这里可以通过”转换”集合的类型来实现存储。 1Collection&lt;String&gt; a = new ArrayList&lt;&gt;(); a可以是一个List、Set或另外一中Collection。通常，习惯地创建一个新的ArrayList，初始化为包含a中的所有元素。 12List&lt;String&gt; list = new ArrayList&lt;String&gt;(a);Set&lt;String&gt; set = new HashSet&lt;String&gt;(a); 通过“转换构造法”，list或set对象就包含了集合a中的所有元素。 Collection接口的定义基本操作： boolean add(E e): 将指定的元素添加到集合中（如果集合允许添加）。 boolean remove(Object o): 从集合中移除指定的元素。 boolean contains(Object o): 检查集合是否包含指定的元素。 int size(): 返回集合中的元素数量。 boolean isEmpty(): 检查集合是否为空。 Iterator&lt;E&gt; iterator(): 返回一个迭代器，用于遍历集合中的元素。 以及批量操作： boolean addAll(Collection&lt;? extends E&gt; c): 批量添加 boolean removeAll(Collection&lt;?&gt; c): 从集合中批量移除元素。 boolean containsAll(Collection&lt;?&gt; c): 检查当前集合是否包含所有传入集合的元素 bollean retainAll(Collection&lt;?&gt; c): 删除当前集合中所有不在指定集合 c 中的元素 void clear(): 移除集合中的所有元素。 数组操作： Object[] toArray(): 将集合转换为数组，数组类型为object &lt;T&gt; T[] toArry(T[] a): 将集合中的元素转换为指定类型的数组，并将其存储在提供的数组中。如果提供的数组足够大，则元素将被存储在这个数组中；否则，将创建一个新的数组。 Collection接口的基本操作123456789101112131415161718dog d1 = new dog(&quot;andy&quot;,5);dog d2 = new dog(&quot;tom&quot;,2);Collection&lt;dog&gt; collection = new ArrayList&lt;&gt;();collection.add(d1);collection.add(d2);for(dog o : collection)&#123; //for-each遍历 System.out.println(o.getName());&#125;Iterator&lt;String&gt; iterator = collection.iterator(); //迭代遍历while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;collection.remove(d1); //删除d1对象collection.clear(); //清空 这里我创建了一个dog对象，并给它name和age。 要注意的是，iterator迭代方法同样有遍历的功能，但是Iterator.remove是修改集合唯一安全的方法。如果要移除当前元素。for-each结构隐藏迭代方法，因此不能调用remove方法。同样在多重集合上进行并行迭代也要用迭代器迭代。 下面演示如何过滤Collection集合： 12345static void filter(Collection&lt;?&gt; c)&#123; for(Iterator&lt;?&gt; it = c.iterator();it.hasNext();)&#123; if(?cond(it.next())) it.remove(); &#125;&#125; Collection接口的批量操作下面展示表现批量操作强大功能的一个示例，从一个名为c的Collection中移除一个指定元素e的所有实例： 1c.removeAll(Collections.singleton(e))； 或者也可以移除所有null元素： 1c.removeAll(Collections.singleton(null))； Collections.singleton是一个静态工厂方法，返回一个只包含指定元素的不可变Set集合(没有重复元素)。 在例子中Collections.singleton(e)方法只包含元素e的Set集合，然后就可以用removeAll删除。 Collection数组操作toArray()方法主要作为集合和老的期望输入数组的API之间的桥梁。 1234567891011// 创建并初始化一个 ListList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);// 使用 toArray() 方法将集合转换为 Object 数组Object[] array = list.toArray();// 使用 toArray(T[] a) 方法将集合转换为指定类型的数组String[] array = list.toArray(new String[0]); Set接口Set是一个不能包含重复元素的接口，是Collection接口的子接口，并且只包含从Collection继承过来的方法，并增加了对add()方法的使用限制，不允许有重复的元素。Set()还修改了equals()和hashCode()方法的实现，允许对Set实例进行内容上的比较，即使它们实现类型不同。如果两个Set实例包含相同的元素，那么它们就是相等的。 Set定义主要方法: 继承了Collection接口的所有方法。 没有专门定义新的方法，但子接口和实现类提供了对集合不重复性要求的具体实现。 主要实现类: HashSet: 基于哈希表的实现，不保证元素的顺序，通常提供快速的插入、删除和查找操作。 TreeSet: 基于红黑树的实现，按自然顺序或构造时提供的比较器进行排序。 LinkedHashSet: 结合了哈希表和链表的特点，保持插入顺序的同时提供较快的操作速度。 Java平台包含3个通用目的的Set实现就是HashSet、TreeSet、LinkedHashSet这三个。 Set接口的基本操作那么Set和Collection有什么区别呢？下面看这个实例。 12345678910111213141516171819202122import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class CollectionSetExample &#123; public static void main(String[] args) &#123; // 使用 Collection 接口 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); collection.add(&quot;Apple&quot;); collection.add(&quot;Banana&quot;); collection.add(&quot;Cherry&quot;); System.out.println(&quot;Collection: &quot; + collection); // 使用 Set 接口 Set&lt;String&gt; set = new HashSet&lt;&gt;(); //这里用了哈希存放 set.add(&quot;Apple&quot;); set.add(&quot;Banana&quot;); set.add(&quot;Apple&quot;); // 重复元素不会被添加 System.out.println(&quot;Set: &quot; + set); &#125;&#125; 我们可以看到，这其中最大的区别就是Set不能重复添加元素。 Set接口的批量操作批量操作特别适合于Set接口： s1.containsAll(s2)：如果s2是s1的一个子集合，返回true s1.addAll(s2)：将s1变换为s1和s2的并集 s1.retain(s2)：将s1变换为s1和s2的交集 s1.removeAll(s2)：将s1不对称地变换为s1和s2的差集 addAll示例： 12345678910111213Set&lt;String&gt; set1 = new HashSet&lt;&gt;();set1.add(&quot;Apple&quot;);set1.add(&quot;Banana&quot;);Set&lt;String&gt; set2 = new HashSet&lt;&gt;();set2.add(&quot;Cherry&quot;);set2.add(&quot;Date&quot;);// 将 set2 的所有元素添加到 set1 中set1.addAll(set2);System.out.println(&quot;Set1 after addAll: &quot; + set1);//Set1 after addAll: [Apple, Banana, Cherry, Date] removeAll示例： 12345678910111213Set&lt;String&gt; set1 = new HashSet&lt;&gt;();set1.add(&quot;Apple&quot;);set1.add(&quot;Banana&quot;);set1.add(&quot;Cherry&quot;);Set&lt;String&gt; set2 = new HashSet&lt;&gt;();set2.add(&quot;Banana&quot;);set2.add(&quot;Cherry&quot;);// 从 set1 中移除 set2 中的所有元素set1.removeAll(set2);System.out.println(&quot;Set1 after removeAll: &quot; + set1); List接口List是一个有序的集合(又是被称为序列)。List可以包含重复的元素。除了从Collection继承过来的操作之外，List接口还包括以下操作： 按位置访问：根据元素在序列中的位置索引访问元素 查找：在序列中查找指定对象，并返回其位置索引 迭代：扩展了Iteractor接口，以利用序列的顺序特性 List子集合：在序列上执行任意范围的操作 List接口的定义如下： 1234567891011121314import java.util.Collection;public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; void add(int index, E element); boolean addAll(int index, Collection&lt;? extends E&gt; c); E get(int index); E set(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; Java平台常见的List实现包括： ArrayList（基于动态数组）、LinkedList（基于双向链表）和 Vector（线程安全的动态数组）。 List接口的操作1. 添加元素 void add(int index, E element) 在指定位置插入元素。 示例: 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(1, &quot;Orange&quot;); // 在位置 1 插入 &quot;Orange&quot; boolean addAll(int index, Collection&lt;? extends E&gt; c) 从指定位置开始，将指定集合中的所有元素添加到当前列表中。 示例: 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);List&lt;String&gt; newItems = Arrays.asList(&quot;Orange&quot;, &quot;Grapes&quot;);list.addAll(1, newItems); // 从位置 1 开始添加 newItems 中的元素 2. 访问元素 E get(int index) 获取指定位置的元素。 示例: 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);String item = list.get(0); // 获取位置 0 的元素 E set(int index, E element) 替换指定位置的元素。 示例: 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.set(1, &quot;Orange&quot;); // 将位置 1 的元素替换为 &quot;Orange&quot; 3. 删除元素 E remove(int index) 移除指定位置的元素。 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.remove(1); // 移除位置 1 的元素 4. 查找元素 int indexOf(Object o) 返回指定元素第一次出现的索引，如果不在列表中，则返回 -1。 示例: 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);int index = list.indexOf(&quot;Banana&quot;); // 获取 &quot;Banana&quot; 的位置 int lastIndexOf(Object o) 返回指定元素最后一次出现的索引，如果不在列表中，则返回 -1。 示例: 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Banana&quot;);int index = list.lastIndexOf(&quot;Banana&quot;); // 获取 &quot;Banana&quot; 最后出现的位置 5. 子列表 List&lt;E&gt; subList(int fromIndex, int toIndex) 返回当前列表中从 fromIndex（包含）到 toIndex（不包含）的部分列表。 1234567List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);list.add(&quot;Date&quot;);List&lt;String&gt; subList = list.subList(1, 3); // 获取子列表 [Banana, Cherry] 6. 迭代器 ListIterator&lt;E&gt; listIterator() 返回一个 ListIterator，从列表的开始处迭代。 ListIterator&lt;E&gt; listIterator(int index) 返回一个 ListIterator，从指定的位置开始迭代。 1234567891011121314List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);ListIterator&lt;String&gt; iterator = list.listIterator();while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;ListIterator&lt;String&gt; iteratorFromIndex = list.listIterator(1);while (iteratorFromIndex.hasNext()) &#123; System.out.println(iteratorFromIndex.next());&#125; Map接口Map接口的定义1234567891011121314151617181920212223242526272829import java.util.Collection;import java.util.Set;public interface Map&lt;K, V&gt; &#123; //基本操作 int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); //批量操作 void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); //集合视图 Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); //嵌套接口 interface Entry&lt;K, V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); &#125;&#125; Java平台包括3中通用的Map实现：HashMap、TreeMap和LinkedHashMap。 Map接口的基本操作1. 基本操作 int size() 返回 Map 中键值对的数量。 示例: 12345Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;One&quot;, 1);map.put(&quot;Two&quot;, 2);int size = map.size(); // 返回 2 boolean isEmpty() 检查 Map 是否为空（即是否没有键值对）。 示例: 1boolean isEmpty = map.isEmpty(); // 返回 false 2. 键和值的存在性检查 boolean containsKey(Object key) 检查 Map 是否包含指定的键。 示例: 1boolean hasKey = map.containsKey(&quot;One&quot;); // 返回 true boolean containsValue(Object value) 检查 Map 是否包含指定的值。 示例: 1boolean hasValue = map.containsValue(2); // 返回 true 3. 获取和设置键值对 V get(Object key) 根据键获取对应的值。如果键不存在，则返回 null。 示例: 1Integer value = map.get(&quot;One&quot;); // 返回 1 V put(K key, V value) 将指定的键值对添加到 Map 中。如果键已经存在，则更新对应的值，并返回之前的值。 示例: 1map.put(&quot;Three&quot;, 3); // 将 &quot;Three&quot; 键与 3 值添加到 map 中 V remove(Object key) 根据键移除对应的键值对，并返回被移除的值。 示例: 1Integer removedValue = map.remove(&quot;Two&quot;); // 移除 &quot;Two&quot; 键对应的值 2 4. 批量操作 void putAll(Map&lt;? extends K, ? extends V&gt; m) 将指定 Map 中的所有键值对添加到当前 Map 中。 示例: 12345Map&lt;String, Integer&gt; anotherMap = new HashMap&lt;&gt;();anotherMap.put(&quot;Four&quot;, 4);anotherMap.put(&quot;Five&quot;, 5);map.putAll(anotherMap); // 将 anotherMap 的所有键值对添加到 map 中 void clear() 移除 Map 中的所有键值对，使 Map 变为空。 示例: 1map.clear(); // 清空 map 5. 视图操作 Set&lt;K&gt; keySet() 返回 Map 中所有键的集合。 示例: 1Set&lt;String&gt; keys = map.keySet(); // 获取 map 的所有键 Collection&lt;V&gt; values() 返回 Map 中所有值的集合。 示例: 1Collection&lt;Integer&gt; values = map.values(); // 获取 map 的所有值 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 返回 Map 中所有键值对的集合，每个键值对作为 Map.Entry 对象存在。 示例: 1234Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());&#125; 6. 嵌套接口 Entry K getKey() 返回 Map.Entry 对象中的键。 V getValue() 返回 Map.Entry 对象中的值。 V setValue(V value) 设置 Map.Entry 对象中的值，并返回之前的值。 boolean equals(Object o) 判断两个 Map.Entry 对象是否相等。 int hashCode() 返回 Map.Entry 对象的哈希码。 示例比如我们可以做一个数组中单词的显示次数小程序： 1234567Map&lt;String,Integer&gt; m = new HashMap&lt;&gt;();for(String a : args)&#123; Integer freq = m.get(a); m.put( a, (freq == null) ? 1 : freq+1 ); //（键，值）&#125;System.out.println(m.size() + &quot;个不同的单词&quot;);System.out.println(m); args: 1java to is is be if if output: 125个不同的单词&#123;java=1, be=1, is=2, to=1, if=2&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"AutoCAD学习笔记","slug":"AutoCAD学习笔记","date":"2024-08-27T15:20:24.000Z","updated":"2024-08-28T06:54:22.527Z","comments":true,"path":"2024/08/27/AutoCAD学习笔记/","link":"","permalink":"https://bayeeaa.github.io/2024/08/27/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"AutoCAD学习笔记这段时间在金工行业实习了一段时间，了解到一般机械制图是用到cad来绘画草图，然后再将画出的.dwg文件导入到ug(或者solidworks)中将其拉伸成3d图形。下面我将记录下这段时间使用cad的较多的快捷键以及指令操作。 界面设置介于方便我们操作，免得每次都要点开找，我们可以将一些常用的操作直接放在边框layout处。 那么怎么设置呢？我们可以右键上方layout处(灰色处)，然后将光标放到AutoCAD上： 然后将出现的小框拖到上述界面的位置即可，这样方便我们使用。 命令操作常用快捷键 快捷键 操作 快捷键 操作 l (L) 直线 s 拉伸 e 清除 tr 修剪 co 复制 ex 延伸 m 移动 cha 倒直角 o 偏移 f 倒圆角 c 圆 dli 直线标注 上面这些快捷键只需要对着界面输入然后按下空格(或者回车)后就可以触发。 还有一点，就是我们要是按下空格就可以重复上一个操作，比如我c完一个圆后还想画一个圆，那就再按下空格，就可以直接再画一个圆。 c圆我们对着界面输入c然后空格后，光标处就会变成十字形，然后只需在图中点一下就可以圆出来： 注意我们可以看到下面命令框告诉我们可以输入圆的半径，比如我们想让圆的半径为10mm，那我们就可以输入10然后空格，或者想要直径为10mm，那就要输入d+空格，然后再输入10。 我们可以用旁边的标记列操作看下是否是10mm： 注意这里只是用于检查，实际标注不能用和轮廓线一样颜色的线。 l直线这里注意我们画下直线的时候会出现两个标注： 长度和角度可以用tab键来切换输入(如果没有这两个框是没有点开正交模式左边那个加号按钮)。 如果我们希望更方便操作角度我们可以开启下面的两个模式： 正交模式 (f8)：点开后直线就是只能为直角(正交)状态。 极角模式 (f10)：可以设置角度，点开到相应角会有直线吸附。 e清除这个很好理解，我们只需要选中需要被删除的线段，按下e+空格即可。 co复制我们co完后指令框显示： 也就是告诉我们需要选中对象。比如我像copy一个圆，那我选择这个圆后，再按下空格，然后出现： 告诉我们寻找基准线，我以点圆的中心为例。 可以看到一个新圆已经被复制出来。 m移动移动跟复制同理，需要选中对象，然后确定基准点来移动。 o偏移o+空格后出现下图 当我们输入距离(比如8mm)，然后再空格，选中对象就可以了 ro旋转和上一个一样，都是选中对象，然后选中基准点，再输入旋转角度。 tr修剪这个特殊点，比如我们要删除这段： 我们就可以tr+两个空格(注意是两个空格)。然后就可以对这段点一下就可以删除了。 ex延伸这个需要选中两个对象，要求这两个对象是要有交点的，然后就可以延长一个对象直至相交。 f倒圆角、cha倒直角倒角只需要我们输入f + r(倒角半径)，然后再指定两个对象即可。 dli正交直线标注也就是直线注释，这里注意是正交线，如果是斜线的话要输入dal。 螺纹孔标注这里附上一张实习用到的表： 我们可以看到不同螺纹孔大小都是有标准的螺纹距离和深度的。比如我们想话一个M6的螺纹孔，我们要这样画： 由于螺纹只有长度的，因此我们在画实际钻孔时要减去螺纹的长度。注意图中标注的细节，这些可以在图层里设置，方便我们选用： 阴影标注找到左边列的打圈处，选中。 点击“添加：拾取点”就可以选择需要阴影的位置了，选择成功再空格选择比例、样例，点击确定即可。 一圆与两圆相切同样我们c+空格打开圆的快捷键，然后选择图中操作。 然后选择圆中需要相切的两个位置，再输入圆的半径即可。 块创建块说白了就是自己写一个模板然后方便下次直接用。 比如我随便画一个矩形想作为块： 我们可以点开绘画然后找到块创建 然后就可以输入名称保存了，需要时就i + 空格换出块就行了。 实际运用中比如这个粗糙度的标注符号在cad里是没有的，那就可以自己画一个然后创建块，方便后续使用。","categories":[],"tags":[{"name":"制图","slug":"制图","permalink":"https://bayeeaa.github.io/tags/%E5%88%B6%E5%9B%BE/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2024-08-21T14:17:45.000Z","updated":"2024-09-16T07:27:46.866Z","comments":true,"path":"2024/08/21/KMP算法/","link":"","permalink":"https://bayeeaa.github.io/2024/08/21/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"KMP算法KMP:一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。——某位哲学大师(雾) 上面这句话很直观的体现了kmp算法的一个重要的特点：前后缀比较。比如我们看下面这道例题： 找出字符串中第一个匹配项的下标给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例 1： 123输入：haystack = &quot;abxabcabcaby&quot;, needle = &quot;abcaby&quot;输出：6解释：&quot;abcaby&quot; 在下标 6 处匹配。 示例 2： 123输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。 提示： 1 &lt;= haystack.length, needle.length &lt;= 104 haystack 和 needle 仅由小写英文字符组成 普通暴力解法最直观的解法就是双循环，把haystack里面的字符都遍历一遍，然后再看这个字符后面是不是和needle匹配的，要是有不匹配的，直接break。 123456789101112131415161718192021222324class Solution &#123; public int strStr(String haystack, String needle) &#123; if (needle.length() == 0) &#123; return 0; // 如果 needle 是空字符串，则返回 0 &#125; if (haystack.length() &lt; needle.length()) &#123; return -1; // 如果 haystack 比 needle 短，则不能包含 needle &#125; for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) &#123; int j; for (j = 0; j &lt; needle.length(); j++) &#123; if (haystack.charAt(i + j) != needle.charAt(j)) &#123; break; // 如果字符不匹配，退出内层循环 &#125; &#125; if (j == needle.length()) &#123; return i; // 如果完整匹配，返回起始位置 &#125; &#125; return -1; // 如果没有找到 needle，返回 -1 &#125;&#125; 可以看到这里套了双层循环，假设m&#x3D;haystack.length() - needle.length() ,n&#x3D;needle.length()那么时间复杂度是O(mn)。但是如果我们使用kmp算法，就可以让时间复杂度控制到O(m+n)。 KMP思路我们想想当在字符串比较的时候，什么操作是多余的操作？ 12text: abxabcabcabypattern: abcaby 以上述例子比较的时候可以发现：在text的[3:7]部分是和pattern[0:4]部分是重合的，由于最后一个y和text中的下一个c没对上，所以没有配对成功，但是在pattern这部分前面的[0:4]中前缀”ab”和后缀的”ab”是一样的，说明我们只需要重新比较text中[6:7]这个”ab”后面的与pattern[0:1]这个”ab”后面的即可，不用再重新比较”ab”。这样就可以优化算法。 next表为了方便我们这样索引，我们将要建立一个next表，里面记录的是由后缀到前缀的索引值，也就是说当我们匹对字符串的时候，如果发现不对，那只需要通过索引值跳到需要比较的部分。 建立思路首先我们给pattern字符串前面加上一个哨兵空字符，为什么要加这个呢？这里是由于之后我们比较的时候如果指针指的字符不匹配，那么我们就要找到指针前面那个字符的所对应的索引值，如果我们加上一个哨兵，那就可以每次不用指针减一，直接j就可以(有点拗口，之后看图会清楚点)。 以上就是next表创建的手画过程，用代码来写就是这样： 12345for(int i=2, j=0;i&lt;=m;i++)&#123; //p就是pattern的缩写，通过toCharArray()来变成字符数组 while(j&gt;0 &amp;&amp; p[j+1] != p[i]) j = next[j]; //如果对不上，就让j不断往前找，直到找到能对上的数 if(p[j+1] == p[i]) j++; //如果对上了，就让j向后移动一位 next[i] = j; //next赋值操作&#125; 可以看到i就是从2开始的，所以我在途中所以为1的地方就没有写值。 与字符串开始匹配 这里发现无法匹配后就直接通过b的前一个字符(a)的索引来向前找有没有为”x”的字符(然而没有)，于是j就停在哨兵字符上。 发现不符，j不动(因为j已经是最上面了，找不上去了)，text中的字符再往后面找。然后重复上面的步骤不停往后比对。最后发现”y”和⑥的”c”不符，于是乎j就往下找(此时j下面的索引为2，因此j跳到”b”上，j+1为”c”)，此时我们就只需要比较”c”和text后面的值了(因为我们知到了”ab”肯定是一样的，不用再比较了)。 这一步就是kmp算法的核心，有了上面这个思路我们就可以解决上面的例题了。 123456789101112131415161718192021222324252627class Solution &#123; public int strStr(String ss, String pp) &#123; if (pp.isEmpty()) return 0; int n = ss.length(), m = pp.length(); //注意长度的取值是在加入哨兵之前的 ss = &quot; &quot; + ss; //加入哨兵 pp = &quot; &quot; + pp; char[] s = ss.toCharArray(); char[] p = pp.toCharArray(); int[] next = new int[m + 1]; //创建next表 for(int i=2, j=0;i&lt;=m;i++)&#123; //填写next表 while(j&gt;0 &amp;&amp; p[j+1] != p[i]) j = next[j]; //找不到的情况，让&quot;j&quot;往前找 if(p[j+1] == p[i]) j++; //核对成功&quot;j&quot;往前走 next[i] = j; //将目前这个下标的值改成此时&quot;j&quot;的值 &#125; for(int i=1,j=0;i&lt;=n;i++)&#123; //核对字符 while(j&gt;0 &amp;&amp; s[i] != p[j+1]) j = next[j]; //找不到的情况，让&quot;j&quot;往前找 if(p[j+1] == s[i]) j++; //核对成功往前走 if(j == m)&#123; //长度相等就return return i - m; //输出第一个元素下标 &#125; &#125; return -1; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"static静态标签","slug":"static静态标签","date":"2024-08-14T02:17:15.000Z","updated":"2024-09-16T07:27:39.454Z","comments":true,"path":"2024/08/14/static静态标签/","link":"","permalink":"https://bayeeaa.github.io/2024/08/14/static%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","excerpt":"","text":"static静态变量我们都知道在测试文件中都需要有： 1public static void main(String[] args) 这段文字，而文字中public void main这几个我都已经数值，但是这个static是什么意思呢？今天我们来一起探讨一下这个词语。 属性静态调用当我们遇到不同的成员需要有相同的属性的时候，为了方便同时输入和调用属性，我们引入了static(静态)修饰符： user: 123456789101112131415161718192021222324252627282930313233package com.bayeeaa.demo1.d9_static;public class user &#123; private String name; private int number; public static String tea; //static修饰tea这个变量 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; public user(String name, int number) &#123; this.name = name; this.number = number; &#125; public void say() &#123; System.out.println(&quot;hi&quot;); &#125;&#125; test: 1234567891011package com.bayeeaa.demo1.d9_static;public class test &#123; public static void main(String[] args) &#123; user u1 = new user(&quot;bb&quot;,123); user u2 = new user(&quot;ye&quot;,11); user.tea = &quot;black tea&quot;; //直接对类进行调取 System.out.println(u2.tea); //black tea System.out.println(u1.tea); //black tea &#125;&#125; 我们可以看到当我们给tea用static修饰了之后，在test文件中我们就可以直接用类来进行赋值而不需要用成员来赋值，并且赋值后每个成员所访问的值都是一样的。被static所修饰的成员变量叫做静态变量，它有这三个特点： 被该类所有对象共享 不属于对象，属于类 随着类的加载而加载，优先于对象的存在 当然被static修饰的成员方法，叫做静态方法，它有这些特点： 多用在测试类和工具类中 Javabean类中很少会用到 这里我们就可以讨论到工具类的创建。 工具类创建创建一个工具类，首先我们要将其私有化，这样外部就不会创建这个类的对象了(因为我们这个要让这个类作为工具，那我们就要写死在这里了，不能再让别人有所操作，不然工具变化会带来不便)： 123public class ArrUtil &#123; private arrUtil()&#123;&#125;&#125; 我们写一个工具类的例子： ArrUtil: 12345678910111213141516171819202122232425package com.bayeeaa.demo1.d9_static;import java.util.ArrayList; //集合listpublic class ArrUtil &#123; private ArrUtil()&#123;&#125;; //工具类私有化 //设置为静态方便调用 public static int get_sum(int[] arr)&#123; //计算数组所有数据和 int sum=0; for (int i = 0; i &lt; arr.length; i++) &#123; sum = sum + arr[i]; &#125; return sum; &#125; public static int get_num_sum(ArrayList&lt;user&gt; list)&#123; //计算集合中所有对象的num属性和 int sum = 0; for (int i = 0; i &lt; list.size(); i++) &#123; sum = sum + list.get(i).getNumber(); &#125; return sum; &#125;&#125; test: 1234567891011121314151617181920212223package com.bayeeaa.demo1.d9_static;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3,4,5,6&#125;; System.out.println(ArrUtil.get_sum(a)); //输出数组的数字和 ArrayList&lt;user&gt; list = new ArrayList&lt;&gt;(); //这是个集合 user u1 = new user(&quot;ye&quot;,1); user u2 = new user(&quot;yee&quot;,2); user u3 = new user(&quot;yeee&quot;,12); list.add(u1); //对象压入集合 list.add(u2); list.add(u3); System.out.println(ArrUtil.get_num_sum(list)); //输出集合中num的和 &#125;&#125; 可以看到可以直接通过 类名.方法名() 来调用工具。 this关键字其实，static有这几个注意事项： 静态方法中，只能访问静态 非静态方法可以访问所有 静态方法中没有this关键字 而这几个关键都和this关键字有关。以下我来举一些例子。 test： 1234567891011package com.bayeeaa.demo1.d9_static;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; methods_class pj = new methods_class(); pj.repeat(); &#125;&#125; methods_class： 123456789101112131415package com.bayeeaa.demo1.d9_static;public class methods_class &#123; String s; public void repeat(methods_class this)&#123; System.out.println(this); //输出com.bayeeaa.demo1.d9_static.methods_class@b4c966a &#125; public static void again()&#123; System.out.println(this); //飘红，静态方法中没有this &#125;&#125; 我在methods_class文件中输出了两个方法，一个是非静态方法，一个是静态方法，当我们分别用test文件来打印的时候会发现第一个repeat方法打印出了对象的地址，而第二个again方法会报错。 在我们平时使用非静态方法应该是不会在非静态方法中手动调入methods_class this这个值的，但是我们却可以直接用方法调用，这是因为在非静态方法中是默认包括this的，而this的赋值又由jvm调取。所以说在非静态方法中如果我们要调用参数，比如num，实际上应该是这样的： 123public void repeat(methods_class this)&#123; System.out.println(this.s);&#125; 但是通过上图的报错我们可以看到静态方法中是没有this的。因此在其中要是强行引入this会导致报错。 有了这样的解释就可以理解上面的三个结论了。 内存解释在作内存解释之前我们要知道： 栈内存（Stack Memory） 结构和管理方式： 栈内存按照先进后出的原则进行管理（LIFO，即 Last In, First Out）。 内存分配和回收由系统自动管理。每当一个函数被调用时，系统会在栈上为其分配内存，函数返回时，这部分内存会被自动释放。 用途： 用于存储局部变量、函数调用参数和返回地址等。 栈内存的管理非常高效，因为内存分配和释放的操作非常简单，只需调整栈顶指针即可。 特点： 内存分配速度快。 栈内存的大小通常较小，固定大小，超过限制会导致栈溢出（stack overflow）。 数据的生命周期由函数调用的生命周期决定，一旦函数返回，栈内存中的数据就会失效。 堆内存（Heap Memory） 结构和管理方式： 堆内存没有固定的管理顺序，分配和释放内存是由程序员或垃圾回收机制管理的。 内存的分配和释放可以发生在程序的任何地方，不像栈内存那样有固定的顺序。 用途： 用于动态分配内存，比如创建对象、数组等，需要程序员显式地请求内存空间。 适用于需要在多个函数调用间共享数据的情况。 特点： 内存分配和释放相对较慢，因为涉及到更复杂的管理机制。 堆内存的大小通常较大，由操作系统和系统配置决定。 需要程序员显式管理内存，未正确释放的内存会导致内存泄漏（memory leak），一些语言如 Java 和 Python 使用垃圾回收机制来自动处理这一问题。 总结 栈内存适用于存储生命周期短、大小固定的数据，管理简单且高效。 堆内存适用于存储生命周期长或大小不确定的数据，管理复杂但灵活。 我们可以简单的将内存划为三个区域： 字节文件加载：引入main文件，加载里面的方法、类文件中的属性、静态属性等等。 然后开始创建对象，在堆内存中开辟一块地，并返回其地址给对象pj。 然后pj就可以根据地址去寻找所要找的元素。 main的解释现在我们再来看下我们每次的入口文件： 1public static void main(String[] args) public： 被JVM调用，访问权限足够大 static：被JVM调用，不用创建对象，直接类名访问。因为main方法是静态的，所以测试类中其他方法也需要是静态的。(这里注意下,不是静态的叫实例变量,非static方法需要new一个实例出来才能使用,这里意思是main默认只能调用静态方法,实例要new) void：被JVM调用，不需要给JVM返回值 main：一个通用的名称，虽然不是关键字，但是被JVM识别 String[] args：以前用于接收键盘录入数据的，现在没有，被保留是为了上下版本兼容","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"Java面向对象编程封装","slug":"Java面向对象编程封装","date":"2024-08-04T07:14:43.000Z","updated":"2024-09-16T07:27:15.392Z","comments":true,"path":"2024/08/04/Java面向对象编程封装/","link":"","permalink":"https://bayeeaa.github.io/2024/08/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%B0%81%E8%A3%85/","excerpt":"","text":"面向对象编程封装我们先从最简单的一个对象设置开始，设置一个phone对象，并赋予里面brand和number，为了进行比对，我让number私有化，而让brand变成public。 主入口文件： 1234567891011package com.bayeeaa.demo1;public class newphone &#123; public static void main(String[] args) &#123; phone p = new phone(); //通过：类名 对象名 = new 类名()来自定义对象 p.brand = &quot;小米&quot;; //这里为了形成对比没有让brand私有化 p.setNumber(20); System.out.println(p.getNumber()); &#125;&#125; 类文件： 1234567891011121314151617181920212223package com.bayeeaa.demo1;public class phone &#123; private int number; //private使这个number私有化，让其更改操作只能在本类中实现 String brand; public int getNumber()&#123; //这里方便输出内容 return number; &#125; public void setNumber(int n)&#123; //通过方法使对象值在本函数中实现改变，函数名最好用set+双驼峰写法 if(n&gt;=18 &amp;&amp; n&lt;50)&#123; number = n; &#125;else&#123; System.out.println(&quot;输入不被允许&quot;); &#125; &#125; public void call()&#123; System.out.println(&quot;手机在打电话&quot;); &#125; &#125; 我们可以看到当number被私有化后，其值的修改就只能在类文件中发送，这样可以提高文件的安全性，我们只要通过调用getNumber和setNumber函数就可以实现值的传递并修改。 两种不同的构造方式空参构造：123public phone()&#123; &#125; 不带任何的参数。 有参构造：1234public phone(String brand,int number)&#123; this.brand = brand; //this.brand指的是类中的brand，是成员变量。右边的brand是方法里的局部变量(this遵循就近原则) this.number = number;&#125; 这里的方法不带void或int等，没有return，是由于它的执行是由jvm调动的，所以主函数调用时候就会执行，无需手动执行。 主函数： 1phone p = new phone(&quot;小米&quot;,20); //有参函数直接可以传入数据 这样就可以直接传入参数。 快捷键：1234567public class User &#123; private String name; private int number; // alt + INSERT就可以帮我们快速生成constructer和set,get函数 // ptg插件也可以帮我们快速构造JAVABEAN&#125; alt + INSERT ptg这个方法需要在setting中下载ptg插件。 通过快捷键我们可以快速的进行javabean构造。 文字游戏的简单应用我们可以设置一个文字游戏，通过血量，攻击力等为对象创建属性，然后循环攻击最后输出结果。 类文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.bayeeaa.demo1.d3; //这里是package，不是import,这是类文件和主入口文件的区别import java.util.Random;public class Role &#123; private int blood; private String name; String[] attack_desc = &#123; &quot;虚弱地&quot;, //1~5 &quot;小心地&quot;, //6~10 &quot;用力地&quot;, //10~20 &#125;; String[] injureds_desc = &#123; &quot;他似乎自信满满&quot;, //HP 100~80 &quot;他认为还有胜算&quot;, //HP 79~50 &quot;他还不肯认输&quot;, //HP 49~20 &quot;他疲惫不堪&quot; //HP 20~0 &#125;; public Role() &#123; &#125; public Role(int blood, String name) &#123; //有参构造 this.blood = blood; //this所表示的就是这个对象的值 this.name = name; &#125; public int getBlood() &#123; //得到血量 return blood; &#125; public void setBlood(int blood) &#123; //设置血量 this.blood = blood; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int get_attack_desc(int hurt) &#123; //要注意这里函数最后无论如何都是要return 0的 if(hurt&lt;=5 &amp;&amp; hurt&gt;0) return 0; else if (hurt&lt;=10 &amp;&amp; hurt&gt;5) return 1; else if (hurt&lt;=20 &amp;&amp; hurt&gt;10) return 2; return 0; &#125;; public int get_injureds_desc(int remain) &#123; if(remain&lt;=100 &amp;&amp; remain&gt;=80) return 0; if(remain&lt;80 &amp;&amp; remain&gt;=50) return 1; if(remain&lt;50 &amp;&amp; remain&gt;=20) return 2; if(remain&lt;20 &amp;&amp; remain&gt;=0) return 3; return 0; &#125; public void attack(Role role)&#123; //Role赋予role这个变量意义，也就是变成了对象 Random r = new Random(); int hurt = r.nextInt(20) + 1; int remainblood = role.getBlood() - hurt; remainblood = remainblood &lt; 0 ? 0 : remainblood; //三元判断，&quot;?&quot;左边为结果，true就是左边的，false为右边 role.setBlood(remainblood); System.out.println(this.getName() + attack_desc[get_attack_desc(hurt)] + &quot;打了&quot; + role.getName() + &quot;&quot; + hurt + &quot;点血，&quot; + role.getName() +&quot;还剩&quot; + role.getBlood() + &quot;，&quot; + injureds_desc[get_injureds_desc(remainblood)]); //this为调用对象，这里的role就是调入参数 &#125;&#125; 主入口： 1234567891011121314151617181920package com.bayeeaa.demo1.d3;public class RoleTest &#123; public static void main(String[] args) &#123; Role r1 = new Role(100,&quot;500c&quot;); Role r2 = new Role(100,&quot;joker&quot;); while(true)&#123; r1.attack(r2); if(r2.getBlood() == 0)&#123; System.out.println(r1.getName() + &quot; Win&quot;); break; &#125; r2.attack(r1); if(r1.getBlood() == 0)&#123; System.out.println(r2.getName() + &quot; Win&quot;); break; &#125; &#125; &#125;&#125; 其中一次运行结果： 12345678910111213141516171819202122500c用力地打了joker11点血，joker还剩89，他似乎自信满满joker用力地打了500c16点血，500c还剩84，他似乎自信满满500c虚弱地打了joker4点血，joker还剩85，他似乎自信满满joker用力地打了500c17点血，500c还剩67，他认为还有胜算500c虚弱地打了joker4点血，joker还剩81，他似乎自信满满joker用力地打了500c16点血，500c还剩51，他认为还有胜算500c小心地打了joker7点血，joker还剩74，他认为还有胜算joker用力地打了500c19点血，500c还剩32，他还不肯认输500c用力地打了joker17点血，joker还剩57，他认为还有胜算joker虚弱地打了500c4点血，500c还剩28，他还不肯认输500c小心地打了joker10点血，joker还剩47，他还不肯认输joker虚弱地打了500c1点血，500c还剩27，他还不肯认输500c用力地打了joker19点血，joker还剩28，他还不肯认输joker用力地打了500c16点血，500c还剩11，他疲惫不堪500c小心地打了joker7点血，joker还剩21，他还不肯认输joker虚弱地打了500c2点血，500c还剩9，他疲惫不堪500c虚弱地打了joker5点血，joker还剩16，他疲惫不堪joker小心地打了500c8点血，500c还剩1，他疲惫不堪500c用力地打了joker17点血，joker还剩0，他疲惫不堪500c WinProcess finished with exit code 0 可以看到我在类文件中先是设置了name和blood两个参数，而其攻击值是随机生成的。我也在类函数中加入了attack_desc和injureds_desc两个字符串数组来形容当前两人的状态。具体解释看代码中的注释。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"}]},{"title":"Vue的生命周期","slug":"Vue的生命周期","date":"2024-08-03T18:01:21.000Z","updated":"2024-08-04T07:04:52.465Z","comments":true,"path":"2024/08/04/Vue的生命周期/","link":"","permalink":"https://bayeeaa.github.io/2024/08/04/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"Vue生命周期通俗的讲就是：一个vue实例从创建到销毁的整个过程 ①创建(响应式数据) ②挂载(渲染模板) ③更新(修改数据更新视图) ④销毁(关闭页面,销毁实例) Vue生命周期函数 创建阶段（Creation）： beforeCreate：实例刚被创建，数据观测和事件机制初始化之前被调用。 created：实例已经创建完成，完成数据观测、属性和方法的运算，初始化事件等。 挂载阶段（Mounting）： beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted：实例已经挂载到 DOM 上后被调用。 更新阶段（Updating）： beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 updated：数据更新后调用，发生在虚拟 DOM 重新渲染和打补丁之后。 销毁阶段（Destroying）： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：实例销毁后调用。在这一步，所有事件监听器被移除，所有子实例被销毁。 错误处理阶段（Error Handling）： errorCaptured：当子组件抛出错误时会触发该钩子。 为了深入的理解这段话，我们要知道什么是实例 实例在 Vue.js 中，”实例”（Instance）是指通过 Vue 构造函数创建的一个 Vue 实例对象。每个 Vue 应用都是通过创建一个 Vue 实例来实现的。当您使用 Vue 构造函数创建一个实例时，您可以传入一个选项对象，用于配置该实例的行为。 在 Vue 实例中，您可以定义数据、计算属性、方法、生命周期钩子函数等。这些属性和方法定义了该实例的行为和功能。Vue 实例还可以与 DOM 元素进行绑定，从而实现数据的双向绑定、事件处理等功能。 下面是一个简单的示例，演示了如何创建一个 Vue 实例： 12345678910111213141516// 创建一个 Vue 实例var vm = new Vue(&#123; // 选项对象 el: &#x27;#app&#x27;, // 指定要挂载的元素 data: &#123; message: &#x27;Hello, Vue!&#x27; &#125;, methods: &#123; greet: function() &#123; alert(this.message); &#125; &#125;, created: function() &#123; console.log(&#x27;Vue 实例已创建&#x27;); &#125;&#125;); 在上面的示例中，我们创建了一个 Vue 实例 vm，并传入了一个选项对象，其中包含了 el、data、methods 和 created 等属性。这个实例可以通过 vm 来访问，并且可以调用定义的方法、访问数据等。 Vue3 Composition API进入到vue3后，组合式API大为推广，在这其中的生命钩子函数有了更灵活的运用，有了这样的变化： onBeforeMount: 在组件挂载之前执行的函数，类似于 Vue 2.x 中的 beforeMount 钩子函数。 onMounted: 在组件挂载到 DOM 后执行的函数，类似于 Vue 2.x 中的 mounted 钩子函数。 onBeforeUpdate: 在组件更新之前执行的函数，类似于 Vue 2.x 中的 beforeUpdate 钩子函数。 onUpdated: 在组件更新完成后执行的函数，类似于 Vue 2.x 中的 updated 钩子函数。 onBeforeUnmount: 在组件卸载之前执行的函数，类似于 Vue 2.x 中的 beforeUnmount 钩子函数。 onUnmounted: 在组件卸载后执行的函数，类似于 Vue 2.x 中的 unmounted 钩子函数。 onActivated: 在组件被激活时执行的函数，用于配合 &lt;keep-alive&gt; 组件使用。 onDeactivated: 在组件被停用时执行的函数，用于配合 &lt;keep-alive&gt; 组件使用。 onErrorCaptured: 捕获子组件抛出的错误，类似于 Vue 2.x 中的 errorCaptured 钩子函数。 代码演示我们分两组进行演示，分别是onBeforeMount和onMounted，onBeforeUpdate和onUpdated。其中用到比较多的就是Mounted这组。 onMounted我们输入以下代码 1234567891011121314151617&lt;template&gt; &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onMounted, onBeforeMount &#125; from &#x27;vue&#x27;const title = &#x27;hello&#x27;onBeforeMount(() =&gt; &#123; console.log(&quot;onBeforeMount: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //undefined&#125;)onMounted(() =&gt; &#123; console.log(&quot;onMounted: &quot;, document.querySelector(&quot;h3&quot;)?.innerHTML); //hello&#125;)&lt;/script&gt; 我们可以看到我们分别让两个生命周期函数打印出此时的值，可以看到注释里的结果，在onBeforeMount，也就是实例还挂载到DOM上，此时还没有开始渲染因此式undefined，在onMounted里，hello被打印了出来，说明此时已经完成了渲染，可以操作DOM了。因此我们平时都习惯将网页进入时就需要触发的函数放在onMounted里，防止函数无法准确获取到DOM元素。 onUpdated1234567891011121314151617181920&lt;template&gt; &lt;h2&gt;&#123;&#123; count &#125;&#125;&lt;/h2&gt;&lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onBeforeUpdate, onUpdated, ref &#125; from &#x27;vue&#x27;let count = ref(1)onBeforeUpdate(() =&gt; &#123; console.log(&quot;onBeforeUpdate&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML) //1&#125;)onUpdated(() =&gt; &#123; console.log(&quot;onUpdated&quot;, document.querySelector(&quot;h2&quot;)?.innerHTML); //2&#125;)const add = () =&gt; &#123; count.value++ &#125;&lt;/script&gt; 可以看到这里就是差异在内部数据更改和视图更新的区别，在onBeforeUpdate时数据并没有发生更新，而在onUpdated数据发生了更新并且可以显示出来。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"}]},{"title":"git使用时出现的问题小汇总","slug":"git使用时出现的问题小汇总","date":"2024-07-29T11:21:51.000Z","updated":"2024-08-01T12:48:51.561Z","comments":true,"path":"2024/07/29/git使用时出现的问题小汇总/","link":"","permalink":"https://bayeeaa.github.io/2024/07/29/git%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/","excerpt":"","text":"git提交1234git add * //将所有上传文件进入缓存区域git commit -m &quot;submit&quot; //提交申请注释，双引号里面就是注释内容(*) git remote add origin https //关联远程仓库，关联后以后就可以不再重复关联git push -u origin main //推入仓库main分支 -m在 git commit 命令中，-m 选项用于指定提交消息。Git 提交时需要一个消息来描述这次提交的目的或更改内容。使用 -m 选项可以让你在命令行中直接输入提交消息，而不是打开编辑器。使用 -m 选项可以快速地提供提交消息。 如果你不使用 -m 选项，Git 会打开你配置的默认文本编辑器（例如 Vim、Nano 等），让你在编辑器中输入提交消息。这适用于较长或复杂的提交消息，允许你在编辑器中进行详细描述和格式化。 -u在git push -u origin main中我们可以看到有个-u，-u 是–set-upstream的缩写。它的作用是将本地分支与远程分支建立跟踪关系。它有一下这几点作用： 将本地分支与远程分支关联起来，使得以后可以简化 git push 和 git pull 命令的使用。 设置当前分支的上游分支（即跟踪的远程分支），方便在以后的操作中，Git 可以自动推送和拉取数据。 error: failed to push some refs to ‘http’ 这个报错是指本地的文件和仓库中有冲突的部分，所以要先拉取github上的，然后再推上去。 12git pull origingit push origin main (或者master) error: src refspec main does not match any由于是新创建的仓库还没有main分支(或者是你还没切换到这个分支上面) 1git checkout -b main 切换到当前分支main。 如何将msater的内容合并到main分支，并删除master？要将 master 分支的内容合并到 main 分支，并删除 master 分支，你可以按照以下步骤进行操作。这些步骤假设你已经在本地仓库中，并且你希望在本地和远程仓库中同步这些更改。 切换到 main 分支： 确保你在 main 分支上，使用以下命令切换到 main 分支： 1git checkout main 更新 main 分支： 确保 main 分支是最新的。如果你正在使用远程仓库，先拉取远程更新： 1git pull origin main **合并 master 分支到 main**： 使用以下命令将 master 分支的内容合并到 main 分支： 1git merge master 如果有合并冲突，Git 会提示你解决冲突。解决所有冲突后，完成合并并提交更改： 12git add &lt;conflicted-files&gt;git commit 推送合并后的 main 分支到远程仓库： 将合并后的 main 分支推送到远程仓库： 1git push origin main 删除 master 分支： 在本地删除 master 分支： 确保你已经切换到 main 分支后，可以删除本地的 master 分支： 1git branch -d master 如果 master 分支没有完全合并到 main，而你确定要删除，可以使用 -D 强制删除： 1git branch -D master 在远程删除 master 分支： 使用以下命令将 master 分支从远程仓库删除： 1git push origin --delete master fatal: refusing to merge unrelated histories表示 Git 拒绝合并两个没有共同历史的分支或仓库。这通常发生在以下几种情况下： 两个分支或仓库的历史完全不同： 比如，你尝试合并两个完全不同的项目，或者一个是新创建的仓库，另一个是老的仓库。 从远程仓库克隆时历史不同： 如果你从一个远程仓库克隆了一个新的仓库，而本地仓库中已经有一些历史记录，Git 会认为这些历史不相关。 可以使用 --allow-unrelated-histories 选项来允许合并不相关的历史。以下是详细的步骤： 切换到 main 分支： 确保你在目标分支（通常是 main 分支）上： 1git checkout main 执行合并命令并允许不相关的历史： 使用 --allow-unrelated-histories 选项来合并 master 分支到 main 分支： 1git merge master --allow-unrelated-histories 这会允许 Git 合并两个没有共同历史的分支。 解决合并冲突： 如果在合并过程中遇到冲突，Git 会提示你解决这些冲突。解决冲突后，完成合并： 12git add &lt;conflicted-files&gt;git commit 推送合并后的 main 分支到远程仓库： 将合并后的 main 分支推送到远程仓库： 1git push origin main","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"},{"name":"Git","slug":"Git","permalink":"https://bayeeaa.github.io/tags/Git/"}]},{"title":"vue3+ts项目的基本路由配置","slug":"vue3-ts项目的基本路由配置","date":"2024-07-20T08:06:02.000Z","updated":"2024-08-03T18:03:49.260Z","comments":true,"path":"2024/07/20/vue3-ts项目的基本路由配置/","link":"","permalink":"https://bayeeaa.github.io/2024/07/20/vue3-ts%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/","excerpt":"","text":"导入router首先在main.ts文件中导入router，并将其use入app中让其挂载。 12import router from &#x27;./router&#x27;;app.use(router) 这样就可以在app中导入router了。 路由文件index.ts配置为了更标准，我们在src文件中创立一个router文件夹，然后在文件夹中创建index.ts文件。 在index文件中，我们就可以将组件的路径记录到其中，这样就可以按照需要访问组件了。 12345678910111213141516import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &#x27;@/components/Home.vue&#x27;const router = createRouter(&#123; history:createWebHistory(), routes:[ &#123; name:&#x27;shouye&#x27; path:&#x27;/Home&#x27; , component: Home, &#125; ]&#125;)//将router暴露出去(default 默认)export default router 我们先导入createRouter和createWebHistory(或createWebHashHistory)，然后再const一个router对象，里面存入history和routes。像这里我导入的是Home.vue组件，然后就可以在routes中写入path和component(path可以和组件的名字不一样，而且浏览器地址栏是不区分大小写的)。在router中history是必不可少的，其中有两种模式可以选择，我们这里选择createWebHistory。 最后不要忘记将router方法暴露出去。 这样我们就已经可以访问”&#x2F;home”组件了，但是我们的组件应该要配合layout来显示，具体放在页面的那个地方才合适呢？ 控制组件存放位置使用中存放组件的位置用RouterView标签，触发标签用RouterLink标签。 首先我们还是一样要在script中导入RouterView，RouterLink： 1import &#123; RouterView, RouterLink &#125; from &#x27;vue-router&#x27; 然后就可以在template中使用了： 123&lt;div :style=&quot;&#123; padding: &#x27;24px&#x27;, background: &#x27;#fff&#x27;, minHeight: &#x27;600px&#x27; &#125;&quot;&gt; &lt;RouterView&gt;&lt;/RouterView&gt; &lt;/div&gt; 其中组件都会在RouterView的位置显示。而我们触发事件就要： 1&lt;RouterLink to=&quot;/home&quot;&gt; 首页 &lt;/RouterLink&gt; 这里需要配合button等来配合使用。 当然考虑到地址的变化，也可以这样写RouterLink： 1&lt;RouterLink :to=&quot;&#123;path:/home&#125;&quot;&gt; 首页 &lt;/RouterLink&gt; 或者： 1&lt;RouterLink :to=&quot;&#123;name:shouye&#125;&quot;&gt; 首页 &lt;/RouterLink&gt; 子路由配置我们上面配置都是一级路由，而二级子路由要怎么配置呢？ 首先我们找到index.ts文件，再里面添加children在path中： 12345678910111213141516const router = createRouter(&#123; history:createWebHistory(), routes:[ &#123; name:&#x27;shouye&#x27;, path:&#x27;/Home&#x27; , component:Home, children:[ &#123; path:&#x27;detail&#x27;, //不要加斜杠 component:Detail, &#125; ] &#125; ]&#125;) 然后我们只需在RouterLink里面修改to的路径就可以了，也就是我们可以localhost&#x2F;home&#x2F;detail来访问子组件了。 路由传参方法query使用query传参我们需要在RouterLink的to中加入需要传入的值，比如我们想传给子组件“qq”一词： 1&lt;RouterLink to=&quot;/detail?a=qq&amp;b=kk&quot;&gt;&lt;/RouterLink&gt; 可以看到我给子组件通过“路径?变量&#x3D;值”将值传递，然后在子组件中我们需要再导入router接收传递的信息，就可以使用了： 12import &#123; useRoute &#125; from &#x27;vue-router&#x27;;let route = useRoute() html: 1&#123;&#123; route.query.a &#125;&#125; 这样就可以在页面中呈现了。 顺便我们log route一下就可以看到页面传递的值： 而如果我们需要通过for来改变传递的值，可以按照示例中这样写： 12345&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt; &lt;RouterLink :to=&quot;`/detail?a=$&#123;shops.id&#125;`&quot;&gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt; &lt;/RouterLink&gt; &lt;/a-col&gt; 或者： 123456789101112&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt; &lt;RouterLink :to=&quot;&#123; path:&#x27;/detail&#x27; query:&#123; a:shops.id, &#125; &#125;&quot; &gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt; &lt;/RouterLink&gt; &lt;/a-col&gt; params与query传参不同的是，params传参在index.ts中的path需要提前占位，在to中就可以对path中占的位对号入座。 比如我在path中用x占位： 12path:&#x27;/detail/:x?&#x27;, //这里的冒号表示占位，问号表示这个地方可能有展位也可能没有（问号不加也可以）component:Detail, 然后在template中： 123&lt;RouterLink to=&quot;/detail/aa&quot;&gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt;&lt;/RouterLink&gt; 再在子组件中console.log(route)一下就可以发现： 最后用params接收： 1&#123;&#123; route.params.a &#125;&#125; 然后同样可以用变量传递的方式传参： 123456789101112&lt;a-col class=&quot;gutter-row&quot; :span=&quot;6&quot; v-for=&quot;shops in datashop&quot; &gt; &lt;RouterLink :to=&quot;&#123; name:&#x27;xiangqing&#x27; query:&#123; a:shops.id, &#125; &#125;&quot; &gt; &lt;div class=&quot;gutter-box&quot;&gt;&#123;&#123; shops.title &#125;&#125;&lt;/div&gt; &lt;/RouterLink&gt; &lt;/a-col&gt; 但注意这里不能用path，只能用name来判断路径。 props配置第一种写法在路由配置中加上props:true，再在组件中加入defineProps([… , … ,])就可以将路由收到的params参数作为props传给组件。 子路由： 123456&#123; name:&#x27;xiangqing&#x27;, path:&#x27;/detail/:id/:title/:content&#x27;, component:Detail, props:true&#125;, 组件： 1defineProps([&#x27;id&#x27;,&#x27;title&#x27;,&#x27;content&#x27;]) 使用： 1&#123;&#123; id &#125;&#125; 第二种写法也可以传递query参数： 12345678&#123; name:&#x27;xiangqing&#x27;, path:&#x27;/detail/:id/:title/:content&#x27;, component:Detail, props(route)&#123; return route.query &#125;&#125;, 总结query不用占位，params需要占位。 本节使用RouterLink标签进行跳转，其中to属性解释来添加跳转的位置，可以用对象的方法书写。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"},{"name":"TS","slug":"TS","permalink":"https://bayeeaa.github.io/tags/TS/"}]},{"title":"vite构建的项目“@”地址无法解析问题","slug":"vite构建的项目“-”地址无法解析问题","date":"2024-07-19T14:36:33.000Z","updated":"2024-07-19T14:43:38.611Z","comments":true,"path":"2024/07/19/vite构建的项目“-”地址无法解析问题/","link":"","permalink":"https://bayeeaa.github.io/2024/07/19/vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E2%80%9C-%E2%80%9D%E5%9C%B0%E5%9D%80%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"使用vite构建项目后，发现无法识别”@”地址： 经过排查是由于config文件中没有配置”@”对应的路径： 12345678import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), ],&#125;) 打开vite.config.ts文件，改成： 123456789101112131415import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) //这里的配置就是可以让@可以读取成&#x27;./src&#x27; &#125; &#125;&#125;) 中间的reslove的alias所包含的就是”@”的配置项，这样我们就可以用@来代替.&#x2F;src。","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"}]},{"title":"IP地址","slug":"IP地址","date":"2024-07-10T09:15:10.000Z","updated":"2024-07-17T05:23:40.744Z","comments":true,"path":"2024/07/10/IP地址/","link":"","permalink":"https://bayeeaa.github.io/2024/07/10/IP%E5%9C%B0%E5%9D%80/","excerpt":"","text":"IP地址内网ip和公网ip内网IP（Internal Network IP）是指在局域网或者内部网络中使用的IP地址。在IPv4的网络中，内网IP地址通常属于私有IP地址范围，例如： 10.0.0.0 到 10.255.255.255 172.16.0.0 到 172.31.255.255 192.168.0.0 到 192.168.255.255 这些地址是专门为局域网内部使用而保留的，不会被分配到互联网上，因此可以重复使用。内网IP地址的作用是在局域网内部进行设备之间的通信和连接，比如连接本地打印机、路由器、局域网内的计算机等。 与内网IP相对的是公网IP（Public IP），公网IP是可以被全球互联网访问到的IP地址，用于在不同的网络之间进行通信。 我们可以通过 1$ ipconfig 来访问我们电脑现在的内网ip(也就是ipv4地址) 公网IP（Public IP）是指可以直接在全球互联网上访问到的IP地址。它是由互联网服务提供商（ISP，也就是移动，联通这些公司）分配给网络设备（如路由器、服务器等）的唯一标识符，用于在互联网上进行通信和数据交换。 公网IP地址是全球唯一的，不同的设备在互联网上需要具有不同的公网IP地址，这样才能保证它们之间能够正确地进行通信和数据传输。公网IP地址通常是静态或动态分配的，静态公网IP地址在一段时间内不会改变，而动态公网IP地址可能会在连接重新建立时发生变化。 通常情况下，个人用户使用的是动态公网IP地址，而企业或特定应用可能会使用静态公网IP地址，以便更稳定地提供服务和进行网络管理，一般情况下我们个人都是先使用内网然后再通过了路由将数据与公网进行交换，如果想要个人直接接入公网，需要向ISP特别申请。 通俗的说，内网ip与公网ip就好比寄快递，内网ip是几栋几号室，而公网ip是哪个省哪个市，有了这些ip地址后，我们才能把信息精确分配到每一个计算机个体。 ipv4和ipv6IPv4（Internet Protocol version 4）是互联网协议第四版，是当前广泛使用的互联网协议之一。IPv4定义了互联网上数据的传输方式，它使用32位（4个字节）的地址长度来标识网络上的每个设备或节点。 IPv4地址通常以点分十进制表示，例如：192.168.1.1。每个IPv4地址由四个八位组成，每个八位组可以表示0到255之间的数值，总共有约42亿个不同的IPv4地址。然而，由于互联网的迅速发展和设备的增多，IPv4地址已经逐渐不足以支持所有连接到互联网的设备。 为了解决IPv4地址耗尽的问题，IPv6（Internet Protocol version 6）被设计出来，它使用128位（16个字节）的地址长度，大大增加了可用的地址空间，预计能够长期解决IP地址耗尽的问题。IPv6的推广和采用逐渐增加，但目前仍然有大部分互联网流量使用IPv4协议。 总结起来，IPv4是互联网上广泛使用的网络协议之一，使用32位地址长度来标识网络上的设备或节点，其地址格式为点分十进制。 NAT由上面我们知道随着互联网的发展，ipv4逐渐枯竭。为了应对这样的情况，NAT（网络地址转换）技术孕育而生。 NAT 的主要类型包括： 静态 NAT：静态NAT是将一个固定的私有IP地址映射到一个固定的公共IP地址的一种形式，通常用于需要特定设备具有公共IP地址的情况，如服务器。 动态 NAT：动态NAT是动态地将内部设备的私有IP地址映射到公共IP地址池中的一个可用地址，通常在需要大量设备同时访问互联网时使用。 PAT（端口地址转换）：也称为Overload NAT，它允许多个设备使用相同的公共IP地址访问互联网，但通过不同的端口号进行区分。 一般情况我们我们就是通过路由器来将私有的ip地址映射到固定的公共ip地址，所以路由器在这里就充当了网关的作用。但是通过路由器传输的终端就不止一个，另一端接收方路由器对应的终端也不止一个，我们传输就无法一一对应，所以我们就要用到端口映射，通过端口号来确定我们要传输数据的终端彼此。 子网掩码在知道子网掩码之前，我们要知道什么是子网。 子网（Subnet）是指将一个大的IP地址块（IP地址空间）划分成若干个较小的子集，每个子集称为一个子网。在网络中，子网的作用是将一个大的网络划分成多个较小的、更易管理的部分，以便于组织和管理网络设备。 每个子网由一组连续的IP地址组成，这些IP地址共享一个公共的网络前缀（网络标识符）。这个网络前缀通常由IP地址和子网掩码（Subnet Mask）共同决定，子网掩码定义了IP地址中哪些部分是网络部分，哪些部分是主机部分。 子网的使用可以帮助网络管理员更有效地管理IP地址，减少广播风暴（Broadcast Storm）和冲突，提高网络的安全性和性能。常见的子网划分方式包括按照部门、功能或地理位置来划分子网，以便于根据需要对每个子网进行管理和配置。 那么如何确定这个ip是否在这个子网中呢？这就需要有子网掩码。子网掩码通过”&amp;”操作辨别子网： 121 &amp; X = X0 &amp; X = X 比如我们可以将： 12192.168.1.10 &amp; 255.255.255.0 = 192.168.1.0IP &amp; 子网掩码 =&gt; 结果相同 =&gt; 同一子网 如果我们通过ip和子网掩码的与操作都得到相同的结果，说明他们都在同一个子网当中。 端口端口（Port）是一种逻辑概念，用于区分不同应用程序或服务在同一台计算机上的通信终点。每个端口都有一个数字标识，称为端口号，用于标识特定的网络服务或应用程序。 主要特点和用途： 端口号：端口号是一个16位的整数，范围从0到65535。其中，0到1023的端口号被称为“系统端口”或“well-known端口”，它们通常分配给常见的网络服务，如HTTP（端口号80）、HTTPS（端口号443）、FTP（端口号21）等。 通信终点：在一台计算机上，每个运行的应用程序或服务都可以通过一个或多个端口号来进行通信。例如，Web服务器使用HTTP协议通过端口号80接收Web请求，而电子邮件服务器使用SMTP协议通过端口号25接收邮件。 传输层概念：端口属于传输层（第四层）协议的概念，在TCP&#x2F;IP模型中，这一层负责提供可靠的数据传输服务。TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们通过端口号来确定数据包应该被交付给哪个应用程序或服务。 端口分类： 系统端口：0到1023，预留给众所周知的服务。 注册端口：1024到49151，分配给用户进程或应用程序。 动态&#x2F;私有端口：49152到65535，用于临时的短暂会话。 端口的重要性： 多路复用：端口允许一台计算机上的多个应用程序同时进行网络通信，通过端口号区分不同的应用数据流。 网络安全：端口号有助于防火墙和安全设备识别和控制不同类型的网络流量，提高网络安全性。 网络管理：端口号使网络管理员可以轻松地监控和管理网络上的各种服务和应用程序。 以太网和因特网以太网（Ethernet）和因特网（Internet）是两个不同的概念，它们在计算机网络中有着不同的角色和范围。 以太网（Ethernet）： 定义：以太网是一种局域网（LAN）技术，用于在较小的范围内连接多台计算机和网络设备，如在办公室、校园或家庭内部。 传输介质：以太网通常使用双绞线、光纤或者无线电波作为传输介质，传输速度可以从几百Mbps到几十Gbps不等。 协议：以太网使用一组标准的数据链路层和物理层协议（如IEEE 802.3标准），定义了数据包在局域网内的传输方式。 拓扑结构：以太网的拓扑结构可以是星型、总线型或者环型，其中最常见的是星型拓扑，每台设备连接到一个中央集线器或交换机。 因特网（Internet）： 定义：因特网是全球范围内的公共计算机网络，由许多不同的网络（包括以太网、光纤网络、卫星网络等）连接起来，通过TCP&#x2F;IP协议族进行数据传输和通信。 范围：因特网是全球性的网络，连接了世界上几乎所有的计算机和网络设备，允许它们之间进行跨地域和跨国界的通信。 协议：因特网使用TCP&#x2F;IP协议族，包括TCP（Transmission Control Protocol）和IP（Internet Protocol），定义了数据在全球范围内的传输和路由方式。 服务和应用：因特网支持各种应用和服务，如电子邮件、网页浏览、文件传输、实时通信等，是人们日常生活中广泛使用的平台。 简单的说以太网就是局域网，而因特网就是互联网。 TCP&#x2F;IP协议TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）是一组通信协议，它定义了互联网和许多私有网络中数据如何传输和交换的标准。TCP&#x2F;IP协议族是现代互联网通信的基础，它包括多个协议，每个协议负责不同的功能。 IP（Internet Protocol）： IP协议负责在网络中传送数据包，并确保它们能够从源地址到目标地址安全地传输。 它定义了数据包的结构和格式，以及如何在网络中路由和转发数据包。 TCP（Transmission Control Protocol）： TCP协议是一种面向连接的协议，负责在通信的两端建立可靠的数据传输连接。 它确保数据包按顺序到达目的地，并处理丢失数据包的重传，以及流量控制和拥塞控制。 UDP（User Datagram Protocol）： UDP协议是一种无连接的协议，它提供了一种简单的数据传输服务，适用于实时应用程序和广播通信。 与TCP不同，UDP不保证数据的顺序和可靠性，但是它提供了较低的延迟和更高的传输速度。 其他协议： ICMP（Internet Control Message Protocol）：用于在IP网络上发送控制消息，如错误报告和网络诊断。 ARP（Address Resolution Protocol）：用于将IP地址映射为MAC地址（硬件地址）。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"前端如何将pdf等文件传入后端","slug":"前端如何将pdf等文件传入后端","date":"2024-07-04T13:12:22.000Z","updated":"2024-08-03T18:03:36.079Z","comments":true,"path":"2024/07/04/前端如何将pdf等文件传入后端/","link":"","permalink":"https://bayeeaa.github.io/2024/07/04/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86pdf%E7%AD%89%E6%96%87%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%90%8E%E7%AB%AF/","excerpt":"","text":"前端如何将pdf等文件传入后端我们知道在js中我们可以通过： 1&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot; accept=&quot;image/*&quot;&gt; 来输入文件。其中type指后端url，accept来限制传入类型。 前端通过表单形式将其传入后端那么前端是怎么将这一整个文件打包传入后端的呢？ 原来前端通过文件上传表单的方式将文件传输到后端。这通常涉及使用 HTML 的 &lt;form&gt; 元素和 &lt;input type=&quot;file&quot;&gt; 输入框，以及设置适当的表单属性来支持文件上传。 可以看到我在使用ant design vue框架时其文件传输的内容包含状态，上传时间，文件名字等。 文件上传的流程： 用户在文件输入框中选择一个文件。 用户点击提交按钮，浏览器将会把表单数据（包括选定的文件）打包成 multipart/form-data 格式的请求体。 请求被发送到指定的后端URL（在这个例子中是 /upload）。 后端接收到请求后，可以通过相应的框架或库来解析 multipart/form-data，获取到文件数据，并进行进一步处理，例如保存文件到服务器或者进行文件内容分析等操作。 文件上传表单示例：1234&lt;form id=&quot;uploadForm&quot; action=&quot;/upload&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt; &lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt;&lt;/form&gt; 解释： &lt;form&gt; 元素定义了一个表单，其中： action=&quot;/upload&quot; 指定了表单提交的目标后端URL。 method=&quot;POST&quot; 指定了使用POST方法提交表单。 enctype=&quot;multipart/form-data&quot; 表示表单中包含文件上传，这是必需的，因为文件上传需要使用 multipart/form-data 类型来传输文件数据。 &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;fileInput&quot;&gt; 是文件上传的输入框，其中： type=&quot;file&quot; 表示这是一个文件输入框，允许用户选择文件。 name=&quot;file&quot; 指定了后端接收文件时的字段名称，这个名称在后端处理文件时很重要。 id=&quot;fileInput&quot; 可以用来通过 JavaScript 获取文件输入框的引用，以便在用户选择文件后执行一些操作（例如显示文件名或大小）。 &lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt; 是一个提交按钮，点击它会触发表单提交操作。 后端处理文件上传的例子： Node.js（使用 Express 框架）： 123456789101112131415javascript复制代码const express = require(&#x27;express&#x27;);const multer = require(&#x27;multer&#x27;);const upload = multer(&#123; dest: &#x27;uploads/&#x27; &#125;);const app = express();app.post(&#x27;/upload&#x27;, upload.single(&#x27;file&#x27;), (req, res) =&gt; &#123; const file = req.file; // 处理文件，例如保存到服务器或者返回其他响应 res.send(&#x27;文件上传成功&#x27;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器运行在 http://localhost:3000&#x27;);&#125;); 在这个例子中，使用了 multer 中间件来处理单个文件上传，upload.single(&#39;file&#39;) 表示期望接收一个名为 file 的文件字段。 PHP： 1234567891011php复制代码&lt;?php$target_dir = &quot;uploads/&quot;;$target_file = $target_dir . basename($_FILES[&quot;file&quot;][&quot;name&quot;]);$uploadOk = 1;if (move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $target_file)) &#123; echo &quot;文件上传成功&quot;;&#125; else &#123; echo &quot;文件上传失败&quot;;&#125;?&gt; PHP 示例使用了 $_FILES 超全局数组来接收上传的文件，并使用 move_uploaded_file() 函数将文件从临时位置移动到指定的目标位置。 用JS将文件传入后端上面以及展示了html文件上传表单的示例，下面再展示通过JavaScript监听文件选择事件来传递。 html1234&lt;div&gt; &lt;input type=&quot;file&quot; id=&quot;File&quot;&gt; &lt;button&gt;点击上传文件&lt;/button&gt;&lt;/div&gt; JS绑定事件12345document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, e =&gt; &#123; let fileList = document.querySelector(&#x27;#File&#x27;).files&#125;)let fd = new FormData()fd.append(&#x27;aaa&#x27;,fileList[0]) 如果接口文档要求传递请求体(包括Content-Disposition, Content-Type等)我们使用window提供的FormData构造函数来实例化一个表单类型。 axios传递1234567axios(&#123; url: &#x27;&#x27;, method: &#x27;POST&#x27;, data: fd&#125;).then(res =&gt; &#123; console.log(res);&#125;) 通过ajax就可以将文件传入后端。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"}]},{"title":"面向JS的TypeScript","slug":"面向JS的TypeScript","date":"2024-07-02T05:52:53.000Z","updated":"2024-07-02T05:55:10.580Z","comments":true,"path":"2024/07/02/面向JS的TypeScript/","link":"","permalink":"https://bayeeaa.github.io/2024/07/02/%E9%9D%A2%E5%90%91JS%E7%9A%84TypeScript/","excerpt":"","text":"面向JS的TypeScript说到TypeScript，就不得不从Javascript说起。我们知道JavaScript（也称为 ECMAScript）最初是一种用于浏览器的简单脚本语言。在它被发明时，它被期望用于嵌入网页中的简短代码片段 - 编写几十行以上的代码有点不寻常。因此，早期的网络浏览器执行此类代码的速度非常慢。不过，随着时间的推移，JS 变得越来越流行，Web 开发者开始使用它来创建交互式体验。 JavaScript是一种为快速使用而设计的语言，与众不同的是，每种语言都有自己的“怪癖“，而 JavaScript 的卑微起步使其拥有许多这样的”怪癖“。 JavaScript 的相等运算符 (==) 强制转换其操作对象，导致意外行为： 123456if (&quot;&quot; == 0) &#123; // It is! But why??&#125;if (1 &lt; x &lt; 3) &#123; // True for any value of x!&#125; JavaScript 还允许访问不存在的属性： 123const obj = &#123; width: 10, height: 15 &#125;;// Why is this NaN? Spelling is hard!const area = obj.width * obj.heigth; TypeScript：静态类型检查器静态检查：在不运行代码的情况下检测代码中的错误。 TypeScript 能在执行前检查程序是否有错误，并根据值的种类进行检查，使其成为静态类型检查器。 比如： 1234const obj = &#123; width: 10, height: 15 &#125;;const area = obj.width * obj.heigth;* Property &#x27;heigth&#x27; does not exist on type &#x27;&#123; width: number; height: number; &#125;&#x27;. Did you mean &#x27;height&#x27;?Property &#x27;heigth&#x27; does not exist on type &#x27;&#123; width: number; height: number; &#125;&#x27;. Did you mean &#x27;height&#x27;? TypeScript是JavaScript的超集因此JS的许多语法在TS中是合法的。由于其语法，TypeScript 不会将任何 JavaScript 代码视为错误。这意味着你可以将任何有效的 JavaScript 代码放入 TypeScript 文件中，而不必担心它的具体编写方式。 语法12let a = (4 *&#x27;)&#x27;expected. 在TS中不会将任何JS代码看成错误。因此你可以将任何有效的JS都放入TS文件中，而不必担心其具体用法。 类型化的JS超集TS是一个类型超集，这意味着它添加了关于如何使用不同类型的值的规则。比如在一些JS中的错误不是语法错误而是“以不正确的方式使用某种值（类型）的错误”。 1console.log(4 / []); 这个语法上合法的程序记录了 Infinity。但是，TypeScript 将数字除以数组视为无意义的操作，并且会触发错误：“The right-hand side of an arithmetic operation must be of type ‘any’, ‘number’, ‘bigint’ or an enum type.”(分母必须是‘any’,’number’,’bigint’,’enum type’)。 运行时的行为TypeScript 也是一种保留了 JavaScript 运行时行为的编程语言。例如，在 JavaScript 中除以零会产生 Infinity 而不是抛出运行时异常。原则上，TypeScript 不会改变 JavaScript 代码的运行时行为。 擦除类型一旦TS的编译器检查完代码，它就会擦除类型以生成结果的“编译”代码。这意味着一旦代码被TS编译后。生成的普通JS就没有类型信息了。","categories":[],"tags":[{"name":"TS","slug":"TS","permalink":"https://bayeeaa.github.io/tags/TS/"}]},{"title":"二叉树的建立、遍历规则、以及节点计算","slug":"二叉树的建立、遍历规则、以及节点计算","date":"2024-06-21T17:24:02.000Z","updated":"2024-07-02T05:54:18.850Z","comments":true,"path":"2024/06/22/二叉树的建立、遍历规则、以及节点计算/","link":"","permalink":"https://bayeeaa.github.io/2024/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99%E3%80%81%E4%BB%A5%E5%8F%8A%E8%8A%82%E7%82%B9%E8%AE%A1%E7%AE%97/","excerpt":"","text":"二叉树的建立、遍历规则、以及节点计算二叉树故名思意就是只有两个度的树，这里讨论其最基本的用法及逻辑。 树的创立定义一颗二叉树首先要有一个度里的数据data，以及左右孩子，我们可以用结构体定义以方便其理解。 结构体定义：12345678typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;; 我们给左右孩子分别定位Left和Right，这样我们就可以使用T-&gt;Left和T-&gt;Right等方式进行调用，利于理解。 树的构建：1234567891011121314151617binTree creatBintree()&#123; int a; binTree b; scanf(&quot;%d&quot;, &amp;a); if (0 == a) //如果输入0，则停止创建 b = NULL; else &#123; b = (binTree)malloc(sizeof(struct binNode)); b-&gt;element = a; b-&gt;leftChild = creatBintree(); b-&gt;rightChild = creatBintree(); &#125; return b;&#125; 树的遍历当我们构建起了一个树后我们怎么对树进行遍历读取呢？可以用前、中、后序遍历，打比方我们用前序遍历就是通过（根、左、右）对树进行读取，也就是首先将最上面的节点作为root，然后将所有左边和右边的节点看作孩子，然后再将此时左孩子最上面的节点作为root进一步（根、左、右）读取，以此类推进行遍历。我们可以用递归的方式来实现代码。 前序遍历123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT==NULL) return; if(BT-&gt;Left==NULL &amp;&amp; BT-&gt;Right==NULL)&#123; printf(&quot; %c&quot;,BT-&gt;Data); //输出结果 &#125; PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right);&#125; 中序遍历123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT==NULL) return; PreorderPrintLeaves(BT-&gt;Left); if(BT-&gt;Left==NULL &amp;&amp; BT-&gt;Right==NULL)&#123; printf(&quot; %c&quot;,BT-&gt;Data); &#125; PreorderPrintLeaves(BT-&gt;Right);&#125; 后序遍历123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT==NULL) return; PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right); if(BT-&gt;Left==NULL &amp;&amp; BT-&gt;Right==NULL)&#123; printf(&quot; %c&quot;,BT-&gt;Data); &#125; &#125; 节点的计算节点的计算需要通过左右子树的孩子判断来对其进行加法运算，我们可以用T-&gt;lchild!&#x3D;NULL来表示没有左孩子，同理可以右孩子也是T-&gt;rchild!&#x3D;NULL，这样就可以区分度为1、2或叶子节点。 计算节点数12345int NodeCount ( BiTree T)&#123; if(T==NULL) return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1; //全部一次性+1&#125; 计算度为1的节点数123456int NodeCount ( BiTree T)&#123; if(T==NULL) return 0; if(( T-&gt;lchild!=NULL &amp;&amp; T-&gt;rchild==NULL) || ( T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild!=NULL)) return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1; //这里次数+1 return NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); //直接return，次数不变&#125; 计算度为2的节点数123456int NodeCount ( BiTree T)&#123; if(T==NULL) return 0; if( T-&gt;lchild!=NULL &amp;&amp; T-&gt;rchild!=NULL) return 1+NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild); return NodeCount (T-&gt;lchild)+NodeCount (T-&gt;rchild);&#125; 计算叶子节点个数12345int LeafCount ( BiTree T)&#123; if(T == NULL) return 0; if(T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild==NULL) return 1; return LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);&#125; 树高计算我们可以定义两个整型m，n分别来表示左右两边的树高度，用递归的方式实现向下计算。 12345678910111213int GetHeight( BinTree BT )&#123; int m, n; if (BT == NULL) return 0; else&#123; m = GetHeight(BT-&gt;Left); n = GetHeight(BT-&gt;Right); if (m &gt; n) return (m + 1); else return (n + 1); &#125; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"图算法-用Dijkstra和Prim求最小路径","slug":"图算法-用Dijkstra和Prim求最小路径","date":"2024-06-15T14:44:05.000Z","updated":"2024-06-15T14:44:30.930Z","comments":true,"path":"2024/06/15/图算法-用Dijkstra和Prim求最小路径/","link":"","permalink":"https://bayeeaa.github.io/2024/06/15/%E5%9B%BE%E7%AE%97%E6%B3%95-%E7%94%A8Dijkstra%E5%92%8CPrim%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/","excerpt":"","text":"图算法-用Dijkstra和Prim求最小路径解决问题：在一个树中有多个节点和多条有向或无向的边，若我们给各个边附上权值，那么利用这两个算法可以计算从一个节点到所有节点的最小距离。实际中可以解决比如快递在区域配送最短的路径等问题。 Dijkstra思路例如以第1个节点为树根并循环整个树的节点，找到与1连接的所有点然后比较到这个点的距离是否小于原点(节点1)到这个点的距离(此时还没有)，若此时的距离比另一条路到这个点的距离小，则存入数据，以此类推。 具体如下：我们用dist数组来存入原点到所有点的最小距离，最开始的时候设置所有的点到原点的距离为无穷大。 12memset(dist, 0x3f, sizeof(dist));dist[1] = 0;//原点到原点的距离为0 用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。 首先用for遍历每个点，寻找到每一个点的到原点的距离。 再在用一个for来确定这个点是到原点的最短距离。 1234567891011for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t if(!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; state[t] = 1;//state[i]置为1。 for(int j = h[t]; j != -1; j = ne[j])&#123;//遍历t所有可以到达的节点i int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新dist[j] &#125;&#125; 整个函数： 123456789101112131415void Dijkstra()&#123; memset(dist, 0x3f, sizeof(dist));//dist数组的各个元素为无穷大 dist[1] = 0;//源点到源点的距离为置为 0 for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//遍历dist数组，找到没有确定最短路径的节点中距离源点最近的点t if(!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; state[t] = 1;//state[i]置为1。 for(int j = h[t]; j != -1; j = ne[j])&#123;//遍历t所有可以到达的节点i int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新dist[j] &#125; &#125;&#125; Prim思路prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。prim算法相比于dijkstra是贪心的，它要寻找的是每一个点之间的最短距离。 具体如下与Dijkstra一样用dist存入距离，并最开始用无穷大赋值。 用state数组来记录这个点是否已经找到了到原点的最小距离，如果是则记下1，否则是0。 用pre数组来保存节点是和谁连通的。 伪代码： 12345678int dist[n],state[n],pre[n];dist[1] = 0;for(i : 1 ~ n)&#123; t &lt;- 没有连通起来，但是距离连通部分最近的点; state[t] = 1; 更新 dist 和 pre;&#125; 我们在prim里面相当于是将树的每个点一个一个加入到一个集合中，这个集合就是生成的树。每次选择树都要看看是否在树中并且到树的距离最短，如果是则加入到集合中。 12345678910111213141516171819202122232425void prim()&#123; memset(dt,0x3f, sizeof(dt));//初始化距离数组为一个很大的数（10亿左右） int res= 0; dt[1] = 0;//从 1 号节点开始生成 for(int i = 0; i &lt; n; i++)&#123;//每次循环选出一个点加入到生成树 int t = -1; for(int j = 1; j &lt;= n; j++)&#123;//每个节点一次判断 if(!st[j] &amp;&amp; (t == -1 || dt[j] &lt; dt[t]))//如果没有在树中，且到树的距离最短，则选择该点 t = j; &#125; if(dt[t] == 0x3f3f3f3f) &#123; cout &lt;&lt; &quot;impossible&quot;; return; &#125; st[t] = 1;// 选择该点 res += dt[t]; for(int i = 1; i &lt;= n; i++)&#123;//更新生成树外的点到生成树的距离 if(dt[i] &gt; g[t][i] &amp;&amp; !st[i])&#123;//从 t 到节点 i 的距离小于原来距离，则更新。 dt[i] = g[t][i];//更新距离 pre[i] = t;//从 t 到 i 的距离更短，i 的前驱变为 t. &#125; &#125; &#125; cout &lt;&lt; res;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"本地已经后端部署，前端response返回“Method Post not allowed”问题","slug":"本地已经后端部署，前端response返回“Method-Post-not-allowed”问题","date":"2024-05-04T15:38:25.000Z","updated":"2024-05-04T15:49:16.020Z","comments":true,"path":"2024/05/04/本地已经后端部署，前端response返回“Method-Post-not-allowed”问题/","link":"","permalink":"https://bayeeaa.github.io/2024/05/04/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E7%BB%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%89%8D%E7%AB%AFresponse%E8%BF%94%E5%9B%9E%E2%80%9CMethod-Post-not-allowed%E2%80%9D%E9%97%AE%E9%A2%98/","excerpt":"","text":"这次是在做前端的时候，前后端联调发生的问题。接口名前后都对的上然而显示“Post方法不被允许”： 第一反应是去看自定义端口最后的url是不是少一个“&#x2F;”： 发现并没有少。 最后经过排查发现前后端地址没有对上。前端地址没有连接本地的地址。 修改target的请求地址为”http://127.0.0.1:3381“，成功解决。","categories":[],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"}]},{"title":"Promise链式调用与async函数解决回调地狱问题","slug":"Promise链式调用与async函数解决回调地狱问题","date":"2024-05-01T02:36:23.000Z","updated":"2024-05-02T15:54:31.017Z","comments":true,"path":"2024/05/01/Promise链式调用与async函数解决回调地狱问题/","link":"","permalink":"https://bayeeaa.github.io/2024/05/01/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8Easync%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/","excerpt":"","text":"在平时我们使用vue的时候经常会看到在请求接口的时候总是会有async与await： 这是为什么呢？不能直接请求接口吗？ 这里其实是为了避免出现回调地狱的问题。要理解清楚这个问题不妨从promise的链式调用开始讲起。 什么是回调地狱？概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调地狱。 我们知道一个axios函数中包含一些url等请求参数和一个.then的回调函数，由于其异步性，一个接口的请求需要等到回调函数成功调回才算结束。于是要是我们在.then里面在嵌入一个axios函数的话就需要等到上一层请求后再进入这层，再由这层回调到上层。代码量一多，不仅可读性差而且异常无法捕获，耦合性严重，牵一发动全身。比如看下面代码： 12345678910axios(&#123;url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; const pname = res.data.list[5] console.log(pname); axios(&#123;url:&#x27;http://hmajax.itheima.net/api/city!&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; const cname = res.data.list[0] console.log(cname); &#125;) &#125;).catch(error =&gt; &#123; console.log(error);&#125;) 我在第二个url中最后加了一个“!”让其错误，并让catch寻找错误的地方。然而我们发现： 其错误直接来源于axios的源码处，而且显示Uncaught (in promise)，这就是回调地狱最直接的一个弊端处。 好了这里又涉及到一个词叫promise。 何为Promise？mdn的解释是：“Promise是一个对象，它代表了一个异步操作的最终完成或者失败。”所以说Promise就是一个函数返回的对象，不然每次做回调操作都要自己手动传一个回调函数进去。 解释：依靠then()方法回返回一个新生成的Promise对象特性，继续串联下一环任务，直到结束。而then()回调函数中的返回值会影响新生成的Promise对象最终状态和结果。这样通过链式调用，可以有效解决回调函数嵌套问题。 123456789const p = new Promise((reslove, reject) =&gt; &#123; setTimeout(() =&gt; &#123; //设置时间模拟ajax请求 reslove(&#x27;北京市&#x27;) &#125;, 2000)&#125;)const p2 = p.then(res =&gt; &#123; console.log(res); //北京&#125;)console.log(p2 === p); //false 可以看到我们创建了一个新的promise对象并赋值给p，然后再用p触发回调函数，并生成了一个全新的promise对象并赋值给p2。 在最后一行的log中，使用了三等判断进行比较，我们知道三等判断，判断的是两个变量保存的内存地址，最后其返回了false更可以说明生成的是一个全新的promise对象。 所以知道了promise的工作原理，我们就可以这样写： 12345678910axios(&#123;url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; const pname = res.data.list[5] console.log(pname); return axios(&#123;url:&#x27;http://hmajax.itheima.net/api/city!&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; const cname = res.data.list[0] console.log(cname); &#125;) &#125;).catch(error =&gt; &#123; console.log(error);&#125;) 没错，就是在第二个axios前面多了一个return，就可以捕获到第二层的错误了。 async函数和await我们现在知道了promise可以解决回调地狱，但是这还是在回调函数里面不断嵌套，可读性极差，这时async函数(意思为“异步”)的引入就极大的改善了这个问题。 定义：async函数是使用async关机字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键词。async和await关键词让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。 因此我们只需要这样： 123456789const getData = async () =&gt; &#123; const pObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;) const pname = pObj.data.list[5] const cObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;) const cname = cObj.data.list[0] console.log(pname); console.log(cname);&#125;getData() //别忘了调用函数 或者： 12345678910111213let pname = []let cname = []const getData = async () =&gt; &#123; await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(res =&gt; &#123; pname = res.data.list[5] &#125;) await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;).then(res =&gt; &#123; cname = res.data.list[0] &#125;) console.log(pname); console.log(cname);&#125;getData() 注意上面第二个代码中pname和cname没有用const定义，是因为当我在外面用 12const pname = []const cname = [] 定义时发现报出错误：Assignment to constant variable（把常量赋值给了变量） 这是因为我们使用 const 定义了变量且存在初始值。 后面又给这个变量赋值，所以报错了。ES6 标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域：使用 const 定义的常量，不能修改它的值，且定义的常量必须赋初值；let 定义的是变量，可以进行变量赋值操作，且不需要赋初值。这个错误就是因为我们修改了常量而引起的错误，虽然某些浏览器不报错，但是无效果！所以解决方法就是前面加： 12let pname = []let cname = [] 成功解决问题。 – 这里debug的时候发现const和let这块还有点含糊，const似乎最好是赋值一个对象或数组，再对对象进行赋值。等我哪天彻底搞明白了后单独出一期讲讲_(:3 ⌒ﾞ)__","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"JavaScript-ES6箭头函数使用细则","slug":"ES6箭头函数","date":"2024-04-29T10:47:55.000Z","updated":"2024-04-29T14:10:11.114Z","comments":true,"path":"2024/04/29/ES6箭头函数/","link":"","permalink":"https://bayeeaa.github.io/2024/04/29/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们知道在ES6之前使用函数要使用function： 123function fn(形参) &#123; 函数体&#125; 然而在function中this指向的对象不够清晰明确，以及其表达不够简洁，于是引入的箭头函数： 123(形参) =&gt; &#123; 函数体&#125; 由于其重要性，以及在vue中的大量使用，我将着重讨论下箭头函数的使用方法，函数参数和this指向问题。 使用方法以及简写条件1234567const fn = function () &#123; console.log(123) //function写法&#125;const fn = () =&gt; &#123; console.log(123) //箭头写法&#125; 当传入只有一个形参时，小括号可以省略: 1234const fn = x =&gt; &#123; console.log(x+x)&#125;fn(1) //2 当函数体只有一行时可以省略大括号: 123456789const fn = x =&gt; console.log(x+x)fn(2) //4const f = (x,y) =&gt; console.log(x+y)f(1,2) //3const form = document.querySelector(&#x27;form&#x27;)form.addEventListener(&#x27;click&#x27;, ev =&gt; ev.preventDefault()) //形参小括号和函数体大括号都省略//阻止表单默认提交时事件 箭头函数可以直接返回一个对象： 123const fn = (uname) =&gt; (&#123; uname: uname &#125;) // 属性: 值const fn = (uname) =&gt; (&#123; uname &#125;) //属性和值的名字一样的时候也可以简写fn(&#x27;ye&#x27;) //&#123;uname: &#x27;ye&#x27;&#125; 这里不用大括号包着是因为对象的大括号和其冲突了，所以用小括号代替了。 箭头函数没有arguments动态参数箭头函数里面只有剩余参数…arr,所以只能用剩余参数来传入数组进行计算。 12345678const getSum = (...arr) =&gt; &#123; let sum=0 for(let i = 0;i &lt; arr.length; i++)&#123; sum +=arr[i] &#125; return sum&#125;console.log(getSum(2,3)); //5 那么何为动态参数，何为剩余参数呢？ arguments动态参数123456789function getSum() &#123; let sum=0 console.log(arguments) //[2,3,4] for(let i = 0;i &lt; arguments.length; i++)&#123; sum +=arguments[i] &#125; console.log(sum)&#125;getSum(2,3,4) //9 arguments动态参数只存在于function函数里面，其是个伪数组，在函数里充当傀儡。 函数剩余参数剩余参数没有的固定名字，这里以arr为例。 123456789function getSum(a,b,...arr) &#123; //这里arr是名字，可以自定义 let sum=0 console.log(arr) //[4,5] for(let i = 0;i &lt; arr.length; i++)&#123; sum += arr[i] &#125; console.log(sum)&#125;getSum(2,3,4,5) //9 可以看到剩余参数顾名思义就是取剩下没有对号入座的参数。a&#x3D;2,b&#x3D;3,那么剩下的就由arr接收。注意前面的三个点是展开运算符，它可以让这几个数字组合成一个数组。 1234fn = (...arr) =&gt; &#123; console.log(arr); &#125;fn(1,2,3) //[1,2,3] 没有展开运算符： 1234fn = (arr) =&gt; &#123; console.log(arr); &#125;fn(1,2,3) //1 箭头函数this问题我们知道this是指向的是环境对象，比如我们输入： 1234567const obj = &#123; number: &#x27;1&#x27;, hello: function () &#123; console.log(this) &#125;&#125;obj.hello() //&#123;number: &#x27;1&#x27;, hello: ƒ&#125; 可以看到，我们定义了一个obj对象然后里面放了一个number和一个hello函数，当我们用obj调用hello函数时，this就指向了obj。那么我们就可以初次判断出谁调用的这个函数，this就指向谁。是不是这样呢？我们可以就单纯输入下面这行。 1console.log(this) //window 我们发现返回的是window，而我们知道window是作用域链的链头。因为我们清楚其实我们每次调用函数都应该要在前面加上window作为调用的对象，但是这样极其的重复与单调故将其省去了。这样也就说明了this确实是指向其调用的对象。 12345function fn() &#123; console.log(this)&#125;fn() //windowwindow.fn() //window 回到这个论题，我们可以发现每一个新函数都要根据它是被如何调用的来定义这个函数的this值，非常让人讨厌。因此在箭头函数中，箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。 当我们再输入： 1234567const obj = &#123; number: &#x27;1&#x27;, hello: () =&gt; &#123; console.log(this) &#125;&#125;obj.hello() //Window hello的上一级时obj，而调用obj的对象是window，所以输出window。 再比如： 1234567891011const obj = &#123; number: &#x27;1&#x27;, hello: function () &#123; let i = 10 const count = () =&gt; &#123; console.log(this) &#125; count() &#125;&#125;obj.hello() //&#123;number: &#x27;1&#x27;, hello: ƒ&#125; count函数的上一层是hello，而调用hello的是obj对象，所以输出obj。 然而在实际开发中，事件回调函数使用箭头函数时，this为全局的window。因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。 123btn.addEventListner(&#x27;click&#x27;, function () &#123; console.log(this) //this指向btn&#125;)","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"AJAX-axios库使用与http协议","slug":"axios","date":"2024-04-26T15:41:11.000Z","updated":"2024-05-02T13:51:08.409Z","comments":true,"path":"2024/04/26/axios/","link":"","permalink":"https://bayeeaa.github.io/2024/04/26/axios/","excerpt":"","text":"AJAX-axios库使用与http协议当我们需要将前后端数据进行传递时，我们可以运用AJAX技术。AJAX也就是异步的JavaScript和XML(Asynchronous JavaScript And XML)。简单的说，就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON,XML,HTML和text文本等格式发送和接收数据。 AJAX工作原理 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） axios使用axios是基于Promise的HTTP客户端作用于浏览器和node.js，属于网络请求库。 语法引入axios.js的两种方法： 使用 jsDelivr CDN: 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用 unpkg CDN: 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 函数基本使用： 12345axios(&#123; url:&#x27;目标地址&#x27;&#125;).then(result=&gt;&#123; //后端返回数据&#125;) axios-查询参数使用axios提供的params选项(param是“参数”的意思) 123456789axios(&#123; url:&#x27;&#x27;, params:&#123; 参数名:值 &#125;&#125;).then(result=&gt;&#123; //返回值 //console.log(result)&#125;) 比如： 12345678axios(&#123; url: &#x27;https://hmajax.itheima.net/api/city&#x27;, params:&#123; pname: &#x27;河北省&#x27; &#125;&#125;).then(result=&gt;&#123; console.log(result);&#125;) 查询完的数据就可以在Response里找到result值，一般情况是返回一个message和一个res，其返回的数据是个json文件。 axios-请求配置12345678910axios(&#123; url:&#x27;&#x27;, method:&#x27;请求方法&#x27;, data:&#123; 参数名:值 &#125;&#125;).then(result=&gt;&#123; //返回值 //console.log(result)&#125;) axios将data对象的数据通过上述方式传入后端，后端就会根据其传入的关键词获得对应的res并在then后面得到。 axios-错误处理在then方法的后面，通过点语法调用catch方法，传入回调函数并定义形参。 12345678axios(&#123; //请求选项&#125;).then(result =&gt; &#123; //处理数据&#125;).catch(error =&gt; &#123; //处理错误 //console.log(error)&#125;) 该方法可以捕捉到错误数据，并将数据传入error形参中，于是就可以将错误数据解析并返回客户端中显示。（其实error可以用console.log在控制台查看，但是catch可以将数据传入并可解析） 1alert(error.response.data.message) //一般情况下可以通过这样解析json文件并弹出问题 HTTP协议Request Headershttp协议规定了浏览器发送及服务器返回内容的格式，也就是如果你传入data对象，报文会将其转化为一个json文件打包传给后端，然后后端再传入对应的json文件。 如下图就是一个请求报文(也就是请求头)： Accept中可以看到返回的是个json文件，Host是域名，User-Agent是用来模仿用户登录。 Resonpse Headers当我们后端受到前端的request headers后就会相应的传入response headers，这个headers包括：响应行，响应头，空行，响应体。响应体就包含了我们需要的json文件，浏览器会将该文件通过js渲染，显示于页面中。在文件传输的时候可能会有前后传递出错的时候，这时候就需要状态码来告知错误信息。 状态码有如下几种： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"并查集","slug":"并查集","date":"2024-04-19T13:41:40.000Z","updated":"2024-05-02T15:58:02.740Z","comments":true,"path":"2024/04/19/并查集/","link":"","permalink":"https://bayeeaa.github.io/2024/04/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集其实解决的内容就是类似于集合合并的问题，然而如果用普通的数组去储存一个集合若数据量大，不仅调用时占用内存空间大，而且不便于插入或查询操作，因此引入并查集可以很好的解决这点。 功能1.将两个集合合并 2.询问两个元素是否再一个集合当中 思路理解这个问题就需要把集合给看成一个树，然后这个树的树根就代表这个集合。当想询问其中一个节点时，我们只要访问这个节点father，然后再找这个father的grandfather直到到树根，就能确定这个点的树根。 123//p[x]表示x的父节点if(p[x]==x) //判断树根while(p[x]!=x) x=p[x] //求x的集合编号 合并两个集合合并集合只需要将其中一个集合的树根的编号改成另一个集合的根。 1p[x]=y//px是x的集合编号，py是y的集合编号 (俗称：给x的祖宗又认了一个爹) 路径压缩当你找到这个节点的根节点时，就把这些节点的父亲全部变成根节点的编号，也就是让这些节点全部指向根节点。当实现了这个操作后，其查询操作直接将时间复杂度变成O(1)。 1234int find(int x)&#123; //寻找根+路径压缩 if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125; 例题1.合并集合一共有 n𝑛 个数，编号是 1∼n1∼𝑛，最开始每个数各自在一个集合中。 现在要进行 m𝑚 个操作，操作共有两种： M a b，将编号为 a𝑎 和 b𝑏 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作； Q a b，询问编号为 a𝑎 和 b𝑏 的两个数是否在同一个集合中； 输入格式第一行输入整数 n𝑛 和 m𝑚。 接下来 m𝑚 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。 输出格式对于每个询问指令 Q a b，都要输出一个结果，如果 a𝑎 和 b𝑏 在同一集合内，则输出 Yes，否则输出 No。 每个结果占一行。 数据范围1≤n,m≤1051≤𝑛,𝑚≤105 输入样例：1234564 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4 输出样例：123YesNoYes 题解12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int p[100005];int find(int x)&#123; //核心函数，find(x)最终返回值就是x的根节点编号 if(x!=p[x]) p[x]=find(p[x]); return p[x];&#125;int main()&#123; int n,m,a,b; string s; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;=n;i++)&#123; p[i]=i; &#125; while(m--)&#123; cin&gt;&gt;s&gt;&gt;a&gt;&gt;b; if(s==&quot;M&quot;)&#123; p[find(a)]=find(b);//让a根节点的父亲变成b节点的根节点 &#125; else if(s==&quot;Q&quot;)&#123; if(find(a)==find(b))&#123; //判断两个数是不是属于同一个集合，其实就是两个根编号是不是一样 cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; &#125; &#125;&#125; 2.合并根题目描述w 星球的一个种植园，被分成 m×n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。 这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。 如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？ 输入格式第一行，两个整数 m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。 接下来一行，一个整数 k，表示下面还有 k 行数据(0&lt;k&lt;1e5)。 接下来 k 行，每行两个整数 a，b，表示编号为 a 的小格子和编号为 b 的小格子合根了。 格子的编号一行一行，从上到下，从左到右编号。 比如：5×4 的小格子，编号： 123451 2 3 45 6 7 89 10 11 1213 14 15 1617 18 19 20 输出格式一行一个整数，表示答案 输入样例1234567891011121314151617185 4162 31 55 94 87 89 1010 1111 1210 1412 1614 1817 1815 1919 209 1313 17 输出样例15 题解： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int p[1000005],vis[1000005];int find(int x)&#123; //寻找根 if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int main()&#123; int n,m,k,a,b,sum=0; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;k; for(int i=1;i&lt;=n*m;i++) p[i]=i; while(k--)&#123; cin&gt;&gt;a&gt;&gt;b; p[find(a)]=find(b);//合并集合 &#125; for(int i=1;i&lt;=n*m;i++)&#123; // cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; if(i==p[i])sum++; &#125; cout&lt;&lt;sum;&#125; 这题使用并查集解题，核心主要两个步骤：寻找该元素的根、合并两个集合 然后最后判断是用if(i&#x3D;&#x3D;p[i])来判断这里的根有几个，因为我们知道只有p[x]&#x3D;&#x3D;x时，才是这个树的根(因为在数组上理解就是所有的数字比如：[-1，1，2，3，4] —&gt; [ -1，4，2，1，3]，我们可以发现数组的顺序表示数字，而对应上面的数字就是其根的索引，在并查集的操作下只有根节点是i&#x3D;&#x3D;p[i]，因此我们也可以将其作为判断几个集合的依据)。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"c++基础数据结构之栈、队列、链表","slug":"c-基础数据结构之栈、队列","date":"2024-04-18T04:50:41.000Z","updated":"2024-08-06T10:56:34.515Z","comments":true,"path":"2024/04/18/c-基础数据结构之栈、队列/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/c-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/","excerpt":"","text":"c++基础数据结构之栈、队列、链表队列1234567queue&lt;int&gt;q //queue&lt;定义类型&gt;定义名称q.pop()//出队q.push()//入队q.front()//队首q.rear()//队尾q.size()//队长(队长可以为0)q.empty()//是否为空队(若是则返回1) 栈123456stack&lt;int&gt;stst.pop()//出栈st.push()//入栈st.top()//栈顶st.size()//栈长st.empty()//判断是否为空栈 1.单链表(注意结构体写法)题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 https://www.ixigua.com/7241418740699824643 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： (1) “H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 (3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式共一行，将整个链表从头到尾输出。 数据范围1≤M≤100000所有操作保证合法。 输入样例 复制123456789101110H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例 复制16 4 6 5 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;struct node &#123; //建立了一个对象 int num; //节点值 int time; //第几次插入 node* next; //定义下一个节点的指针位置&#125;;node* head = new node();//创建一个新对象叫headvoid headin(int n,int i)&#123; node* p=new node();//创建一个新节点 p-&gt;num=n;//把值输入节点中，箭头写法表示对象的属性 p-&gt;time=i;//这是次数 //下面就是插入模板操作 p-&gt;next=head-&gt;next; head-&gt;next=p;&#125;void de(int t)&#123; node* p, * q;//定义两个节点 p=head-&gt;next;//p为指向head的下一个节点 if(!t)&#123; head-&gt;next=p-&gt;next;//head指的是头，里面没值，所以实际的链表头是p delete(p);//p是实际头节点 &#125; else&#123; while(p)&#123;//找到第t次插入的数 if(p-&gt;time==t)break; p=p-&gt;next; &#125; q=p-&gt;next;//让q在p的前面，辅助删除p后面的节点 p-&gt;next=q-&gt;next; delete(q);//删除q &#125;&#125;void insert(int t,int n,int i)&#123; node* p=head-&gt;next; //让p指针指向head的下一个，然后用p节点找欲插入的值 //下面三行是创建新节点然后给其赋值的操作 node* q=new node(); q-&gt;num=n; q-&gt;time=i; //从链表头开始找 while(p)&#123; if(p-&gt;time == t)break;//找第t次插入的数 p=p-&gt;next; &#125; //把q节点插到第t次插入的数后面 q-&gt;next=p-&gt;next; p-&gt;next=q;&#125;int main()&#123; head-&gt;next=NULL;//开始时链表没有值 int m,i,x,k; char op; i=1; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;op; if(op==&#x27;H&#x27;)&#123; cin&gt;&gt;x; headin(x,i); i++; &#125; if(op==&#x27;D&#x27;)&#123; cin&gt;&gt;k; de(k); &#125; if(op==&#x27;I&#x27;)&#123; cin&gt;&gt;k&gt;&gt;x; insert(k,x,i); i++;//因为题目是记录第几次插入的数，所以要用i计数 &#125; &#125; node* p = head-&gt;next;//让p指向实际头节点 while(p)&#123; cout&lt;&lt; p-&gt;num &lt;&lt; &#x27; &#x27;; p=p-&gt;next; &#125;&#125; 2.简单计算器题目描述读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。 https://www.ixigua.com/7213692123635024436 输入格式每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。 100 * 2 + 100 &#x2F; 2 - 100 * 2 - 4 &#x2F; 2 输出格式对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入样例 复制14 + 2 * 5 - 7 / 11 输出样例 复制113.36 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;stack&lt;double&gt;d_st;stack&lt;char&gt;op_st;int level(char a)&#123; if(a==&#x27;+&#x27;||a==&#x27;-&#x27;)return 1; if(a==&#x27;*&#x27;||a==&#x27;/&#x27;)return 2;&#125;void cal()&#123; char c=op_st.top();op_st.pop(); double a,b; a=d_st.top(); d_st.pop(); b=d_st.top(); d_st.pop(); if(c==&#x27;+&#x27;)d_st.push(b+a); if(c==&#x27;-&#x27;)d_st.push(b-a); if(c==&#x27;*&#x27;)d_st.push(b*a); if(c==&#x27;/&#x27;)d_st.push(b/a);&#125;int main()&#123; string str; double x; getline(cin,str); int len=str.size(); for(int i=0;i&lt;len;i++)&#123; if(str[i]&gt;=&#x27;0&#x27; &amp;&amp; str[i]&lt;=&#x27;9&#x27;)&#123;//如果是数字 x=str[i]-&#x27;0&#x27;; while(str[i+1]&gt;=&#x27;0&#x27; &amp;&amp; str[i+1]&lt;=&#x27;9&#x27;)&#123; x=x*10+str[i+1]-&#x27;0&#x27;; i++; &#125; d_st.push(x);//把字符串数字转化为整型并推入栈 &#125; else if(str[i]==&#x27;+&#x27; || str[i]==&#x27;-&#x27; || str[i]==&#x27;*&#x27; || str[i]==&#x27;/&#x27;)&#123; if(op_st.empty()||level(str[i])&gt;level(op_st.top()))&#123;//只有优先级高于栈顶的情况才能入栈 op_st.push(str[i]); &#125; else if(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123; while(!op_st.empty() &amp;&amp; level(str[i])&lt;=level(op_st.top()))&#123;//拿栈顶前两个计算 cal(); &#125; op_st.push(str[i]); &#125; &#125; &#125; while(!op_st.empty())&#123; cal(); &#125; printf(&quot;%.2lf&quot;,d_st.top());&#125; 3.约瑟夫环(队列解法)题目描述有ｎ(n&lt;100)个人依次围成一圈，从第１个人开始报数，数到第ｍ个人出列，然后从出列的下一个人开始报数，数到第ｍ个人又出列，…，如此反复到所有的人全部出列为止。设ｎ个人的编号分别为1，2，…，n，打印出列的顺序。 输入格式n和m。 输入样例14 17 输出样例11 3 4 2 题解1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt;qe; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; qe.push(i); &#125; while(!qe.empty())&#123; int x; for(int i=1;i&lt;=m-1;i++)&#123; x=qe.front(); qe.pop();qe.push(x);//把队头放到对尾 &#125; x=qe.front();qe.pop();//数到的数彻底出队 cout&lt;&lt;x&lt;&lt;&quot; &quot;; &#125;&#125; 4.走出迷宫(bfs)题目描述当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。 假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。 视频讲解：https://www.ixigua.com/7166253132702450212 输入格式第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。 接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符‘.’表示空地，‘#’表示墙，‘S’表示起点,‘T’表示出口。 输出格式输出从起点到出口最少需要走的步数。 输入样例12343 3S#T.#.... 输出样例16 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char a[105][105];int vis[105][105];int n,m;struct node&#123; int r,c; int step;&#125;;int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;void bfs(int sr,int sc,int er,int ec)&#123; queue&lt;node&gt;qe;//注意定义方式 node q,t;//t用来记录q的一圈4个方向 q.r=sr,q.c=sc; q.step=0; qe.push(q); vis[q.r][q.c]=1; while(!qe.empty())&#123; q=qe.front(); qe.pop(); if(q.r==er &amp;&amp; q.c==ec)&#123; cout&lt;&lt;q.step; break; &#125; for(int i=0;i&lt;4;i++)&#123; t.r=q.r+dir[i][0]; t.c=q.c+dir[i][1]; if(a[t.r][t.c]==&#x27;.&#x27; &amp;&amp; vis[t.r][t.c]==0 &amp;&amp; t.r&gt;=1&amp;&amp;t.r&lt;=n &amp;&amp; t.c&gt;=1&amp;&amp;t.c&lt;=n)&#123; t.step=q.step+1; vis[t.r][t.c]=1; qe.push(t); &#125; &#125; &#125;&#125;int main()&#123; int sr,sc,er,ec; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]==&#x27;S&#x27;)sr=i,sc=j; if(a[i][j]==&#x27;T&#x27;)er=i,ec=j,a[i][j]=&#x27;.&#x27;; &#125; bfs(sr,sc,er,ec);&#125; 5.出入栈判断题目描述现有 a∼z 26 个小球模拟出入栈操作，小球按照 a∼z 的顺序压入栈，在栈顶的元素可以随时被取出，在游戏开始前给出任意 26 个字母的一些排列，问是否能够由出栈顺序得到这个排列。 输入格式输入第一行表示一个整数n, n&lt;&#x3D;100 接下来输入n行，每行表示一个a~z的排列。 输出格式每组数据输出一行结果，如果能够由出栈顺序得到给定排列，则输出 yes，否则输出 no。 输入样例 复制1232abcdefghijklmnopqrstuvwxyzzabcdefghijklmnopqrstuvwxy 输出样例 复制12yesno 数据范围与提示5abcdegfhijklnmopqrstuvwxyzabcdegfhijklnmopqrstzyxwvudcbaegfhijklnmopqrstuvwxyzabcdegfhijkwxyzlnmopqrstuvabcdegfhijklnmouvwxyztsrqp yesyesyesnoyes 题解12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; stack &lt;char&gt; st; int n; cin&gt;&gt;n; while(n--)&#123; string s; cin&gt;&gt;s; int len=s.size(),j=0; for(int i=0;i&lt;len;i++)&#123; char ch=i+&#x27;a&#x27;; st.push(ch); while(!st.empty() &amp;&amp; st.top()==s[j])&#123; st.pop(),j++; &#125; &#125; if(j==len)cout&lt;&lt;&quot;yes\\n&quot;; else cout&lt;&lt;&quot;no\\n&quot;; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript基本语法","slug":"JavaScript基本语法","date":"2024-04-18T04:48:23.000Z","updated":"2024-04-29T11:07:33.889Z","comments":true,"path":"2024/04/18/JavaScript基本语法/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"JavaScript基础语法介绍JavaScript介绍1.1 JavaScript是什么是一个运行在浏览器上的编程语言。 1.2JavaScript书写位置内部式： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 外部式： 1234&lt;body&gt; &lt;script src=&quot;./my.js&quot;&gt; &lt;/script&gt;&lt;/body&gt; 使用外部时，script标签里面不要写内容，否则会被忽略。 1.3JavaScript输入输出语法输出语法1： 123456&lt;body&gt; &lt;script&gt; document.write(&#x27;hey&#x27;) document.write(&#x27;&lt;h1&gt; 一级 &lt;/h1&gt;&#x27;) &lt;/script&gt;&lt;/body&gt; 输出语法2： 12345&lt;body&gt; &lt;script&gt; alert(&#x27;hey&#x27;)//页面弹出警示框 &lt;/script&gt;&lt;/body&gt; 输出语法3： 12345&lt;body&gt; &lt;script&gt; console.log(&#x27;haha&#x27;)//控制台输出语法，程序员调试使用 &lt;/script&gt;&lt;/body&gt; 输入语法1： 1prompt(&#x27;请输入&#x27;)//弹出一个对话框 prompt输入类型为字符串。 1.4 字面量比如2000 是数字字面量，’hahaha’是字符串字面量，[]数组字面量，{}对象字面量 变量2.1 变量是什么白话：用来装数据的盒子。可以用来存放数据。 2.2 变量的基本使用(与c语言定义类似) 1.声明变量1let variable //var存在与老版的JavaScript中 age为变量。 2.变量赋值1variable = 18 variable为变量，18为字面量。 变量不允许多次定义。 小小的变量使用一下： 123456&lt;body&gt; &lt;script&gt; let n=prompt(&#x27;请输入&#x27;) document.write(n) &lt;/script&gt;&lt;/body&gt; 2.3 变量命名规则与规范1. 规则①不能用关键字。 ②只能用下划线、字母、数字、＄组成，且不能用数字开头。 ③字母严格区分大小写。 2.规范①起名要有意义。 ②遵守小驼峰命名法。 数组1.1 声明数组1let arr = [1，2，3] 1.2 数组的基本使用12console.log(arr[0]) //索引console.log(arr.length) //获取长度 常量1.1 基本使用1const G = 9.8 常量不允许重新赋值，声明的时候必须赋值。 数据类型js为弱数据类型语言，只有赋值了才知道是什么数据类型。 基本数据类型number 数字型 string 字符串型 boolean 布尔型 undefined 未定义型 null 空类型 引用数据类型object 对象 1.数字类型数字类型可以由+ - * &#x2F; %各个符号进行运算。 NaN (not a number)：表示计算错误。 NaN是粘性的，任何对NaN的操作都会返回NaN。 2.字符串通过单引号、双引号或反引号包裹的数据都叫字符串。 字符串拼接：1234console.log(&#x27;12&#x27;+&#x27;34&#x27;) //字符串可以用加号拼接let a=&#x27;k&#x27;let b=&#x27;q&#x27;console.log(k+q) 模板字符串：1document.write(`大家好，我叫$&#123;name&#125;,今年$&#123;age&#125;岁`) //用反引号,变量用＄&#123;&#125;包裹 3.布尔型 (bollean)12let n=trueconsole.log(n) 4.未定义类型 (undefined)12let numconsole.log(num) //输出undefined 5.空类型 (null)12let obj=null //表示赋值了一个空的内容console.log(obj) 如果一个变量里面确定存放的是对象，如果还没准备号对象，可以放个null 6.检测数据类型12typeof num //num为变量typeof(num) 7.类型转换隐式转换+号两边只要有一个是字符串，都会把另外一个转成字符串。 除了+以外的算数运算符，比如- * &#x2F;等都会把数据转成数字类型。 1234console.log(&#x27;数字&#x27; + 1) //返回&#x27;数字1&#x27;console.log(&#x27;1&#x27; + 1) //返回&#x27;11&#x27;console.log(&#x27;1&#x27; - 1) //返回0console.log(+&#x27;123&#x27;) //返回123 显示转换通过函数来进行数据转换： 12Number(str) //转换为数字类型let num = +prompt(&#x27;输入&#x27;) //输入的可以转换为数字类型 parse系列： 1234parseInt(num) //只保留数字且只保留整数parseFloat(num) //保留数字并保留小数parseInt(12px) //12 parseFloat(12.86px) //12.86 运算一元运算符前置自增12let i=1console.log(++i + 2) //2+2=4 先自加再使用。 后置自增12let i=1console.log(i++ + 2) //1+2=3 此时i已经为2，但是没有参与运算 先使用再自加。 12let i=1console.log(i++ + ++i + i) //1+3+3=7 第二个i时i为2 比较运算符1234567&gt;&lt;&gt;=&lt;=== //左右两边值是否相等=== //左右两边是否类型和值都相等!== //左右两边是否不全等 NaN不等于任何人，包括它自己。 1console.log(NaN === NaN) //false if语句123if (条件) &#123; 满足条件执行的代码&#125; 条件中只有数字0或者空字符会触发false，其余都是true。 三元运算符可以代替if双分支。 1条件 ? 满足条件执行的代码 : 不满足条件执行的代码 例子： 123456if(3&lt;5)&#123; alert(&#x27;真的&#x27;)&#125;else&#123; alert(&#x27;假的&#x27;)&#125; 和 13&lt;5 ? alert(&#x27;真的&#x27;) : alert(&#x27;假的&#x27;) 等价。 还可以作赋值操作： 1let sum = 3 &lt; 5 ? 3 : 5 //sum=3 数字补0例子123let num = prompt(&#x27;请您输入一个数字&#x27;) //类型为stringnum = num &lt; 10 ? 0 + num : num //判断小于10才补0alert(num) 输入9，输出09 输入11，输出11 数组查询12let arr=[1,2,3]console.log(arr[0]) 修改123let arr=[1,2,3]arr[0]=3console.log(arr[0]) //[3,2,3] 增加push() 添加数组末尾 unshift() 添加数组开头 1234let arr=[1,2,3]arr.push(4) //[1,2,3,4]arr.push(4,5) //[1,2,3,4,5]arr.unshift(0) //[0,1,2,3] 删除pop() 弹出最后一个元素 shift() 弹出第一个元素 splice() 切片删除 &#x2F;&#x2F;arr.plice(起始位置，删除几个) 12345678let arr=[1,2,3]arr.pop() //[1,2]console.log(arr.pop()) //3arr.shift() //[2,3]console.log(arr.shift) //1arr.splice(1,1) //[1,3]arr.splice(1) //[1] 删除索引1后面的所有arr.splice(1,2) //[1] 函数123function 函数名() &#123; 函数体&#125; 调用: 1函数名() 例如： 12345function sayhi&#123; console.log(&#x27;hi&#x27;)&#125;sayhi() 异常处理语句throw语句1throw expression; 使用这个语句后就会弹出error： 12345678for(let i=1;i&lt;=5;i++)&#123; if(i!=4)&#123; console.log(&quot;yes&quot;); &#125; else&#123; throw &quot;not 4&quot;; //Uncaught not 4 &#125;&#125; try…catch语句123456try&#123; ...&#125; catch (error)&#123; console.error(error)&#125; catch块可以用来处理所有try块总产生的异常。 finally块12345678openMyFile();try &#123; writeMyFile(theData); //This may throw a error&#125; catch (e) &#123; handleError(e); // If we got a error we handle it&#125; finally &#123; closeMyFile(); // always close the resource&#125; finally块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。 循环与迭代 for 语句 do…while 语句 while 语句 label 语句 break 语句 continue 语句 for…in 语句 for…of 语句 其循环方式与c语言相似，不再一一赘述。 对象一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法。 对象及其属性： 1234var myCar = new Object();myCar.make = &quot;Ford&quot;;myCar.model = &quot;Mustang&quot;;myCar.year = 1969; 可以按如下方法访问对象： 123myCar[&quot;make&quot;] = &quot;Ford&quot;;myCar[&quot;model&quot;] = &quot;Mustang&quot;;myCar[&quot;year&quot;] = 1969; 创建新对象使用对象初始化器创建1234567var obj = &#123; property_1: value_1, // property_# 可以是一个标识符... 2: value_2, // 或一个数字... [&quot;property&quot; + 3]: value_3, // 或一个可计算的 key 名... // ..., &quot;property n&quot;: value_n,&#125;; // 或一个字符串 使用构造函数创建用构造函数创建分两种： 通过创建一个构造函数来定义对象的类型。(建议首字母大写) 通过 new 创建对象实例。 这里首先定义一个对象类型，并且赋予其make,model,year属性。 12345function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125; 注意这里是通过this来给对象类型属性值赋值 然后你就可以创建一个新对象啦 1var mycar = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993); 或者你也可以让类中加入一个owner： 123456function Car(make, model, year, owner) &#123; this.make = make; this.model = model; this.year = year; this.owner = owner;&#125; 那么你就可以这样创建： 12var car1 = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993, rand);var car2 = new Car(&quot;Nissan&quot;, &quot;300ZX&quot;, 1992, ken); 就可以这样索引读取： 1car2.owner.name; 你也可以为之前定义的对象增加新的属性： 1car1.color = &quot;black&quot;; 注意这里只是这个car1增加了新属性，不影响其他car1,car3 使用Object.create方法创建及使用Object.create()函数创建 123456789101112131415var Animal = &#123; type: &quot;Invertebrates&quot;, // 属性默认值(无脊椎动物) displayType: function () &#123; //类里面可以包含函数 console.log(this.type); //该函数用来显示type的值 &#125;,&#125;;// 创建一种新的动物——animal1var animal1 = Object.create(Animal);animal1.displayType(); // 输出:Invertebrates(因为没有没有给type赋值)// 创建一种新的动物——Fishesvar fish = Object.create(Animal);fish.type = &quot;Fishes&quot;;fish.displayType(); // 输出:Fishes","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"}]},{"title":"如何优雅的将秒换算成-时:分:秒？","slug":"秒转换时间","date":"2024-04-18T01:29:59.000Z","updated":"2024-04-29T11:06:44.553Z","comments":true,"path":"2024/04/18/秒转换时间/","link":"","permalink":"https://bayeeaa.github.io/2024/04/18/%E7%A7%92%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4/","excerpt":"","text":"如何优雅的将秒换算成-时:分:秒？思路先看一下题目，发现就是一道模拟题，但是又一些细节的。 首先是数据的规模：时间不超过 10^18,所以需要开 long long。 然后首先要忽略掉毫秒。 这里普及一个知识:1s &#x3D; 1000ms 所以需要忽略后面的三位。直接整除 1000 就可以了。 之后就是处理时分秒了： 1.小时由于只是算一天，24 小时之内，所以要把完整的一天去掉，也就是把对每天的秒数取余，余数就是除了整天剩余的秒数，每天的秒数用24*60*60来表示（当然你也可以直接算出来结果是86400）。然后用最后一天剩余的秒数整除每小时的秒数60*60（也就是3600），就是小时值了。 2.分钟分钟要先对每小时的秒数60*60取余，余数就是除了整小时以外剩余的秒数。之后整除 6060 就是剩余的秒数中整分钟的数，就是分钟值了。 3.秒直接对60取余，剩下的就是秒了。 时间的处理就搞好了。下面就是输出了，题目要求时、分、秒不足两位时补前导 00。所以这是一个细节。 当然你可以用printf进行域宽的输出，但是我这里介绍一个用cin的方法。 要用到两个函数： 一个是setw()函数，这个函数可以限定域宽，宽度就是括号里的数字。 另外一个setfill()函数，这个函数可以设置当实际的宽度不足setw()函数的值时，用某个字符来补足。（setfill()函数最好放在setw()函数前面） 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,h,m,s; cin&gt;&gt;n; n=n/1000; h=n%(24*3600)/3600; m=n%3600/60; s=n%60; cout&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(2)&lt;&lt;s;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"css背景","slug":"css-bgc","date":"2024-01-20T04:25:09.000Z","updated":"2024-04-29T11:07:56.347Z","comments":true,"path":"2024/01/20/css-bgc/","link":"","permalink":"https://bayeeaa.github.io/2024/01/20/css-bgc/","excerpt":"","text":"CSS背景背景颜色background-color(bgc) 123div &#123; background-color: pink;&#125; 颜色取值可以用：关键字、rgb表示法、rgba表示法、十六进制… 背景图片background-image(bgi) 123div &#123; background-image: url(&#x27;图片的路径&#x27;);&#125; ①背景图片中url可以省略引号。 ②背景图片默认是在水平和垂直方向平铺的。 ③背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色。 背景平铺background-repeat(bgr) 123div&#123; background-repeat:no-repeat;&#125; repeat (默认值)水平和垂直方向都平铺 no-repeat 不平铺 repeat-x 沿着水平方向(x轴)平铺 repeat-y 沿着垂直方向(y轴)平铺 背景位置background-position(bgp) 123div&#123; background-position:&#125; 方位名词水平方向left、center、right 垂直方向top、center、bottom 123div&#123; background-position: right bottom; //水平位置 垂直位置&#125; 数字+px坐标轴①原点(0,0) 盒子左上角 ②x轴 水平向右 ③y轴 垂直向下 操作将图片左上角与坐标点重合即可 123div&#123; background-position: 50px 100px; //水平位置 垂直位置&#125; 背景相关属性连写background: color image repeat position 可以不按顺序写。 123div&#123; background: pink url(./images/1.jpg) no-repeat bottom center ;&#125; 与img的区别①img标签是一个标签，不设置宽高默认会以原尺寸显示。 ②div标签需要设置div的宽高，因为背景图片只是装饰的css样式，不能撑开div标签。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"}]},{"title":"递归——深度优先搜索(dfs)","slug":"递归——深度优先搜索(dfs)","date":"2023-11-06T14:26:27.000Z","updated":"2024-04-29T11:06:51.155Z","comments":true,"path":"2023/11/06/递归——深度优先搜索(dfs)/","link":"","permalink":"https://bayeeaa.github.io/2023/11/06/%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/","excerpt":"","text":"递归——深度优先搜索(dfs)区别与广度优先(bfs)，深度优先注重的是一步走到底，通俗的举一个例子，比如一个迷宫，每走一格他就有很多的方向可以走，而深度优先就是先选取一个方向并且一路走到底直到触边或无路可走时再返回。以下使用递归方法实现深度优先搜索： 递归方法类似于栈，将数据一直递取到底后自下往上出栈。 大致框架如下： 1234567891011121314viod dfs(int k)&#123; if(输出条件)&#123; cout&lt;&lt; &#125; else&#123; for(int i=0;i&lt;n;i++)&#123; if(vis[i]==0)&#123; a[k]=数字,vis[i]=1//标记使用; dfs(k+1);//向下递取 vis[i]=0;//将其拿出，返回原先状态 &#125; &#125; &#125;&#125; 下列题目方式解决一些排列组合问题。 组合输出 –5个数字组合输入3个盒子 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,r;int a[200],vis[200];//a用来记录牌子，vis用来记录牌子的使用情况int is_rise(int b[])&#123;//判断是否是递增数组 int flag=1; for(int i=1;i&lt;r;i++)&#123; if(a[i]&gt;a[i+1])&#123; flag=0; &#125; &#125; return flag;&#125;void dfs(int k)&#123;//k为盒子的编号，或可以理解为步数 if(k==r+1&amp;&amp;is_rise(a))&#123; for(int i=1;i&lt;=r;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; return; &#125; for(int i=1;i&lt;=n;i++)&#123;//注意只要一个for来表示其手上所拿的牌即可，不要用两个for，递归里面就包含了向下循环的方式，就是一遍一遍尝试放牌。 if(vis[i]==0)&#123; a[k]=i,vis[i]=1; dfs(k+1); vis[i]=0;//将牌子拿出来，此时就要把vis归回0 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;r; dfs(1);&#125; 这题不用暴力for循环做解，而是考虑用三个盒子装入数字，装入过的数字用1标记箱子被使用。 素数环 eg：输入8 输出4 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[25],vis[25];int n,cnt;int isPrime(int x)&#123; if(x&lt;2)return 0; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)return 0; &#125; return 1;&#125;void dfs(int k)&#123; if(k==n+1 &amp;&amp; isPrime(a[1]+a[n]))&#123;//是否超出边界&amp;&amp;是否头尾相加是素数 cnt++; return; &#125; for(int i=2;i&lt;=n;i++)&#123; if(vis[i]==0 &amp;&amp; isPrime(i+a[k-1]))&#123;//vis用来看有没有用过这个数字 a[k]=i,vis[i]=1;//a用来保存数字 dfs(k+1); vis[i]=0;//当前的这个数字清除，再向下dfs &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; a[1]=1,vis[1]=1; dfs(2); cout&lt;&lt;cnt; &#125; 全排列问题 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[25],b[25]; //a用来存储数字，到时候输出就看a里面存的数字；b用来记录数字使用过没有，如果用了就用1表示，没用就是0；比如1 2 3，在存放第二个盒子的时候1已经用过了，故用b[i]==0来判断出可以用2，再把2放到盒子里void dfs(int k)&#123; //depth first search if(k==n+1)&#123; //k是指到第几个盒子了，如果k到了第n+1个虚无的盒子，就说明没盒子了要输出了 for(int i=1;i&lt;=n;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for(int i=1;i&lt;=n;i++)&#123;//i是指拿在你手上的牌的数字，没用0为了更好理解 if(b[i]==0)&#123;//看看这个牌用过没有，b数组用来看这个牌用过没有用的 a[k]=i,b[i]=1;//如果没有用过就把牌i放到第k个盒子里，用a[k]=i表示，再用b[i]=1表示这个牌用了 dfs(k+1);//上一步只放了一张牌，这一步就是看到第二个盒子，在这次i会发现b[1]=1，因此此时i会为2，并把2放到盒子里 b[i]=0;//就是把当前的这张牌拿出来，比如n=3时，它时在dpf(3)时先将i=3的拿出来，然后再退回上一个dpf(2)把i=2那出来，然后dpf(2)这段又会i+1变成3，此时又到dps(3)里，以此类推 &#125;&#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(1);&#125; 体积 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt;int a[25],vis[1005];void dfs(int k,int sum)&#123; if(k==n+1)&#123;// cout&lt;&lt;sum&lt;&lt;&quot; &quot;; vis[sum]=1; return; &#125; dfs(k+1,sum+a[k]); dfs(k+1,sum);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; dfs(1,0); for(int i=1;i&lt;=1000;i++)&#123; if(vis[i])cnt++; &#125; cout&lt;&lt;cnt; return 0;&#125; 若把上面代码的注释删除则可以得到： 12331 3 48 4 5 1 7 3 4 0 6 由此可知上面深度搜索遍历的顺序是： 123456781+3+41+31+413+4340 以上手写笔记逐个分析dfs递归情况，方便理解两个dfs同时出现的状态。 相当于第一个dfs一个一个出栈，出栈一个数据就进入下一个栈再进行递取。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"爬取pixiv日前十图片并下载至本地","slug":"pixiv-crawler","date":"2023-09-11T04:21:25.000Z","updated":"2024-04-29T11:07:14.360Z","comments":true,"path":"2023/09/11/pixiv-crawler/","link":"","permalink":"https://bayeeaa.github.io/2023/09/11/pixiv-crawler/","excerpt":"","text":"爬取pixivic日前十图片实现目标：通过爬虫代码将pixivic日前十图片下载至本地并通过文件夹分类日期： 1.发送请求首先通过f12检查网站传输的包，发现ranks文件，查看其api所对应的响应，可以找到图片的url下载地址： 于是我们就可以向这个api发送请求： 1234import requestsurl = &quot;https://api.bbmang.me/ranks?page=1&amp;date=2023-09-07&amp;mode=day&amp;pageSize=30&quot;reponse = requests.get(url)print(reponse) #返回&lt;Response [200]&gt; 因为返回值为200，说明服务器已经同意请求，并通过reponse.text发现其返回值是标准的json文件，没有出现乱码等反爬现象，因此不用再加入请求头。 2.解析数据返回数据长这个样子： json使用这就是标准的json形式文件，但还不是一个字典(其实很像)，所以我们要通过response.json()指令将其变成一个字典，这样才可以通过字典与列表的操作方式提取数据。 我们可以看到里面的数据其实就是字典与列表的不断嵌套，所以只要一点点剥下去即可： 123response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;]#返回为https://i.pximg.net/img-original/img/2023/09/06/00/46/45/111480211_p0.png#就是日排行第一的图 但是当你将网站复制进浏览器时你会发现打不开。 url拼接也许是因为这个url是p站之前的使用方法，这时通过与现在图片的打开地址进行比对可以看到其中可以进行暴力拼接 图中方框处就是相同的部分，因此我们可以通过列表的切片将其拼接，这样我们就可以得到可以用的图片下载url了。 3.下载图片至本地目前我们已经得到了今天top1的图片url，我们再通过request请求获取图片数据，然后就可以把图片下载到本地了： 12345img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][0][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot;img = requests.get(img_url)with open(&quot;./top1.jpg&quot;,&quot;wb&quot;) as f: #&quot;wb&quot;是以二进制写入 f.write(img.content) #content是指获取二进制内容 此时你已经可以看到top1的图片下载当前文件夹了。 同理，下载前十的图片只需要加入for循环就可以了，以下省略。 4.下载至指定文件夹这里就需要导入os包： 1234import ospath = &#x27;C:/Users/yyn19/Desktop/code/download_imges/2023-9-7&#x27; #这是我的绝对地址if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹，文件夹名字为2023-9-7 path书写这其中的path是linux写法书写，为了方便我进行字符串拼接，这其中path也有三种写法： 第二条中的r是用来申明不是转义字符。 这样就可以创建一个文件夹了~ 然后只要再with open() as中加入path路径就可以将其下载到指定文件夹中了。 5.关于api中日期的变化因为每天api的地址都会更新，这里我就用了datetime包来获取时间信息，我发现api中的日期都会比我们现在的时间少3天，因此只要一下操作就能获取api中的时间日期： 123import datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3) 然后只需要再拼接如url中就可以啦~ 完整代码123456789101112131415161718192021import requestsimport osimport datetimeday = datetime.date.today()api_day = day-datetime.timedelta(days=3)url = &quot;https://api.bbmang.me/ranks?page=1&amp;date=&quot;+str(api_day)+&quot;&amp;mode=day&amp;pageSize=302&quot;response = requests.get(url)date = url[40:50]path = &#x27;C:/Users/yyn19/Desktop/code/download_imges/&#x27;+date #linux写法if(os.path.exists(path)==False): #判断是否存在该文件夹 os.mkdir(path) #创建该文件夹for i in range(10): img_url = &quot;https://acgpic.net/c/540x540_70/img-master&quot;+response.json()[&quot;data&quot;][i][&#x27;imageUrls&#x27;][0][&#x27;original&#x27;][32:-4]+&quot;_master1200.jpg&quot; img = requests.get(img_url) with open(path+&quot;/top&quot;+str(i+1)+&quot;.jpg&quot;,&quot;wb&quot;) as f: f.write(img.content) print(&quot;正在保存top&quot;+str(i+1)+&quot;中...&quot;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫 --- 以爬取笔趣阁小说为例","slug":"biquge","date":"2023-08-31T07:40:23.000Z","updated":"2024-04-29T11:07:47.514Z","comments":true,"path":"2023/08/31/biquge/","link":"","permalink":"https://bayeeaa.github.io/2023/08/31/biquge/","excerpt":"","text":"爬虫 — 以爬取笔趣阁小说为例1.发送请求123456import requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers) 这是requests请求，若返回response值为200，则表示请求成功 2.获取数据1response = requests.get(url,headers).text 可以通过以上方法返回得到的html文件内容，而文件中有很多标签在里面，不能直接获取想要的信息，所以需要数据解析 3.解析数据有以下几种途径：css、xpath、re正则表达 等等 让我们来看看分别用这三种方法怎么去解析到一个章节的标题 css123import parselselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() 这种方法通过css选择器进行选择 xpath123import parselselector = parsel.Selector(response)novel_title = selector.xpath(&quot;//*[@class=&quot;bookname&quot;]/h1/text()&quot;).get() 注意text后面的() re12import renovel_title = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0] 这里是因为h1在html文件中只有一个，故我直接导入。获取的数据是一个列表，所以我后面做了个且切片来直接获取字符串 *注意：以上方法各有利弊，选择合适的方式来解析数据 4.保存数据12with open(&quot;file_name&quot;+&quot;.txt&quot;,mode=&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: #w是写入但是覆盖，a是追加写入，写入文件末尾 wb是二进制写入f.write(novel_context) #写入文件 with open(download_path,mode&#x3D;””,encoding&#x3D;”utf-8”)中间的download_path可以写绝对路径 以上思路已经理清楚了，下面开始实践：爬取一章12345678910111213import parselimport requestsurl = &quot;https://www.xzmncy.com/list/5418/2610707.html&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot;&#125;response = requests.get(url,headers).textselector = parsel.Selector(response)novel_title = selector.css(&quot;.bookname h1::text&quot;).get() #css方法解析数据novel_context_list = selector.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) 注意：join函数的使用： 123456a=[&quot;1&quot;,&quot;2&quot;,&quot;8&quot;,&quot;9&quot;]print(&quot; &quot;.join(a)) #输出1 2 8 9print(&quot;\\n&quot;.join(a)) #输出1(换行)2(换行)8(换行)9b=&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;print(&quot; &quot;.join(a)) #输出a b （注意seq不能是int整形） 爬取各章url12345678910111213import requestsimport reurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] print(novel_url) print(novel_title) 在小说的列表页面我们可以发现每个标签对应的章节url，此时我们获取的数据是这样的： 我们就可以用re来解析到各个章节的url和title 完整代码123456789101112131415161718192021222324import requestsimport reimport parselurl = &quot;https://www.xzmncy.com/list/18753/&quot;headers = &#123; &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&quot; &#125;response = requests.get(url,headers).textnovel_name = re.findall(&quot;&lt;h1&gt;(.*?)&lt;/h1&gt;&quot;,response)[0]novel_info = re.findall(&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;,response)for novel_url_part,novel_title in novel_info: novel_url = &quot;https://www.xzmncy.com&quot;+novel_url_part[0:24] novel_response = requests.get(novel_url, headers).text selectors = parsel.Selector(novel_response) novel_context_list = selectors.css(&quot;#htmlContent p::text&quot;).getall() novel_context = &quot;\\n&quot;.join(novel_context_list) print(&quot;正在保存&quot;+novel_title) novel_title = &quot;*&quot; + novel_title with open(novel_name+&quot;.txt&quot;,mode=&quot;a&quot;) as f: f.write(novel_title) f.write(&quot;\\n&quot;) f.write(novel_context) f.write(&quot;\\n&quot;) f.write(&quot;\\n&quot;) 运行代码就可以看到当前的目录下出现一个txt文件，里面就是想要的小说啦~","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"CSS选择器","slug":"css选择器","date":"2023-08-23T04:35:42.000Z","updated":"2024-04-29T11:08:02.355Z","comments":true,"path":"2023/08/23/css选择器/","link":"","permalink":"https://bayeeaa.github.io/2023/08/23/css%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"引入方式引入方式有以下三种： 1.内嵌式 12345678910111213&lt;!-- 内嵌式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; colour&#123; colour:pink; &#125; &lt;/style&gt;&lt;/head&gt; 2.外联式 12345678910&lt;!-- 外联式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./111.css&quot;&gt; &lt;!-- 111为引入文件名 --&gt;&lt;/head&gt; 3.行内式 1234567&lt;!-- 行内式 --&gt;&lt;body&gt; &lt;div class=&quot;colour&quot;&gt; abcd &lt;/div&gt; &lt;div style=&quot;color: aqua;font-size: large;&quot;&gt;abab&lt;/div&gt;&lt;/body&gt; 选择器一共有4种：标签选择器、类选择器、id选择器、通符选择器 注：一下选择器均是在style标签下的 1.标签123div&#123; color:blue;&#125; 所选类型与body中html的文本类型相符(如上文中，其下文body中应该是div) 2.类选择器123.color-choose&#123; color:blue;&#125; 其html调用方式为： 1&lt;div class=&quot;color-choose&quot;&gt; abab &lt;/div&gt; 3.id选择器123#color&#123; color:blue;&#125; 其html调用方式为： 1&lt;div id=&quot;color&quot;&gt; abab &lt;/div&gt; 注意：id只得调用一次 4.通符选择器12345*&#123; margin:0; padding:0;&#125;&lt;!-- 清除内外边距 --&gt; 对全局内容生效 选择器的选择1.后代 （后面所有代）问题如下 1234&lt;p&gt; abab &lt;/p&gt;&lt;div&gt; &lt;p&gt; 哈哈哈 &lt;/p&gt;&lt;/div&gt; 欲选择div中的p标签，而不是外部的p 以如下方法实现： 12345&lt;style&gt; div p &#123; color:blue; &#125;&lt;/style&gt; 2.子代 （后面一代）问题是要选中div后面的一代 123456&lt;div&gt; &lt;p&gt; dd &lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot;&gt; ddd &lt;/a&gt; &lt;/p&gt;&lt;/div&gt; 以如下方法实现： 123div&gt;p&#123; color:blue;&#125; 3.并集问题：想要让以下这些标签被选到 1234&lt;p&gt; p &lt;/p&gt;&lt;div&gt; div &lt;/div&gt;&lt;span&gt; span &lt;/span&gt;&lt;h1&gt; haha &lt;/h1&gt; 以下面方法实现： 123p,div,span,h1&#123; color:blue;&#125; 4.交集问题：只想要选中下面p中带class&#x3D;”c”的 1234&lt;div class=&quot;c&quot;&gt;abcd&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;a&lt;/p&gt;&lt;div class=&quot;c&quot;&gt;d&lt;/div&gt;&lt;p class=&quot;c&quot;&gt;b&lt;/p&gt; 以下面方法实现： 123p.c&#123; color:blue;&#125; p是标签，c是类名（前面带个.的） 5.伪类问题：想要让鼠标悬停在如下超链接上能够变色 1&lt;a href=&quot;~~~&quot;&gt;传送&lt;/a&gt; 一下方法实现： 1234a:hover&#123; color:red; background-color:yellow;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"}]},{"title":"破壳啦","slug":"page1","date":"2023-08-21T11:25:42.000Z","updated":"2024-04-29T11:07:26.258Z","comments":true,"path":"2023/08/21/page1/","link":"","permalink":"https://bayeeaa.github.io/2023/08/21/page1/","excerpt":"","text":"终于创建好一个博客啦！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://bayeeaa.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://bayeeaa.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://bayeeaa.github.io/tags/Python/"},{"name":"其他","slug":"其他","permalink":"https://bayeeaa.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"Debug","slug":"Debug","permalink":"https://bayeeaa.github.io/tags/Debug/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://bayeeaa.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bayeeaa.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"java","slug":"java","permalink":"https://bayeeaa.github.io/tags/java/"},{"name":"操作系统","slug":"操作系统","permalink":"https://bayeeaa.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"前端","slug":"前端","permalink":"https://bayeeaa.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://bayeeaa.github.io/tags/vue/"},{"name":"Git","slug":"Git","permalink":"https://bayeeaa.github.io/tags/Git/"},{"name":"制图","slug":"制图","permalink":"https://bayeeaa.github.io/tags/%E5%88%B6%E5%9B%BE/"},{"name":"算法","slug":"算法","permalink":"https://bayeeaa.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"TS","slug":"TS","permalink":"https://bayeeaa.github.io/tags/TS/"},{"name":"JS","slug":"JS","permalink":"https://bayeeaa.github.io/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"https://bayeeaa.github.io/tags/CSS/"},{"name":"生活","slug":"生活","permalink":"https://bayeeaa.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}